{"./":{"url":"./","title":"首页","keywords":"","body":"YZJ's Blog 个人博客 Author: yangzejin Email: i@yangzejin.com GPT3/GPT4：gpt.yangzejin.com Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-08-24 08:46:02 "},"C++.html":{"url":"C++.html","title":"C++","keywords":"","body":"C++ 基础 C和C++的区别以及C++的特点 C语言是C++的子集，C++可以很好兼容C语言。但是C++11又有很多新特性引入了nullptr、auto变量、Lambda匿名函数、右值引用、智能指针。 C++是面向对象的编程语言，C++引入了新的数据类型 类，由此引申出了三大特性：封装、继承、多态。而C语言则是面向过程的编程语言。 C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来改善安全性，如const常量、引用、四类cast转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try—catch等等； C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL（Standard Template Library）。STL的一个重要特点是数据结构和算法的分离，其体现了泛型化程序设计的思想。C++的STL库相对于C语言的函数库更灵活、更通用。 C++语言编写出的程序结构清晰、易于扩充，程序可读性好 C++生成的代码质量高，运行效率高，仅比汇编语言慢10%～20%； include头文件双引号\"\"和尖括号<>的区别？ 区别： 尖括号<>的头文件是系统文件，双引号\"\"的头文件是自定义文件，编译器预处理阶段查找头文件的路径不一样。 查找路径： <>的头文件：编译器设置的头文件路径-->系统变量。 \"\"的头文件：默认从项目当前目录查找头文件。 动态链接与静态链接区别？ 静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。 动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。 区别 静态链接是将各个模块的obj和库链接成一个完整的可执行程序；而动态链接是程序在运行的时候寻找动态库的函数符号（重定位） 静态链接运行快、可独立运行；动态链接运行较慢(事实上，动态库被广泛使用，这个缺点可以忽略)、不可独立运行。 静态链接浪费空间，存在多个副本，同一个函数的多次调用会被多次链接进可执行程序，当库和模块修改时，main也需要重编译；动态链接节省空间，相同的函数只有一份，当库和模块修改时，main不需要重编译。 静态类型/动态类型和静态绑定/动态绑定 静态类型：对象在声明时采用的类型，在编译期既已确定； 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的； 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期； 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期； 非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态性）。 代码到可执行文件过程？ gcc是GNU编译器合集，能编译C, C++, Objective-C, Objective-C++, Fortran, Ada, D, Go, and BRIG (HSAIL)多种语言，g++能编译 c & c++，g++会自动链接标准库STL，而gcc不会自动链接STL g++ test.cpp -o test或g++ test.cpp 会自动执行上述流程 g++ -std=c++11 a.cpp 支持c++11编译 -I参数是用来指定头文件所在目录 option 功能 举例 输出格式 -E 预处理 宏替换、头文件展开、去掉注释g++ -E test.cpp -o test.i *.i -S 生成汇编文件 g++ -S test.i -o test.s *. s -c 生成二进制文件,可被直接执行 g++ -c test.s -o test.o *. o -o 生成最终可执行文件 g++ test.o -o test *.out(默认) 原码、反码、补码？ 整型数值在计算机的存储里，最左边的一位代表符号位，0代表正数，1代表负数。 原码：为二进制的数，如：10 原码为0000 1010 反码：正数的反码与原码相同：如：10 原码为0000 1010，反码为0000 1010 负数为原码0变1，1变0，（符号位不变）：如：-10 原码为1000 1010，反码为1111 0101 补码：正数的补码与原码相同：如：10 原码为0000 1010，补码为0000 1010 负数的补码为反码加1：如：-10 反码为1111 0101，补码为1111 0110 正数：原码=反码=补码 负数：原码=反码（原码取反）=补码（反码＋1） 大端 小端？ 大端存储：字数据的高字节存储在低地址中 (网络字节序) 小端存储：字数据的低字节存储在低地址中 (主机字节序) 在Socket编程中，往往需要将操作系统所用的小端存储的IP地址转换为大端存储，这样才能进行网络传输 #include using namespace std; int main() { int a = 0x1234; //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分 char c = (char)(a); if (c == 0x12) cout 结构体和共用体的区别？ struct和union都是由多个不同的数据类型成员组成。 struct的所有成员都存在；但在任何同一时刻, union中只存放了一个被选中的成员，共用体是共用内存空间，所以每个成员都是读写同一个内存空间，那么内存空间里面的内容不停的被覆盖，而同一时刻，都只能操作一个成员变量。否则会出现读错误。 在不考虑字节对齐的情况下，struct变量的总长度等于所有成员长度之和。Union变量的长度等于最长的成员的长度。 struct的不同成员赋值是互不影响的；而对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了。 枚举 enum是一个派生数据类型，可以声明、定义一个整型常数集合。所不同的是，集合里面的整型常数是用其他名字代替的，但只是代替，其本质还是一个整型常数。（默认从0开始顺序定义，常用于定义状态码） C++中 struct 和 class 的区别？ struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装； struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的，例如： struct A{ int iNum; // 默认访问控制权限是 public } class B{ int iNum; // 默认访问控制权限是 private } 在继承关系中，struct 默认是公有继承，而 class 是私有继承； class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数，例如： template // 可以把typename 换成 class int Func(const T& t, const Y& y) { //TODO } C++结构体和C结构体的区别？ （1）C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数。 （2）C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种。 （3）C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的。 （4）C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用。 C++有几种传值方式，区别是什么？ 值传递：形参即使在函数体内值发生变化，也不会影响实参的值；在函数传参的过程中，函数会为形参申请新的内存空间，并将实参的值复制给形参。形参的改变当然不会影响实参的值。 引用传递：形参在函数体内值发生变化，会影响实参的值； 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值； 全局变量和局部变量的区别？ 作用域不同：全局变量的作用域为整个程序，而局部变量的作用域为当前函数或循环等 内存存储方式不同：全局变量存储在全局数据区中，局部变量存储在栈区 生命期不同：全局变量的生命期和主程序一样，随程序的销毁而销毁，局部变量在函数内部或循环内部，随函数的退出或循环退出就不存在了 使用方式不同：全局变量在声明后程序的各个部分都可以用到，但是局部变量只能在局部使用。函数内部会优先使用局部变量再使用全局变量。 当局部变量被定义时，系统不会对其初始化，必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值： 数据类型 初始化默认值 int 0 char '\\0' float 0 double 0 pointer NULL C++内存分布模型 如上图，从低地址到高地址，一个程序由代码段、数据段、BSS段、堆栈段组成。 代码段：存放程序执行代码的一块内存区域。只读，不允许修改，代码段的头部还会包含一些只读的常量，如字符串常量字面值（注意：const变量虽然属于常量，但是本质还是变量，不存储于代码段）。 数据段data：存放程序中已初始化的非零全局变量和静态变量的一块内存区域。 BSS 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。 可执行程序在运行时又会多出两个区域：堆区和栈区。 堆区：动态申请内存用。堆从低地址向高地址增长。 栈区：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。 最后还有一个文件映射区（共享区），位于堆和栈之间。 初始化为0的全局变量在bss还是data？ BSS段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。 堆和栈的区别？ 堆栈空间分配不同。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等，栈有着很高的效率；堆一般由程序员分配释放，堆的效率比栈要低的多。 堆栈缓存方式不同。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。 空间大小： 栈的空间大小并不大，一般最多为2M，超过之后会报Overflow错误。堆的空间非常大，理论上可以接近3G。（针对32位程序来说，可以看到内存分布，1G用于内核空间，用户空间中栈、BSS、data又要占一部分，所以堆理论上可以接近3G，实际上在2G-3G之间）。 能否产生碎片： 栈的操作与数据结构中的栈用法是类似的。‘后进先出’的原则，以至于不可能有一个空的内存块从栈被弹出。因为在它弹出之前，在它上面的后进栈的数据已经被弹出。它是严格按照栈的规则来执行。但是堆是通过new/malloc随机申请的空间，频繁的调用它们，则会产生大量的内存碎片。这是不可避免地。 什么是野指针/悬空指针，如何避免？ 野指针就是没有被初始化的指针 悬空指针是指指针指向的内存空间已被释放或不再有效。 如何避免： 野指针：指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。 悬空指针：指针free或delete之后没有及时置空 => 释放操作后立即置空。 使用时不要超出指针作用域 使用智能指针 数组和指针的区别？ 数组：数组是用于储存多个相同类型数据的集合。 数组名是首元素的地址。 指针：指针相当于一个变量，但是它和普通变量不一样，它存放的是其它变量在内存中的地址。指针名指向了内存的首地址。 区别： 赋值：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝 存储方式： 数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，数组的存储空间，不是在静态区就是在栈上。 指针：指针本身就是一个变量，作为局部变量时存储在栈上。 sizeof：数组所占存储空间的内存大小：sizeof（数组名）/sizeof（数据类型） 32位平台下，sizeof（指针名）=4，64位平台下，sizeof（指针名）=8。 引用和指针的区别？ 指针是实体，占用内存空间；引用是别名，与变量共享内存空间。 指针不用初始化或初始化为NULL；引用定义时必须初始化。 指针中途可以修改指向；引用不可以。 指针可以为NULL；引用不能为空。 sizeof(指针)计算的是指针本身的大小；而sizeof(引用)计算的是它引用的对象的大小。 如果返回的是动态分配的内存或对象，必须使用指针，使用引用会产生内存泄漏。 指针使用时需要解引用；引用使用时不需要解引用‘*’。 有二级指针；没有二级引用。 数组指针与指针数组的区别？ 数组指针是一个指针变量，指向了一个一维数组， 如int (*p)[4]，(*p)[4]就成了一个二维数组，p也称行指针；指针数组是一个数组，只不过数组的元素存储的是指针变量, 如int *p[4]。 指针函数与函数指针的区别？ 指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数。 指针函数：int *fun(int x,int y); 函数指针：int (*fun)(int x,int y); 指针函数返回一个指针。 函数指针使用过程中指向一个函数。通常用于回调函数的应用场景。 回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。 const的作用？ 指针常量（顶层const）和常量指针（底层const） const修饰普通类型的变量，告诉编译器某值是保持不变的。 const 修饰指针变量，根据const出现的位置和出现的次数分为三种 常量指针：指针指向一个常量对象，目的是防止使用该指针来修改指向的值。const int* ptr; 指针常量：将指针本身声明为常量，这样可以防止改变指针指向的位置。int* const ptr; 指向常量的常指针：一个常量指针指向一个常量对象。 const修饰参数传递，可以分为三种情况。 值传递的 const 修饰传递，一般这种情况不需要 const 修饰 当 const 参数为指针时，可以防止指针被意外篡改。 自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。 const修饰函数返回值，分三种情况。 const 修饰内置类型的返回值，修饰与不修饰返回值作用一样。 const 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。 const 修饰返回的指针或者引用，是否返回一个指向 const 的指针，取决于我们想让用户干什么。 const修饰类成员函数 const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。 常量对象可以调用类中的 const 成员函数，但不能调用非 const 成员函数; (原因:对象调用成员函数时，在形参列表的最前面加一个形参 this，但这是隐式的。this 指针是默认指向调用函数的当前对象的，所以，很自然， this 是一个常量指针 test const，因为不可以修改 this 指针代表的地址。但当成员函数的参数列表(即小括号) 后加了 const 关键字(void print() const;)，此成员函数为常量成员函数，此时它的隐式this形参为 const test const，即不可以通过 this 指针来改变指向对象的值。 static的作用？ 控制变量的存储方式和可⻅性 1.静态局部变量 用于函数体内部修饰变量 （1）该变量在全局数据区分配内存(局部变量在栈区分配内存); （2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化(局部变量每次函数调用都会被初始化); （3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0(局部变量不会被初始化); （4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，也就是不能在函数体外面使用它(局部变量在栈区，在函数结束后立即释放内存); 2.静态全局变量和静态函数 定义在函数体外，用于修饰全局变量，表示该变量只在本文件可见。 （1）静态全局变量不能被其它文件所用(全局变量可以); （2）其它文件中可以定义相同名字的变量，不会发生冲突(自然了，因为static隔离了文件，其它文件使用相同的名字的变量，也跟它没关系了); 3.静态成员变量 所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享； 不需要实例化对象即可访问 注意不能再类内部初始化！要在类外部初始化，初始化时不加static！(如果类外定义函数时在函数名前加了static，因为作用域的限制，就只能在当前cpp里用，歧义) 4.静态成员函数 这个函数不接受this指针，只能访问类的静态成员 这个函数不需要实例化对象即可访问 为什么静态成员变量不能在类内初始化？ 因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。 为什么静态成员函数不能访问非静态成员？ 静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。 为什么要少使用#define？ 由程序编译的四个过程，知道宏是在预编译阶段被展开的。在预编译阶段是不会进行语法检查、语义分析的，宏被暴力替换，正是因为如此，如果不注意细节，宏的使用很容易出现问题。比如在表达式中忘记加括号等问题。 正因为如此，在C++中为了安全性，我们就要少用宏。 不带参数的宏命令我们可以用常量const来替代，比如const int PI = 3.1415，可以起到同样的效果，而且还比宏安全，因为这条语句会在编译阶段进行语法检查。 而带参数的宏命令有点类似函数的功能，在C++中可以使用内联函数或模板来替代，内联函数与宏命令功能相似，是在调用函数的地方，用函数体直接替换。但是内联函数比宏命令安全，因为内联函数的替换发生在编译阶段，同样会进行语法检查、语义分析等，而宏命令发生在预编译阶段，属于暴力替换，并不安全。 什么是内联函数？ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。 内联函数的作用：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。 为什么使用内联函数？ 函数调用是有调用开销的，执行速度要慢很多，调用函数要先保存寄存器，返回时再恢复，复制实参等等。 如果本身函数体很简单，那么函数调用的开销将远大于函数体执行的开销。为了减少这种开销，我们才使用内联函数。 内联函数使用的条件 以下情况不宜使用内联： （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。 内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。 不能被重载的运算符 1、 . （成员访问运算符） 2、* （成员指针访问运算符） 3、:: （域运算符） 4、sizeof （长度运算法） 5、? : （条件运算符） 四种强制类型转换 xxx_cast (expression); static_cast 最常见的类型转换。它可以用于基本数据类型之间的转换，也可以用于指向父类和子类之间的指针或引用的转换 基本数据类型之间的转换。 将任何类型转换为void类型。 将空指针转换成目标类型的指针。 用于类层次结构中基类和派生类之间指针或引用的转换。向上转换（派生类转换为基类）是安全的；向下转换（基类转换为派生类）没有动态类型检查，是不安全的。 int i = 10; double d = static_cast(i); // 整型转为浮点型 dynamic_cast 主要用于处理基类和派生类之间的转换。如果类型转换不安全，它会返回空指针NULL。这是唯一一种在运行时执行类型检查的转换。要求转换的类具有多态性质(虚函数)。type-id:类的指针、引用、void* Base *b = new Derived(); Derived *d = dynamic_cast(b); // 基类指针转为派生类指针 if (d != nullptr) { // 转换成功 } else { // 转换失败 } const_cast 用于修改常量对象的常量属性。需要注意的是，使用 const_cast 去掉常量性质并修改数据可能导致未定义的行为。**只能用于转换指针或引用，type_id和expression的类型是一样的。 int num = 100; const int* p1 = &num; //将常量指针转换为普通类型指针，去除const属性 int* p2 = const_cast(p1); *p2 = 200; int a = 100; const int& ra = a; //将常量引用转换为普通类型引用，去除const属性 int& ra1 = const_cast(ra); ra1 = 200; reinterpret_cast 允许进行任何指针或整型的转换。它可以将任何类型的指针转换为任何其他类型的指针，将指针或引用转换为一个整型，将一个整型转换为指针或引用类型要转换的类型必须是指针、引用或算术类型。 char c = 'a'; int d = reinterpret_cast(c); int* p=NULL; float* q = NULL; p = reinterpret_cast(q); q = reinterpret_cast(q); 智能指针 智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，智能指针实质是一个对象，行为表现的却像一个指针。智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，自动释放资源。这样程序员就不用再担心内存泄露的问题了。 C++里面有四个指针：auto_ptr、unique_ptr、shared_ptr、weak_ptr，auto_ptr被C++11弃用（存在潜在的内存崩溃问题）。 shared_ptr shared_ptr 实现共享式拥有概念，智能指针可以指向相同对象。该对象和其相关资源会在最后一个引用被销毁时候释放。 实现原理： 构造函数中计数值初始化为1 拷贝构造函数中计数值加1 赋值运算中，左边的对象引用计数减去1，右边的对象引用计数加上1 析构函数中引用计数要减去1 在赋值和析构函数中，如果计数值减去1后为0，则调用delete释放对象 weak_ptr weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。 解决shared_ptr内存泄露，共享指针的循环引用计数问题：当两个类中相互定义shared_ptr成员变量，同时对象相互赋值时，就会产生循环引用计数问题，最后引用计数无法清零，资源得不到释放。 可以使用weak_ptr，weak_ptr是弱引用，weak_ptr的构造和析构不会引起引用计数的增加或减少。我们可以将其中一个改为weak_ptr指针就可以了。 unique_ptr unique指针规定一个智能指针独占一块内存资源。当两个智能指针同时指向一块内存，编译报错。 保证同一时间内只有一个智能指针可以指向该对象。 实现原理：只需要将拷贝构造函数和赋值拷贝构造函数申明为private或delete。不允许拷贝构造函数和赋值操作符 unique_ptr p3 (new string (auto));//#4 unique_ptr p4;//#5 p4 = p3;//此时会报错 成员函数 //unique_ptr release(); // 返回一个指向被管理对象的指针，并释放所有权 reset(); //替换被管理对象 swap(); //交换被管理对象 get(); //返回指向被管理对象的指针 //shared_ptr reset(); //替换被管理对象 swap(); //交换被管理对象 get(); //返回指向被管理对象的指针 use_count(); //返回 shared_ptr 所指对象的引用计数 //weak_ptr reset(); //替换被管理对象 swap(); //交换被管理对象 use_count(); //返回 shared_ptr 所指对象的引用计数 lock(); //创建管理被引用的对象的shared_ptr 类 对象 面向对象和面向过程的区别？ 面向过程（Procedure Oriented 简称 PO）：把事情拆分成几个步骤（相当于拆分成一个个的方法和数据），然后按照一定的顺序执行。 面向对象（Object Oriented 简称 OO）：面向对象会把事物抽象成对象的概念，先抽象出对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法。 C++有几种构造函数？ 默认构造函数 初始化构造函数（有参数） 拷贝构造函数 移动构造函数（move和右值引用） 委托构造函数 转换构造函数 #include using namespace std; class Student{ public: Student(){//默认构造函数，没有参数 this->age = 20; this->num = 1000; }; Student(int a, int n):age(a), num(n){}; //初始化构造函数，有参数和参数列表 Student(const Student& s){//拷贝构造函数，这里与编译器生成的一致 this->age = s.age; this->num = s.num; }; Student(int r){ //转换构造函数,形参是其他类型变量，且只有一个形参 this->age = r; this->num = 1002; }; ~Student(){} public: int age; int num; }; int main(){ Student s1; Student s2(18,1001); int a = 10; Student s3(a); Student s4(s3); printf(\"s1 age:%d, num:%d\\n\", s1.age, s1.num); printf(\"s2 age:%d, num:%d\\n\", s2.age, s2.num); printf(\"s3 age:%d, num:%d\\n\", s3.age, s3.num); printf(\"s2 age:%d, num:%d\\n\", s4.age, s4.num); return 0; } //运行结果 //s1 age:20, num:1000 //s2 age:18, num:1001 //s3 age:10, num:1002 //s2 age:10, num:1002 成员初始化列表 用初始化列表会快一些的原因是，对于类型，它少了一次调用构造函数的过程，而在函数体中赋值则会多一次调用。而对于内置数据类型则没有差别。 class complex { public: complex(double r = 0, double i = 0) : re(r), im(i) {} complex& operator += (const complex&) double real () const { return re; } double imag () const { return im; } private: double re, im; friend complex& __doapl (complex* , const complex&); } 拷贝构造函数和赋值运算符重载的区别？ 赋值运算符 对象存在，用别的对象给它赋值，这属于重载“=”号运算符的范畴，“=”号两侧的对象都是已存在的。 拷贝构造函数是函数，赋值运算符是运算符重载。 拷贝构造函数会生成新的类对象，赋值运算符不能。 拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。 形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现\"=\"的地方都是使用赋值运算符，如下： Student s; Student s1 = s; // 调用拷贝构造函数 Student s2; s2 = s; // 赋值运算符操作 注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符。 拷贝构造函数的参数类型为什么必须是引用? 如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。否则无法完成拷贝，而且栈也会满。 什么情况下会调用拷⻉构造函数？ 类的对象需要拷⻉时，拷⻉构造函数将会被调用，以下的情况都会调用拷⻉构造函数: 一个对象以值传递的方式传入函数体，需要拷⻉构造函数创建一个临时对象压入到栈空间中。 一个对象以值传递的方式从函数返回，需要执行拷⻉构造函数创建一个临时对象作为返回值。 一个对象需要通过另外一个对象进行初始化。 左值和右值？ C++ 中有两种类型的表达式： 左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。 变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。 右值引用的作用？ C++11引入右值引用&&主要是为了实现移动语义和完美转发。 移动语义为了避免临时对象的拷贝，为类增加移动构造函数。 完美转发，就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的。 移动语义的原理？ 移动语义为了避免临时对象的拷贝，为类增加移动构造函数。移动构造函数与拷贝构造不同，它并不是重新分配一块新的空间同时将要拷贝的对象复制过来，而是\"拿\"了过来，将自己的指针指向别人的资源，然后将别人的指针修改为nullptr 类的访问权限有几种？ 公有成员（变量和函数）允许类成员和类外的任何访问，由public限定； 私有成员（变量和函数）只限于类成员访问，由private限定； 受保护成员（变量和函数）允许类成员和派生类成员访问，不允许类外的任何访问。所以protected对外封闭，对派生类开放。 继承类型和访问属性 当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。 我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则： 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。 总结: 不管是哪种继承方式，派生类中新增成员可以访问基类的公有成员和保护成员，无法访问私有成员。但是只有公有继承中，派生类的对象能访问基类的公有成员。使用友元（friend）可以访问保护成员和私有成员。 多继承存在什么问题？如何消除多继承的二义性？ 多继承会增加程序的复杂度，使得程序的编写和维护比较困难，容易出错 在继承时，基类之间或基类与派生类之间发生成员同名时，将出现对成员访问的不确定性，即同名二义性； 消除二义性的方法： 利用作用域运算符 ::，用于限定派生类使用的是哪个基类的成员 在派生类中定义同名成员，覆盖基类的相关成员 当派生类从多个基类派生,这些基类又从同一基类派生,咋在访问此共同基类的成员时,将产生另一种不确定性,即路径二义性: 消除路径二义性的方法: 消除同名二义性的两种方法同样有用 还可以使用虚继承，使得不同路径继承来的同名成员在内存中只有一份拷贝。 虚基类与虚继承是什么？ 多继承很容易产生错误，典型的就是菱形继承，是一种路径二义性的情况： 在一个派生类中保留间接基类的多份同名成员，虽然可以在不同的成员变量中分别存放不同的数据，但大多数情况下这是多余的：因为保留多份成员变量不仅占用较多的存储空间，还容易产生命名冲突。假如类 A 有一个成员变量 a，那么在类 D 中直接访问 a 就会产生歧义，编译器不知道它究竟来自 A -->B-->D 这条路径，还是来自 A-->C-->D 这条路径。下面是菱形继承的具体实现： //间接基类A class A{ protected: int m_a; }; //直接基类B class B: public A{ protected: int m_b; }; //直接基类C class C: public A{ protected: int m_c; }; //派生类D class D: public B, public C{ public: void seta(int a){ m_a = a; } //命名冲突 // 因为类 B 和类 C 中都有成员变量 m_a（从 A 类继承而来），编译器不知道选用哪一个，所以产生了歧义。 void setb(int b){ m_b = b; } //正确 void setc(int c){ m_c = c; } //正确 void setd(int d){ m_d = d; } //正确 private: int m_d; }; int main(){ D d; return 0; } 利用作用域运算符 ::消除二义性： void seta(int a){ B::m_a = a; } // 表示使用 B 类的 m_a，反之使用C的同理 利用虚继承解决：在继承方式前面加上 virtual 关键字就是虚继承 //间接基类A class A{ protected: int m_a; }; //直接基类B class B: virtual public A{ //虚继承 protected: int m_b; }; //直接基类C class C: virtual public A{ //虚继承 protected: int m_c; }; //派生类D class D: public B, public C{ public: void seta(int a){ m_a = a; } //正确 void setb(int b){ m_b = b; } //正确 void setc(int c){ m_c = c; } //正确 void setd(int d){ m_d = d; } //正确 private: int m_d; }; int main(){ D d; return 0; } 这段代码使用虚继承重新实现了上图所示的菱形继承，这样在派生类 D 中就只保留了一份成员变量 m_a，直接访问就不会再有歧义了。 虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。 C++标准库中的 iostream 类就是一个虚继承的实际应用案例。iostream 从 istream 和 ostream 直接继承而来，而 istream 和 ostream 又都继承自一个共同的名为 base_ios 的类，是典型的菱形继承。此时 istream 和 ostream 必须采用虚继承，否则将导致 iostream 类中保留两份 base_ios 类的成员。 多态的实现？ 利用虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism）。 多态其实一般就是指继承加虚函数实现的多态，多态可以分为静态多态和动态多态。静态多态其实就是重载，因为静态多态是指在编译时期就决定了调用哪个函数，根据参数列表来决定;动态多态是指通过子类重写父类的虚函数来实现的，因为是在运行期间决定调用的函数，所以称为动态多态，一般情况下我们不区分这两个时所说的多态就是指动态多态。 虚函数的实现原理 C++实现虚函数的原理是虚函数表+虚表指针。 当一个类里存在虚函数时，编译器会为类创建一个虚函数表，虚函数表是一个数组，数组的元素存放的是类中虚函数的地址。 同时为每个类的对象添加一个隐藏成员，该隐藏成员保存了指向该虚函数表的指针。该隐藏成员占据该对象的内存布局的最前端。 虚函数表在什么时候创建？每个对象都有一份虚函数表吗？ 当一个类里存在虚函数时，编译器会为类创建一个虚函数表，发生在编译期。 虚函数表只有一份，而有多少个对象，就对应多少个虚函数表指针。 虚函数表指针是虚函数表所在位置的地址。虚函数表指针属于对象实例。因而通过new 出来的对象的虚函数表指针位于堆，声名对象的虚函数表指针位于栈。 虚函数表位于只读数据段（.rodata），即：C++内存模型中的常量区(用于维护只读数据，比如：常量字符串、带 const 修饰的全局变量和静态变量等)； 虚函数代码则位于代码段（.text），也就是C++内存模型中的代码区 纯虚函数？ virtual void fun() = 0; 纯虚函数的类称为抽象类（Abstract Class）。之所以说它抽象，是因为它无法实例化，也就是无法创建对象。原因很明显，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间。 抽象类通常是作为基类，让派生类去实现纯虚函数。派生类必须实现纯虚函数才能被实例化。 析构函数必须为虚函数吗？构造函数可以为虚函数吗？ C++默认析构函数不是虚函数，因为申明虚函数会创建虚函数表，占用一定内存，当不存在继承的关系时，析构函数不需要申明为虚函数。 若存在继承关系时，析构函数必须申明为虚函数，这样父类指针指向子类对象，释放基类指针时才会调用子类的析构函数释放资源，否则内存泄漏。 构造函数不能为虚函数，当申明一个函数为虚函数时，会创建虚函数表，那么这个函数的调用方式是通过虚函数表来调用。若构造函数为虚函数，说明调用方式是通过虚函数表调用，需要借助虚表指针，但是没构造对象，哪里来的虚表指针？但是没有虚表指针，怎么访问虚函数表从而调用构造函数呢？这就成了一个先有鸡还是先有蛋的问题。 构造与析构的顺序？ 构造顺序：基类构造函数>对象成员构造函数>子类构造函数 析构顺序：子类析构函数>对象成员析构函数>基类析构函数 从里向外构造，从外向里析构。 深拷贝与浅拷贝的区别？ 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 什么是this指针？ 在每一个成员函数中都包含一个特殊的指针，这个指针的名字是固定的，称为this指针。它是指向本类对象的指针，它的值是当前被调用的成员函数所在的对象的起始地址。 this是一个指针，它时时刻刻指向你这个实例本身。 this在成员函数的开始执行前构造，在成员的执行结束后清除。 重载、重写、隐藏？ 重载overload 函数名相同，参数列表不同（参数类型、参数顺序),不能用返回值区分。 特点：作用域相同；函数名相同；参数列表必须不同，但返回值无要求； 特殊情况：若某一重载版本的函数前面有virtual关键字修饰，则表示它是虚函数，但它也是重载的一个版本。 作用效果：编译器根据函数不同的参数列表，将函数与函数调用进行早绑定，重载与多态无关，与面向对象无关，它只是一种语言特性。 重写override 派生类重定义基类的虚函数，既会覆盖基类的虚函数(多态)。 特点：作用域不同；函数名、参数列表、返回值相同；基类函数是virtual； 特殊情况：若派生类重写函数是一个重载版本，那么基类的其他同名重载函数将在子类中隐藏。 作用效果：父类指针和引用指向子类的实例时，通过父类指针或引用可以调用子类的函数，这就是C++的多态。 隐藏hide 隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数。 两个函数参数相同，但是基类函数不是虚函数。和重写的区别在于基类函数是否是虚函数。 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。 空类大小？ sizeof(A) 的值为1，因为编译器需要区分这个空类的不同实例，分配一个字节，可以使这个空类的不同实例拥有一个独一无二的地址，这样空类在实例化后在内存得到了独一无二的地址，所以空类所占的内存大小是1个字节。 空类有哪些成员函数？ class Empty { public: Empty(); // 缺省构造函数 Empty( const Empty& ); // 拷贝构造函数 ~Empty(); // 析构函数 Empty& operator=( const Empty& ); // 赋值运算符 Empty* operator&(); // 取址运算符 const Empty* operator&() const; // 取址运算符 const }; 友元类和友元函数？ 友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。但是另一个类里面也要相应的进行声明。 友元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员和保护成员。但是需要在类的定义中声明所有可以访问它的友元函数。 友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。 模板 程序所实现的功能基本相同，不同的仅是数据类型不同。而模板正是一种专门处理不同数据类型的机制。 #include using namespace std; template//函数模板 type1 Max(type1 a,type2 b) { return a > b ? a : b; } void main() { cout 该模板有个比较隐晦的bug，那就是a、b只有在能进行转型的时候才能进行比较，否则 a > b 这一步是会报错的，这个时候往往需要对于 > 号进行重载。 模版特例化 定义:对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上 模板函数特例化 必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对<>，表明将原模板的所有模板参数提供实参 注意:模板及其特例化版本应该声明在同一个头文件中，且所有同名模板的声明应该放在前面，后面放特例化版本。 类模板特例化 原理类似函数模板，不过在类中，我们可以对模板进行特例化，也可以对类进行部分特例化。对类进行特例化时，仍然用template<>表示是一个特例化版本。 类模板的部分特例化 不必为所有模板参数提供实参，可以指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板，使用它时还必须为其特例化版本中未指定的模板参数提供实参(特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板) explicit explicit 关键字只能用于类内部的构造函数声明上 被explicit修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显式的方式进行类型转换 final override final来限制某个类不能被继承，或者某个虚函数不能被重写。如果修饰函数，final只能修饰虚函数，并且要放到类或者函数的后面 override确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也明确表明将会重写基类的虚函数，还可以防止因疏忽把本来想重写基类的虚函数声明成隐藏。 extern 关键字：在C++中，导入C函数的关键字是extern，表达形式为extern “C”， extern \"C\"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern \"C\"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。 声明外部变量/函数：当你在一个文件中声明变量/函数，但实际的定义在另一个文件中时，你可以使用extern关键字来告诉编译器该变量是在其他文件中定义的。 编译区别：由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 assert assert(expr) 如果expr表达式为假，assert输出信息并终止程序执行，如果为真，assert什么也不做。 #ifdef、#else、#endif、#ifndef的作用？ 作用一：条件编译 一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。 #ifdef 标识符 程序段 1 #else 程序段 2 #endif 它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2。 作用二：避免文件重定义 在一个大的软件工程里面，可能会有多个文件同时包含一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量“重定义”错误。在头文件中使用#define、#ifndef、#ifdef、#endif能 避免头文件重定义。 volatile mutable volatile的变量是说这变量可能会被意想不到地改变，系统总是重新从它所在的内存读取数据。每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。多线程中被几个任务共享的变量需要定义为volatile类型。 mutable是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中，甚至结构体变量或者类对象为const，其mutable成员也可以被修改。mutable在类中只能够修饰非静态数据成员。 如何定义一个只能在堆上（栈上）生成的对象的类？ 只能在堆上 方法：将析构函数设为私有 原因：C++ 是静态綁定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。 只能在栈上 方法：将new 和delete 重载为私有 原因：在堆上生成对象，使用new 关键词操作，其过程分为两阶段：第一阶段，使用new在堆上寻找可用内存，分配给对象;第二阶段，调用构造函数生成对象。将new操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。 内存管理 什么是内存泄露？ 简单地说就是申请了一块内存空间，使用完毕后没有释放掉。 （1）new和malloc申请资源使用后，没有用delete和free释放； （2）子类继承父类时，父类析构函数不是虚函数。 （3）比如文件句柄、socket、自定义资源类没有使用对应的资源释放函数。 （4）shared_ptr共享指针成环，造成循环引用计数，资源得不到释放。 如何避免内存泄漏？ 良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。 将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。 使用智能指针。 一些常见的工具插件可以帮助检测内存泄露，如ccmalloc、Dmalloc、Leaky、Valgrind等等。 new/delete和malloc/free的异同？ int *p = new int[2]; int *q = (int *)malloc(2*sizeof(int)); 都可用于内存的动态申请和释放 new是操作符，而malloc是函数。 new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。 malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。 new可以被重载；malloc不行 new分配内存更直接和安全。 new发生错误抛出异常，malloc返回null new/delete实现原理？ new的实现过程是：首先调用名为operator new的标准库函数，分配足够大的原始为类型化的内存，以保存指定类型的一个对象；接下来运行该类型的一个构造函数，用指定初始化构造对象；最后返回指向新分配并构造后的的对象的指针 delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存 //operator new：该函数实际通过malloc来申请空间，当malloc申请空间成功时直接返回；申请空间失败， //尝试执行空间不足应对措施，如果改应对措施用户设置了，则继续申请，否则抛异常。 void *__CRTDECL operator new(size_t size) _THROW1(_STD bad_alloc) { // try to allocate size bytes void *p; while ((p = malloc(size)) == 0) if (_callnewh(size) == 0) { // report no memory // 如果申请内存失败了，这里会抛出bad_alloc 类型异常 static const std::bad_alloc nomem; _RAISE(nomem); } return (p); } malloc/free实现原理？ malloc 在申请内存时，一般会通过brk 或者mmap系统调用进行申请。 申请内存小于128K时，会使用系统函数brk在堆区中分配； 当申请内存大于128K时，会使用系统函数mmap在映射区分配。 brk是将数据段(.data)的最高地址指针_edata往高地址推； mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。 什么是字节对齐？ 为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，即所谓的“对齐”，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除，也即“对齐”跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。 为什么要字节对齐？ （1）需要字节对齐的根本原因在于CPU访问数据的效率问题。 （2）一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。 （3）各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始 结构体字节对齐三原则： 1.每个数据成员存储起始位置要从该成员大小的整数倍开始 2.结构体作为成员时应从内部最大元素的整数倍地址开始存储 3.结构体总大小为内部最大成员的整数倍 STL vector deque（双端数组） list（双向链表） queue stack set/unordered_set map/unordered_map 是否支持迭代器 × × 尾部添加 push_back push_back push_back push 尾部删除 pop_back pop_back pop_back 首部添加 push_front push_front push 首部删除 pop_front pop_front pop pop 插入（迭代器） insert insert insert insert insert 删除（迭代器） erase erase erase erase(key) erase(key) 改变大小 resize resize resize 交换内容 swap swap swap swap swap 清除 clear clear clear clear clear 是否为空 empty empty empty empty empty empty empty 大小 size size size size size size size 第一个元素 front front front front 最后一个元素 back back back back 访问元素 at() at() at() top（栈顶） 指定键的个数 count count 寻找指定键 存在返回迭代器，反之返回s.end() find find vector> dp(n,vector(m,0)) n行m列二维数组 vector访问元素的速度要比deque快 set不允许出现重复 所有的元素都会被自动排序（默认从小到大） 不能直接修改它的元素值 multiset 允许出现键值重复，unordered_set unordered_multiset元素不会自动排序 map中是pair p(key,value) map.first是key 只出现一次 map.second是value map[key]=value map[x]++ 把key放在map中计数 迭代器 迭代器是类模板不是指针（表现得像指针） container::iterator iter container::const_iterator citer *iter :返回迭代器iter所指元素引用 iter->mem :等价于(*iter).mem，解引用iter并获取该元素的名为mem的成员 ++iter :令iter指示容器中的下一个元素 --iter :令iter指示容器中的上一个元素 iter + n:迭代器加上一个整数仍得一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。 iter - n:迭代器减去一个整数仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。 C++11新特性 lambda 函数式编程 lambda 的形式 C++ 没有为 lambda 表达式引入新的关键字，并没有“lambda”这样的词汇，而是用了一个特殊的形式“[]”，术语叫“lambda 引出符”（lambda introducer）。在 lambda 引出符后面，就可以像普通函数那样，用圆括号声明入口参数，用花括号定义函数体，方便写程序，使程序代码更加简洁。 auto f1 = [](){}; // 相当于空函数，什么也不做 auto f2 = []() // 定义一个lambda表达式 { cout C++ 里，每个 lambda 表达式都会有一个独特的类型，而这个类型只有编译器才知道，我们是无法直接写出来的，所以必须用 auto。 不过，因为 lambda 表达式毕竟不是普通的变量，所以 C++ 也鼓励程序员尽量“匿名”使用 lambda 表达式。也就是说，它不必显式赋值给一个有名字的变量，直接声明就能用。 由于“匿名”，lambda 表达式调用完后也就不存在了（也有被拷贝保存的可能），这就最小化了它的影响范围，让代码更加安全。 vector v = {3, 1, 8, 5, 0}; // 标准容器 cout = 5; // 用做算法的谓词判断条件 } // lambda表达式结束 ) find_if()的第三个参数是一个 lambda 表达式的谓词。这个 lambda 表达式以值的方式捕获 value，并在 lambda 参数大于 value 时返回 true。 lambda的变量捕获 lambda 的“捕获”功能需要在“[]”里做文章，由于实际的规则太多太细，记忆、理解的成本高，所以记住几个要点： “[=]”表示按值捕获所有外部变量，表达式内部是值的拷贝，并且不能修改； “[&]”是按引用捕获所有外部变量，内部以引用的方式使用，可以修改； 也可以在“[]”里明确写出外部变量名，指定按值或者按引用捕获，C++ 在这里给予了非常大的灵活性。 int x = 33; // 一个外部变量 auto f1 = [=]() // lambda表达式，用“=”按值捕获 { //x += 10; // x只读，不允许修改 }; auto f2 = [&]() // lambda表达式，用“&”按引用捕获 { x += 10; // x是引用，可以修改 }; auto f3 = [=, &x]() // lambda表达式，用“&”按引用捕获x，其他的按值捕获 { x += 20; // x是引用，可以修改 }; 在使用捕获功能的时候要小心，对于“就地”使用的小 lambda 表达式，可以用“[&]”来减少代码量，保持整洁；而对于非本地调用、生命周期较长的 lambda 表达式应慎用“[&]”捕获引用，而且，最好是在“[]”里显式写出变量列表，避免捕获不必要的变量。 class DemoLambda final { private: int x = 0; public: auto print() // 返回一个lambda表达式供外部使用 { return [this]() // 显式捕获this指针 { cout 泛型的 lambda C++14 里，lambda 表达式可以实现“泛型化”，相当于简化了的模板函数，具体语法利用了 auto： auto f = [](const auto& x) // 参数使用auto声明，泛型化 { return x + x; }; cout = default 和 = delete = default 和 =delete 是 C++11 新增的专门用于六大基本函数的用法，对于比较重要的构造函数和析构函数，应该用= default的形式，明确地告诉编译器：“应该实现这个函数，但我不想自己写。”这样编译器就得到了明确的指示，可以做更好的优化。 class DemoClass final { public: DemoClass() = default; // 明确告诉编译器，使用默认实现 ~DemoClass() = default; // 明确告诉编译器，使用默认实现 }; 另一种 = delete 的形式。表示明确地禁用某个函数形式，且不限于构造 / 析构，可以用于任何函数（成员函数、自由函数）。比如说，如果想要禁止对象拷贝，就可以用这种语法显式地把拷贝构造和拷贝赋值delete掉，让外界无法调用。 class DemoClass final { public: DemoClass(const DemoClass&) = delete; // 禁止拷贝构造 DemoClass& operator=(const DemoClass&) = delete; // 禁止拷贝赋值 }; 补充 sizeof和strlen有什么区别？ sizeof是一个操作符，strlen是库函数 sizeof计算的是数据类型占内存的大小，strlen计算的是字符串实际的长度 sizeof的参数可以是数据的类型，也可以是变量，但strlen的参数只能是以 \\0 为结尾的字符串 编译器在编译时就计算出了sizeof的结果，而strlen函数必须在运行时才能计算出来。 bind() 函数 #include std::bind(待绑定的函数对象/函数指针/成员函数指针,参数绑定值1,参数绑定值2,...,参数绑定值n); bind的第一个参数是待绑定的函数对象或者函数指针,之后跟随多个参数以设定待绑定函数的参数绑定方式。待绑定函数有多少个参数,则bind后便需要多少个参数以一一声明其参数的绑定方法.当参数绑定为某一固定值时,则其对应参数绑定值可以使一个变量或常量.当需要将参数与绑定所生成的函数对象的某个参数相关联时,则需要用到在标准中预定义的几个常量 _1、_2、_3等.这些常量声明在std::placeholders命名空间内为占位符来改变参数的顺序，并且可以设置函数中默认的几个参数来减少输入参数的数量。 move() 函数 template typename remove_reference::type&& move(T&& t) { return static_cast::type &&>(t); } 它唯一的功能是将一个左值引用强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。 GDB g++ -g 添加gdb调试选项 linux系统支持gdb，mac支持lldb。https://lldb.llvm.org/use/map.html为gdb和lldb命令对照表。 先编译生成.out文件g++ -g -std=c++11 a.cpp，gdb a.out进入调试页面，最后r或run运行。 b打断点，info breeak查看断点信息，del 1删除断点。 n或next继续执行 p、print打印变量或变量地址 s、step进入函数调试 shell ls可以使用终端命令等，set logging on打开日志模式 watchpoint查看变量是否变化，info查看watchpoint信息。 ulimit -a 调试core文件 Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-10-04 09:18:45 "},"STL.html":{"url":"STL.html","title":"STL","keywords":"","body":"STL 什么是STL、STL有哪些容器？ STL组成 简单概括： C++STL从广义上来讲包括了三类：算法，容器和迭代器 算法包括排序，拷贝等常用算法，以及不同容器特定的算法 容器就是数据的存放形式，包括序列容器和关联式容器 序列容器：list、vector等 关联容器：set、map等 迭代器就是在不暴露容器内部结构的情况下对容器的遍历 详细说明： 容器：一些封装数据结构的模板类，例如 vector 向量容器、list 列表容器等。 算法：STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件 中，少部分位于头文件 中。 迭代器：在C++STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。 函数对象：如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。 适配器：可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。 内存分配器：为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。 其中迭代器、函数对象、适配器、内存分配器这四部分是为容器和算法服务的： 算法通过迭代器获取容器中的内容 函数对象可以协助算法完成各种操作 适配器用来套接适配仿函数 内存分配器给容器分配存储空间 在惠普实验室最初发行的版本中，STL 被组织成 48 个头文件；但在 C++ 标准中，它们被重新组织为 13 个头文件： STL容器分类 标准库的容器分为三类：顺序容器、关联容器、容器适配器 顺序容器有五种 array 数组：固定大小数组，支持快速随机访问，但不能插入或删除元素 vector 动态数组：支持快速随机访问，尾部插入和删除的速度快 deque 双向队列：支持快速随机访问，首尾位置插入和删除速度快 list双向链表：只支持双向顺序访问，任何位置插入和删除速度都很快 forward_list 单向链表：只支持单向顺序访问，任何位置插入和删除的速度都很快 关联容器有两种 map容器： map multimap unordered_map unordered_multimap set容器： set multiset unordered_set unordered_multiset 容器适配器有三种： stack queue priority_queue vector 底层原理 vector底层是一个动态数组，包含三个迭代器，start 和 finish 之间是已经被使用的空间范围，end_of_storage是整块连续空间包括备用空间的尾部。 当空间不够装下数据（v.push_back(val)）时，会自动申请另一片更大的空间（1.5或2倍），然后把原来的数据拷贝到新的内存空间，然后释放原来的空间 当释放或删除（v.clear()）vector中的数据时，其存储空间不释放，只是清空了里面的数据 对vector的任何操作一旦引起了空间的重新分配，指向源vector的所有迭代器都会失效 vector中的 size 和 capacity 的区别？ size 表示当前vector有多少个元素（finish - start），而capacity函数则表示它已经分配的内存中可以容纳多少元素（end_of_storage - start） vector 中的 reserve 和 resize 的区别？ reserve是直接扩充到已经确定的大小（newSize = capacity），可以减少多次开辟、释放空间的问题（优化push_back）。就可以提高效率，其次还可以减少多次拷贝数据的问题。reserve只是保证vector中的空间大小（capacity，end_of_storage - start）最少达到参数所指定的大小n。 reserve (int n) resize( ) 可以改变有效空间的大小(newSize = newCapacity)，也能改变默认值的功能。capacity的大小也会随着改变。 resize（int n，element），扩容后每个元素的值为element，默认为0 vector的元素类型可以是引用吗？vector如何查找一个元素？ 不能，因为vector的底层实现要求连续的对象排列，引用并非对象，没有实际地址，因此vector的元素类型不能是引用。 find(vec.begin(),vec.end(),1); // 查找1 vector 迭代器失效的情况？ 当插入一个元素到vector中，由于引起了内存的重新分配，所以指向原内存的迭代器全部失效。 当删除容器中的一个元素后，该迭代器所指向的元素已经被删除，那么也造成迭代器的失效。 erase方法会返回下一个有效的迭代器，所以当我们要删除某个元素时，需要 it = vec.erase(it) it = vec.erase(it); vector如何正确释放内存？ vec.clear( ) : 清空内容，但不释放内存 vector( ).swap(vec) : 清空内容，且释放内存，得到一个全新的vector vec.shrink_to_fit ( ) : 请求容器降低其capacity 和 size 匹配 vec.clear( ) ; vec.shrink_to_fit ( ) : 清空内容，且释放内存。 vector扩容为什么要以 1.5 或 2 倍 扩容？ 以2倍方式扩容，导致下一次申请的内存必然大于之前分配的内存总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为1和2之间，即（1,2） $$ k\\sum^n_{i=0}2^i = k(2^{n+1}-1) $$ 在Win + VS 下是 1.5倍，在 Linux + GCC 下是 2 倍 频繁对vector调用push_back()对性能的影响和原因？ 在一个vector的尾部之外的任何位置添加元素，都需要重新移动元素。而且，想一个vector添加元素可能会引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移到新的空间，影响性能。 list 底层原理 list底层是一个双向链表，以节点为单位存放数据，结点的地址在内存中不一定连续，每次插入或删除一个元素，就分配或释放一个元素空间。 list不支持随机存取，适合需要大量的插入和删除，而不关心随机存取的应用场景。 list常用函数 list.push_back(elem); list.pop_back(); list.push_front(elem); list.size(); list.sort(); list.unique(); // 移除数值相同的连续元素 list.back(); // 取尾迭代器 list.erase(it); // 删除一个元素，返回删除元素的下一个迭代器 vector 和 list 的区别是什么？ vector 是连续存储的容器，动态数组，在堆上分配空间 底层实现：数组 两倍容量增长： vector 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后（插入指定位置），然后调整迭代器。 如果没有剩余空间了，则会重新配置给其原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。 性能： 随机存取访问，$O(1)$ 插入： 在最后插入（空间够）：$O(1)$ 在最后插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝 在中间和头部插入（空间够）：内存拷贝，需要挪动大量的数据，时间复杂度为$o(n)$ 删除： 末尾删除：$O(1)$ 中间删除：内存拷贝，$O(n)$ 适用场景：经常随机访问，且不经常对非尾结点进行插入删除 list 动态链表，在堆上分配空间，没插入一个元素都会分配相应空间，每删除一个元素都会释放相应空间。 底层实现：双向链表 性能： 访问：$O(n)$ 插入：$O(1)$ 删除：$O(1)$ 适用场景：经常插入删除大量数据 vector 和 list 区别 vector底层是现实数组，list底层实现是双向链表 vector支持随机访问性能好，插入删除性能差；list不支持随机访问，但插入删除性能好。 vector是顺序存储，list不是 vector在非尾节点进行插入删除会导致内存拷贝，list不会 vector是一次性分配好内存，不够时进行2倍扩容，list每次插入新结点都会进行内存申请。 map、set、multiset、multimap map、set、multiset、multimap的底层原理 map、set、multiset、multimap的底层实现都是红黑树，epoll模型的底层数据结构也是红黑树，Linux系统中CFS进程调度算法也用到了红黑树 红黑树的特性： 每个节点是红色或黑色的 根节点是黑色的 每个叶子节点是黑色的 如果一个节点是红的，则它的两个儿子均是黑色的 每个结点到其子孙节点NULL指针的所有路径上包含相同数目的黑色节点 红黑树详解： map、set、multiset、multimap的特点 set和multiset会根据特定的排序准则自动将元素排序，set中元素不重复，multiset可以重复 map和multimap将 key 和 value 组成的 pair 作为元素，根据key的排序准则自动将元素排序，map中key不允许重复，multimap可以重复 为何map和set的插入删除效率比其他序列容器高，而且每次insert之后，以前保存的迭代器不会失效？ 因为存储的是节点，不需要内存的拷贝和移动 因为插入操作知识节点指针的换来换去，节点内存没有改变。而迭代器就像指向节点的指针，内存没变，指向内存的指针也不会变。 为何map和set不能像vector一样有一个reserve函数来预分配数据？ 因为在map和set内部存储的已经不是元素本身了，而是包含元素的节点。也就是说map内部使用的Alloc并不是map声明的时候从参数传入的Alloc. map、set、multiset、multimap 常用函数？ mp.count(key) > 0; // 统计的是key出现的次数，只能是0或1 mp.find(key) != mp.end() //表示key存在 // 均返回迭代器 it map.begin(); it map.end(); it mp.find(k); bool map.empty(); int map.size(); map.insert({it,string}); for (it = mp.begin();it != mp.end()) { if (it->second == \"target\") mp.erase(it++); else ++it; } map插入方式有哪几种？ 用insert函数插入pair数据 mapStudent.insert(pair(1,\"student_one\"));; 用insert函数插入value_type数据 mapStudent.insert(map::value_type(1,\"student_one\")); 在insert函数中使用make_pair()函数 mapStudent.insert(make_pair(1,\"student_one\")); 用数组方式插入 mapStudent[1] = \"student_one\"; map中[]和find的区别是什么？ map的下标运算[]的作用是：将key作为下标去执行查找，并返回相应的值；如果不存在这个key，就将一个具有该key和value的键值对插入map find函数是用关键字执行查找，找到了返回该位置的迭代器，如果不存在返回尾迭代器 map 和 set 的区别 map中的元素是 key - value 键值对；Set则只是关键字的简单集合，set中每个元素的值都唯一。 set的迭代器是const的，不允许修改元素的值，而map允许修改value，但不允许修改key。 原因是因为map和set是根据关键字排序来保证其有序性的。如果允许修改key 的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map 和set 的结构，导致iterator 失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL 中将set 的迭代器设置成const，不允许修改迭代器的值；而map 的迭代器则不允许修改key 值，允许修改value 值。 map 支持下标操作，set 不支持下标操作。map 可以用key 做下标，map 的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map 中。 因此下标运算符[ ]在map 应用中需要慎用，const_map 不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type 类型没有默认值也不应该使用。如果find 能解决需要，尽可能用find。 红黑树是怎么能够同时实现这两种容器？ 为什么使用红黑树？ 他们的底层都是以红黑树的结构实现，因此插入删除等操作都在O(logn)时间内完成，因此可以完成高效的插入删除； 在这里定义了一个模版参数，如果它是key那么它就是set，如果它是map，那么它就是map；底层是红黑树，实现map的红黑树的节点数据类型是key+value，而实现set的节点数据类型是value 因为map和set要求是自动排序的，红黑树能够实现这一功能，而且时间复杂度比较低。 适用场景： map：有序键值对不重复映射 set：有序不重复集合 unordered_map、unordered_set unordered_map、unordered_set 底层原理 unordered_map的底层是一个防冗余的哈希表（采用除留余数法）。哈希表最大的优点就是把数据的存储和查找小号的时间大大降低，时间复杂度为$O(1)$；而代价是消耗比较多的内存 使用一个下标范围比较大的数组来存储元素。设计哈希函数（一般使用除留余数法），使得每个元素的key都与一个函数值（即数组下标，hash值）相对应，于是这个数组单元用来存储这个元素，这个数组单元一般称为桶。 不能保证每个元素的key与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这就产生了冲突，一般用开链法解决冲突 unordered_map 和 map的区别？使用场景？ 构造函数：unordered_map 需要hash函数，等于函数；map只需要比较（小于）函数 存储结构：unordered_map 采用hash表存储，map一般采用红黑树（RB Tree）实现。因此其memory数据结构上不一样的。 总体来说，unordered_map查找速度比map快，属于常数级别；而map的查找速度上是 $\\log{n}$ 级别。 但是并不一定常数就比$\\log{n}$ 小，hash还有hash函数的耗时。当元素达到一定的数量级时，优先考虑hash_map；若对内存使用量有严格要求，hash_map需要慎选，而且hash_map构造速度较慢。所以如何选择，主要权衡三个因素：查找速度、数据量、内存使用 unordered_map、unordered_set常用函数有哪些？ unordered_map.begin(); // 起始位置迭代器 unordered_map.end(); // 末尾迭代器 unordered_map.cbegin(); // 起始位置常迭代器 const_iterator unordered_map.cend(); // 末尾常迭代器 unordered_map.size(); // 有效元素个数 unordered_map.insert(key); // 插入元素 unordered_map.find(key); // 查找元素，返回迭代器 unordered_map.count(key); // 返回匹配给定主键的元素的个数 deque deque的底层原理 deque是双端队列，在头尾进行插入和删除都是O(1)时间复杂度 deque的底层则是若干个数组的集合，单个数组内是连续物理空间，但不同数组间却不连续； deque的动态拓展或动态缩减，是通过新增或者释放物理空间片段来实现的，不发生数据的转移。 deque内部维护了所有元素的必要信息，保证能够通过统一的接口直接访问所有的元素，且访问耗时相等，访问者无需关心各个元素是否位于同一个物理空间上。deque的底层设计决定了deque的以下特性： ① 支持高效的双端增减操作（因为无需移动数据） ② 在元素数量很大时，总体来说比vector更高效（大量数据的移动很耗时） ③ 不支持“指针+offset”的访问方式（物理空间不连续） ④ 当需要在首尾之外的位置频繁插入/移除元素时，deque比list/forward_list表现更差。 ⑤ 迭代器访问或者引用访问的连续性不如 list 和 forward_list。 deque常用函数 deque.push_back(elem); deque.pop_back(); deque.push_front(elem); deque.pop_front(); deque.size(); deque.at(idx) // 传回索引idx所指的数据，如果idx越界，抛出out_of_range 什么情况下用vector、list、deque？ vector可以随机存储元素（即可以通过公式直接计算出元素地址，不需要挨个查找），但在非尾部插入删除数据时，效率很低，适合对象简单，对象数据量变化不大，随机访问频繁。除非特殊情况，尽可能的使用vector而非deque，因为deque的迭代器比vector复杂很多。 list不支持随机存储，适用于对象大、对象数量变化频繁，插入和产出频繁，写多读少的情景 需要从首尾两端进行插入或删除操作的时候用deque 哈希表 hash_map、map使用情况？ hash_map查找速度比map快，查找速度属于常数级别；map的查找速度是 $\\log{n}$ 级别 删除和插入操作较多的情况下，map比hash_map的性能更好，数据量越大越明显 map的遍历性能高于hash_map， hash_map 查找性能 比map要好，数据量越大，查找次数越多，hash_map表现就越好。 但是并不一定常数就比$\\log{n}$ 小，hash还有hash函数的耗时。当元素达到一定的数量级时，优先考虑hash_map；若对内存使用量有严格要求，hash_map需要慎选，而且hash_map构造速度较慢。所以如何选择，主要权衡三个因素：查找速度、数据量、内存使用 STL中哈希表的底层实现 Hashtable在C++的STL里占据着重要的一席之地。其中的hash_set、hash_map、hash_multiset、hash_multimap四个关联容器都是以hashtable为底层实现方法（技巧） Hashtable底层实现是通过开链法来实现的，hash table表格内的元素称为桶（bucket)，bucket是hashtable_node数据结构组成的链表，定义如下，通过当前节点，可以方便地通过节点自身的next指针来获取下一链表节点的元素。 template struct __hashtable_node { __hashtable_node *next; Value val; }; 存入桶元素的容器是vector。选择vector为存放桶元素（bucket）的基础容器，是因为vector容器本身具有动态扩容能力，无需人工干预。 在开链方法中，用于装载桶元素（bucket）的vector容器大小恒定为一个质数大小，哈希表内置了28个质数（53,97,193，...，429496729）。在创建哈希表时，会根据存入的元素个数选择大于等于元素个数的质数作为哈希表的容量，即vector的长度，其中每个桶（bucket）所维护的链表长度也等于哈希表的容量。如果插入哈希表的元素超过了桶（bucket）的容量，就要重建哈希表，即找出下一个质数，创建新的buckets 、vector，重新计算元素在新哈希表的位置，然后再delete掉old hashtable的所有元素。 hash_table的一些细节： 其迭代器没有减操作，也没有逆向迭代器。 不能处理 string double float等类型。 哈希构造函数和哈希冲突算法有哪些？ 哈希构造函数（记住前四个）： 除留余数法 直接定址法 数字分析法 平方取中法 折叠法、基数转换法、随机数法、随机乘数法、字符串数值哈希法、旋转法 哈希处理冲突方法： 开链法 开放定址法 再哈希法 迭代器 迭代器的底层原理 迭代器上连接容器和算法的一个桥梁，通过迭代器可以在不了解容器的内部原理的情况下遍历容器。 它的底层实现包含两个重要的部分： 萃取技术 模板便特化 萃取技术（traits）可以进行类型推导，根据不同类型可以执行不同的处理流程，比如容器是vector，那么traits必须推导出其迭代器类型位随机访问迭代器，而list则位双向迭代器。 例如STL算法库中的distance函数，distance函数接受两个迭代器参数，然后计算他们两者之间的距离。显然对于不同的迭代器计算效率差别很大。比如对于vector容器来说，对于内存是连续分配的，因此指针直接相减即可获得两者的距离；而list容器是链式表，内存一般都不是连续分配，因此只能通过一级一级调用next() 或 其他函数，没调用一次再判断迭代器是否相等来计算距离。vector迭代器计算distance的效率为$O(1)$ ,而list则为$O(n)$, n为距离的大小。 使用萃取技术（traits）进行类型推导的过程中会使用到模板偏特化。模板偏特化可以用来推导参数，如果我们自定义多个类型，除非我们把这些自定义类型的特化版本写出来，否则我们只能判断他们是内置类型，并不能判断他们具体属于哪个类型。 template struct TraitsHelper { static const bool isPointer = false; }; template struct TraitsHelper { static const bool isPointer = true; } if (TraitsHelper::isPointer) .... // 可以得出当前类型int*为指针类型 else .... // 可以得出当前类型int非指针类型 迭代器的种类 输入迭代器：是只读迭代器，在每个被遍历的位置上只能读取一次。如find函数的参数就是输入迭代器 输出迭代器：是只写迭代器，在每个被遍历的位置上只能被写一次。 前向迭代器：兼具有输入和输出迭代器的能力，但是它可以对同一个位置重逢进行读和写。但它不支持operator-，所以只能向前移动。 双向迭代器：很像前向迭代器，只是它向后移动和向前移动同样容易 随机访问迭代器：有双向迭代器的所有功能。而且还提供“迭代器算数”，即一步内可以向前或向后跳跃任意位置，包含指针的所有操作。并另外支持it+n、it-n、it+=n、it-=n、it1-it2 和 it[n]等操作。 迭代器的失效问题 以vector为例： 插入元素： 1、尾后插入：size 2、中间插入：中间插入：size 删除元素： 尾后删除：只有尾迭代失效。 中间删除：删除位置之后所有迭代失效。 deque 和 vector 的情况类似, 而list双向链表每一个节点内存不连续, 删除节点仅当前迭代器失效,erase返回下一个有效迭代器; map/set等关联容器底层是红黑树删除节点不会影响其他节点的迭代器, 使用递增方法获取下一个迭代器 mmp.erase(iter++); unordered_(hash) 迭代器意义不大, rehash之后, 迭代器应该也是全部失效. 迭代器 ++ it 与 it++ 前置（++ it）返回一个引用，后置（ it ++）返回一个对象 前置（++ it）不会产生临时变量，后置（ it ++）必须产生临时对象，临时对象会导致效率降低 // 前缀形式： int& int::operator++() //这里返回的是一个引用形式，就是说函数返回值也可以作为一个左值使用 {//函数本身无参，意味着是在自身空间内增加1的 *this += 1; // 增加 return *this; // 取回值 } //后缀形式:函数返回值是一个非左值型的，与前缀形式的差别所在。 const int int::operator++(int) //函数带参，说明有另外的空间开辟 { int oldValue = *this; // 取回值 ++ (*this); // 增加 return oldValue; // 返回被取回的值 } 迭代器与指针的区别 迭代器不是指针，是类模板，表现的像指针。它只是模拟了指针的一些功能，通过重载了指针的一些操作符，->、*、++、--等。迭代器封装了指针，是一个可遍历STL（ Standard TemplateLibrary）容器内全部或部分元素的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，它可以根据不同类型的数据结构来实现不同的++，--等操作。 迭代器返回的是对象引用而不是对象的值，所以cout 只能输出迭代器使用*取值后的值而不能直接输出其自身。 常用算法 函数式编程 统计某个元素的出现次数： vector v = {1,3,1,7,5}; // vector容器 auto n1 = std::count( // count算法计算元素的数量 begin(v), end(v), 1 // begin()、end()获取容器的范围 ); 使用就地定义函数的lambda表达式，函数式编程，统计大于2的元素个数 auto n = std::count_if( // count_if算法计算元素的数量 begin(v), end(v), // begin()、end()获取容器的范围 [](auto x) { // 定义一个lambda表达式 return x > 2; // 判断条件 } ); // 大函数里面套了三个小函数 迭代器使用 容器一般会提供begin()，end()函数，但更建议使用更加通用的全局函数begin()，end()，另外还有cbegin(), rbegin() vector v = {1,2,3,4,5}; // vector容器 auto iter1 = v.begin(); // 成员函数获取迭代器，自动类型推导 auto iter2 = v.end(); auto iter3 = std::begin(v); // 全局函数获取迭代器，自动类型推导 auto iter4 = std::end(v); auto iter5 = v.rbegin(); // 反向迭代器，前开后闭区间 auto iter6 = v.rend(); // auto iter7 = v.cbegin(); // 常量迭代器，只读 迭代器和指针类似，也可以前进和后退，但不能假设它一定支持“++”“--”操作符，最好也要用函数来操作，常用的有这么几个： distance()，计算两个迭代器之间的距离； advance()，前进或者后退 N 步； next()/prev()，计算迭代器前后的某个位置。 array arr = {0,1,2,3,4}; // array静态数组容器 auto b = begin(arr); // 全局函数获取迭代器，首端 auto e = end(arr); // 全局函数获取迭代器，末端 assert(distance(b, e) == 5); // 迭代器的距离 auto p = next(b); // 获取“下一个”位置 assert(distance(b, p) == 1); // 迭代器的距离 assert(distance(p, b) == -1); // 反向计算迭代器的距离 advance(p, 2); // 迭代器前进两个位置，指向元素'3' assert(*p == 3); assert(p == prev(e, 2)); // 是末端迭代器的前两个位置 排序算法 一些常见问题对应的算法： 要求排序后仍然保持元素的相对顺序，应该用 stable_sort，它是稳定的； 选出前几名（TopN），应该用 partial_sort； 选出前几名，但不要求再排出名次（BestN），应该用 nth_element； 中位数（Median）、百分位数（Percentile），还是用 nth_element； 按照某种规则把元素划分成两组，用 partition； 第一名和最后一名，用 minmax_element。 // top3 std::partial_sort( begin(v), next(begin(v), 3), end(v)); // 取前3名 // best3 std::nth_element( begin(v), next(begin(v), 3), end(v)); // 最好的3个 // Median auto mid_iter = // 中位数的位置 next(begin(v), v.size()/2); std::nth_element( begin(v), mid_iter, end(v));// 排序得到中位数 cout 9; } ); for_each(begin(v), pos, print); // 输出分组后的数据 // min/max auto value = std::minmax_element( //找出第一名和倒数第一 cbegin(v), cend(v) ); 如果是 list 容器，应该调用成员函数 sort()，它对链表结构做了特别的优化。有序容器 set/map 本身就已经排好序了，直接对迭代器做运算就可以得到结果。 查找算法 算法 binary_search，顾名思义，就是在已经排好序的区间里执行二分查找。但只返回一个 bool 值，告知元素是否存在，而更多的时候是想定位到那个元素，所以 binary_search 几乎没什么用。 vector v = {3,5,1,7,10,99,42}; // vector容器 std::sort(begin(v), end(v)); // 快速排序 auto found = binary_search( // 二分查找，只能确定元素在不在 cbegin(v), cend(v), 7 ); 在已序容器上执行二分查找，要用到：lower_bound，它返回第一个“大于或等于”值的位置： decltype(cend(v)) pos; // 声明一个迭代器，使用decltype pos = std::lower_bound( // 找到第一个>=7的位置 cbegin(v), cend(v), 7 ); found = (pos != cend(v)) && (*pos == 7); // 可能找不到，所以必须要判断 assert(found); // 7在容器里 lower_bound 的返回值是一个迭代器，所以就要做一点判断工作，才能知道是否真的找到了。判断的条件有两个，一个是迭代器是否有效，另一个是迭代器的值是不是要找的值。 lower_bound 的查找条件是“大于等于”，而不是“等于”，所以它的真正含义是“大于等于值的第一个位置”。相应的也就有“大于等于值的最后一个位置”，算法叫 upper_bound，返回的是第一个“大于”值的元素。 pos = std::upper_bound( // 找到第一个>9的位置 cbegin(v), cend(v), 9 ); 两者的区分可以借助一个简单的不等式： begin 有序容器 set/map，就不需要调用这三个算法了，它们有等价的成员函数find/lower_bound/upper_bound，效果是一样的。 multiset s = {3,5,1,7,7,7,10,99,42}; // multiset，允许重复 auto pos = s.find(7); // 二分查找，返回迭代器 assert(pos != s.end()); // 与end()比较才能知道是否找到 auto lower_pos = s.lower_bound(7); // 获取区间的左端点 auto upper_pos = s.upper_bound(7); // 获取区间的右端点 for_each( // for_each算法 lower_pos, upper_pos, print // 输出7,7,7 ); 其他 vector越界访问下标，map越界访问下标？vector删除元素时会不会释放空间？ 通过下标访问vector中的元素会做边界检查，但该处的实现方式要看具体的IDE，不同IDE的实现方式不一样，确保不可访问越界地址 map的下标运算[]的作用是：将key作为下标去执行查找，并返回相应的值；如果不存在这个key，就将一个具有该key和value的键值对插入map erase函数只能删除内容，不能改变vector容量的大小，它删除了it迭代器指向的元素，并且返回被删除的it之后的下一个迭代器 clear函数只能清空内容，也不能改变capacity容量大小； 如果想要在删除内容的时候同时释放内存，可以选用deque容器 使用有序容器插入自定义对象要怎么做？ 标准库里一共有四种有序容器：set/multiset 和 map/multimap。set 是集合，map 是关联数组（在其他语言里也叫“字典”）。 因为有序容器的数量很少，所以使用的关键就是要理解它的“有序”概念，也就是说，容器是如何判断两个元素的“先后次序”，知道了这一点，才能正确地排序。 这就导致了有序容器与顺序容器的另一个根本区别，在定义容器的时候必须要指定 key 的比较函数。只不过这个函数通常是默认的 less，表示小于关系，不用特意写出来： template class vector; // vector template // 比较函数 > class set; // 集合 template // 比较函数 > class map; // 关联数组 C++ 里的 int、string 等基本类型都支持比较排序，放进有序容器里毫无问题。但很多自定义类型没有默认的比较函数，要作为容器的 key 就有点麻烦。 解决这个问题有两种办法：一个是重载“ 比如说我们有一个 Point 类，它是没有大小概念的，但只要给它重载“ bool operator s; // 现在就可以正确地放入有序容器 s.emplace(7); s.emplace(3); 另一种方式是编写专门的函数对象或者 lambda 表达式，然后在容器的模板参数里指定。这种方式更灵活，而且可以实现任意的排序准则： set s = {7, 3, 9}; // 定义集合并初始化3个元素 for(auto& x : s) { // 范围循环输出元素 cout b; // 定义大于关系 }; set gs(comp) // 使用decltype得到lambda的类型 std::copy(begin(s), end(s), // 拷贝算法，拷贝数据 inserter(gs, gs.end())); // 使用插入迭代器 for(auto& x : gs) { // 范围循环输出元素 cout 使用无序容器插入自定义对象要怎么做？ 无序容器也有四种，名字里也有 set 和 map，只是加上了 unordered（无序）前缀，分别是unordered_set/unordered_multiset、unordered_map/unordered_multimap。 无序容器虽然不要求顺序，但是对 key 的要求反而比有序容器更“苛刻”一些，例如unordered_map 的声明： template, // 计算散列值的函数对象 class KeyEqual = std::equal_to // 相等比较函数 > class unordered_map; 它要求 key 具备两个条件，一是可以计算 hash 值，二是能够执行相等比较操作。 第一个是因为散列表的要求，只有计算 hash 值才能放入散列表，第二个则是因为 hash 值可能会冲突，所以当 hash 值相同时，就要比较真正的 key 值。 与有序容器一样，要把自定义类型作为 key 放入无序容器，必须要实现这两个函数： “==”函数 ：可以用与“ bool operator==(const Point& a, const Point& b) { return a.x == b.x; // 自定义相等比较运算 } 散列函数：可以用函数对象或者 lambda 表达式实现，内部最好调用标准的 std::hash 函数对象，而不要自己直接计算，否则很容易造成 hash 冲突： auto hasher = [](const auto& p) // 定义一个lambda表达式 { return std::hash()(p.x); // 调用标准hash函数对象计算 }; 有了相等函数和散列函数，自定义类型也就可以放进无序容器了： unordered_set s(10, hasher); s.emplace(7); s.emplace(3); 容器内删除一个元素 对于顺序容器vector,deque来说，使用erase(itertor)后，后边的每个元素的迭代器都会失效（list除外），但是后边每个元素都会往前移动一个位置，erase 会返回下一个有效的迭代器，见如下代码，返回的是删除的后一个元素的迭代器 int main() { vector v{1, 2, 3}; for (auto it = v.begin(); it != v.end(); ++it) cout 输出： 1 2 3 3 对于关联容器map ,set 来说，使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素不会影响到下一个元素的迭代器，返回值是void，所以要采用erase(it++)的方式删除迭代器；这样it就记录了下一个元素的迭代器 对于list来说，它使用了不连续分配的内存，并且它的erase方法也会返回下一个有效的iterator，下述两种写法均可 int main() { list lst{1, 2, 3, 4, 5}; for (auto it = lst.begin(); it != lst.end(); ++it) cout 输出： 1 2 3 4 5 2 3 3 4 5 如果在共享内存上使用STL标准库？ 假设进程A在共享内存中放入了数个容器，进程B如何找到这些容器呢？ 一个方法是进程A把容器放在共享内存的确定地址上（fixed offsets），则进程可以从该已知地址上获取容器。 另一个改进的办法是，进程A现在共享内润某快确定地址上放一个map容器，然后进程A再创建其他容器，然后给它取个名字，和地址一并保存到这个map容器里。 进程B知道如何获取该保存了地址映射的map容器，然后统一再根据名字取得其他容器的地址。 Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-10-02 20:11:37 "},"计算机网络.html":{"url":"计算机网络.html","title":"计算机网络","keywords":"","body":"计算机网络 OSI TCP/IP OSI(Open System Interconnect)七层协议模型 各层功能 物理层: 通过媒介传输比特,确定机械及电气规范，传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45 数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP ARP 网络层：实现数据包的选路和转发，提供网络互连，传输单位为包,主要包括的协议为IP ICMP 传输层：为两台主机上的应用程序提供端到端(end to end)的通信，传输单位为报文,主要包括的协议为TCP UDP 会话层：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS 表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII 应用层: 各种应用软件（应用程序及接口）,传输单位为APDU，主要包括的协议为 FTP HTTP DNS TCP/IP 体系结构 应用层 HTTP：超文本传输协议，在浏览器与服务器间传送文档。 DNS（Domain Name Service，域名服务）协议提供机器域名到IP地址的转换。DNS是一套分布式的域名服务系统。每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且是动态更新的。众多网络客户端程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。(UDP传输) SMTP协议：简单邮件传送协议 FTP协议：文件传输协议 RIP 协议：距离矢量路由选择协议。 传输层 TCP协议（Transmission Control Protocol，传输控制协议）为应用层提供可靠的、面向连接的和基于流（stream）的服务。 UDP协议（User Datagram Protocol，用户数据报协议）则与TCP协议完全相反，它为应用层提供不可靠、无连接和基于数据报的服务。 网络层 IP协议：IP协议根据数据包的目的IP地址来决定如何投递它，使用逐跳（hop by hop）的方式确定通信路径。（1） 寻址。（2） 路由选择。（3） 分段与组装。 ICMP协议：是IP协议的重要补充，主要用于检测网络连接。(ping工作协议) 数据链路层 ARP协议：ARP地址解析协议用于将计算机的网络地址（IP地址32位）转化为物理地址（MAC地址48位） 原理： 主机A检查自己的ARP缓存表（ARP cache），其中存储了最近与其他主机通信的IP地址和对应的MAC地址。如果目标主机的IP地址已经存在于ARP缓存表中，主机A可以直接使用该MAC地址发送数据。 如果ARP缓存表中没有目标主机的IP地址条目，主机A将发送一个ARP请求广播到局域网上的所有主机。ARP请求包含主机A的IP地址和MAC地址，以及目标主机的IP地址。 其他主机收到ARP请求后，会检查自己的IP地址是否与ARP请求中的目标IP地址匹配。如果匹配，说明该主机是目标主机，它将发送一个ARP响应给主机A，包含自己的IP地址和MAC地址。 主机A收到ARP响应后，将目标主机的IP地址和MAC地址存储到ARP缓存表中，以便将来的通信使用。 主机A现在知道了目标主机的MAC地址，可以使用该地址发送数据包到目标主机。 RARP协议：RARP协议（Reverse ARP，反向ARP协议），其功能是将MAC地址解析为对应的IP地址。 TCP UDP UDP头部结构 源端口：16位表示取值范围是1-65535。 目的端口：也是16位。 长度：长度是16位表示，指udp数据包的整体长度，udp数据包最小是8个字节，所以它能发送的最大负载长度是65535-8。 校验和：udp的校验和用16位表示，是检验协议头和负载数据。 TCP头部结构 32位序号（sequence number）：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。序号值被系统初始化为某个随机值ISN（Initial Sequence Number，初始序号值）。 32位确认号（acknowledgement number）：用作对另一方发送来的TCP报文段的响应。其值是收到的TCP报文段的序号值加1。 4位头部长度（header length）：标识该TCP头部有多少个32bit字（4字节）。 标识位： URG标志，表示紧急指针（urgent pointer）是否有效。 ACK标志，表示确认号是否有效。称携带ACK标志的TCP报文段为确认报文段。 PSH标志，提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间。 RST标志，表示要求对方重新建立连接。称携带RST标志的TCP报文段为复位报文段。 SYN标志，表示请求建立一个连接。称携带SYN标志的TCP报文段为同步报文段。 FIN标志，表示通知对方本端要关闭连接了。称携带FIN标志的TCP报文段为结束报文段。 16位窗口大小（window size）：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口（Receiver Window，RWND）。 16位校验和（TCP checksum）：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。 16位紧急指针（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。 选项字段40字节：最大报文段长度(Max Segment Size，MSS)，通常将MSS设置为(MTU-40)字节，(减掉的这40字节包括20字节的 TCP头部和20字节的IP头部)，MTU为帧的最大传输单元。对以太网而言，MSS值是 1460(1500-40)字节。 RST 产生复位报文段的3种情况: 访问不存在的端口 异常终止连接 处理半打开连接 TCP与UDP区别？ （1）连接： TCP 是面向连接的传输层协议，即传输数据之前必须先建立好连接。 UDP是无连接的。 （2）服务对象： TCP 是点对点的两点间服务，即一条 TCP 连接只能有两个端点; UDP 支持一对一，一对多，多对一，多对多的交互通信。 （3）可靠性： TCP 是可靠交付:无差错，不丢失，不重复，按序到达。 UDP 是尽最大努力交付，不保证可靠交付。 （4）拥塞控制，流量控制： TCP 有拥塞控制和流量控制保证数据传输的安全性。 UDP 没有拥塞控制，网络拥塞不会影响源主机的发送效率。 （5) 报文长度： TCP 是动态报文长度，即 TCP 报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。 UDP 面向报文，不合并，不拆分，保留上面传下来报文的边界。 （6）首部开销： TCP 首部开销大，首部 20 个字节。 UDP 首部开销小，8 字节。(源端口，目的端口，数据长度，校验和) （7）TCP传输速度比UDP慢，TCP是重量级协议、UDP是轻量级协议 TCP建立（三次握手） Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，等待Server确认。此时客户端进入SYN-SENT（同步已发送） 状态。 SYN报文段（即SYN=1的报文段）不能携带数据，但要消耗一个序号 Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置1，ack=J+1，随机产生一个值seq=K，并将该数据包发给Client以确认连接请求。这时TCP服务器进行进入SYN-RCVD（同步收到）状态。 同理，此报文段也不能携带数据。 Client收到确认后，检测ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server。完成三次握手，客户端进入ESTABLISHED（已建立连接）状态。当服务器收到客户端的确认后，也进入ESTABLISHED（已建立连接）状态。 TCP标准规定，ACK报文段可以携带数据，但如果不携带数据则不消耗序号 ISN(Initial Sequence Number)初始序号是动态生成的。 TCP关闭（四次挥手） 客户端向服务器发送一个FIN报文，首部的FIN=1，同时报文给自己指定一个序号（m），此时客户端进入FIN_WAIT_1 （终止等待1）状态，但客户端依然可以接收服务器发送来的数据。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 服务端收到了客户端的FIN报文，会发送ACK报文进行确认，把收到报文的序列号的值+1（m+1）作为ACK报文的序列号的值，表明已经收到了客户端的报文，服务器进入CLOSE-WAIT（关闭等待）状态 TCP服务器进程这时应通知高层应用程序，客户端到服务端这个方向的连接就释放了，此时TCP连接处于半关闭（HALF-CLOSE）状态，即客户端已经没有数据要发送了，但服务器若发送数据，客户端仍要接收。客户端收到服务端的确认后，进入FIN-WAIT-2（终止等待2）状态。等待服务端发出的连接释放报文段。 当服务器没有数据要发送了，也想要断开连接，会给客户端发送FIN报文，且指定一个序列号（n），服务器进入了LAST-ACK（最后确认）状态。 客户端收到FIN之后，一样会发送一个ACK报文作为应答，且把服务端的序号+1（n+1）作为自己ACK报文的序号。然后进入TIME-WAIT（时间等待）状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。 两次握手不可以： TCP 是全双工通信，两次握手只能确定单向数据链路是可以通信的，并不能保证反向的通信正常 详细解释： 这个问题的本质是：在信道不可靠的情况下, 通信双发需要就某个问题达成一致. 需要几次通信？ 对于此问题，无论在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足\"在不可靠信道上可靠地传输信息\"这一需求所导致的 具体来说： TCP连接的双方要确保各自的收发消息的能力都是正常的。 客户端第一次发送握手消息到服务端，服务端接收到握手消息后把ack和自己的syn一同发送给客户端，这是第二次握手，当客户端接收到服务端发送来的第二次握手消息后，客户端可以确认“服务端的收发能力OK，客户端的收发能力OK”，但是服务端只能确认“客户端的发送OK，服务端的接收OK”， 所以还需要第三次握手，客户端收到服务端的第二次握手消息后，发起第三次握手消息，服务端收到客户端发送的第三次握手消息后，就能够确定“服务端的发送OK，客户端的接收OK”， 至此，客户端和服务端都能够确认自己和对方的收发能力OK，TCP连接建立完成。 四次挥手的原因? 因为当处于LISTEN状态的服务器端收到来自客户端的SYN报文(客户端希望新建一个TCP连接)时，它可以把ACK(确认应答)和SYN(同步序号)放在同一个报文里来发送给客户端。但在关闭TCP连接时，当收到对方的FIN报文时，对方仅仅表示对方已经没有数据发送给你了，但是自身可能还有数据需要发送给对方，则等你发送完剩余的数据给对方之后，再发送FIN报文给对方来表示你数据已经发送完毕，并请求关闭连接，所以通常情况下，这里的ACK报文和FIN报文都是分开发送的。 TIME_WAIT的作用 2MSL（MaximumSegment Life，报文段最大生存时间） 保证最后一次握手报文能到服务器，能进行超时重传。 2MSL 后，这次连接的所有报文都会消失，不会影响下一次连接。 缺点： 第一是内存资源占用，但不是很严重，基本可以忽略。 第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口。端口资源也是有限的，一般可以开启的端口为 32768～61000 ，也可以通过net.ipv4.ip_local_port_range指定，如果 TIME_WAIT 状态过多，会导致无法创建新连接。 TCP状态转移图 TCP的可靠机制 TCP超时重传 TCP可靠性中最重要的一个机制是处理数据超时和重传。TCP协议要求在发送端每发送一个报文段，就启动一个定时器并等待确认信息；接收端成功接收新数据后返回确认信息。若在定时器超时前数据未能被确认，TCP就认为报文段中的数据已丢失或损坏，需要对报文段中的数据重新组织和重传。 拥塞控制 包含四个部分慢启动（slow start）、拥塞避免（congestion avoidance）、快速重传（fast retransmit）和快速恢复（fast recovery） SWND（Send Window，发送窗口 ）、SMSS（Sender Maximum SegmentSize，发送者最大段大小）、接收通告窗口（RWND）、拥塞窗口（CongestionWindow，CWND） 慢启动：CWND将按照指数形式扩大。慢启动算法的理由是，TCP模块刚开始发送数据时并不知道网络的实际情况，需要用一种试探的方式平滑地增加CWND的大小。（cwnd *2） 拥塞避免：慢启动门限（slow start threshold size，ssthresh）。当CWND的大小超过该值时（一般设为65536），TCP拥塞控制将进入拥塞避免阶段，拥塞窗口的值不再指数上升，而是加法增加。（cwnd +1） 快速恢复：当发送方知道只是丢失了个别的报文段，不会启动慢开始算法，而是执行快恢复算法。将阈值设为当前窗口大小的一半，同时设置拥塞窗口为阈值的大小，然后执行拥塞避免算法。 快速重传：发送方只要一连收到3个重复确认，就知道接收方没有收到应当立即进行快重传，这样就不会出现超时。 如何判断拥塞？ 传输超时，或者说TCP重传定时器溢出。采用慢启动和拥塞避免 接收到重复的确认报文段。采用快速重传和快速恢复 TCP 粘包/拆包 怎么解决？ 一个完整的数据包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。 原因 1、应用程序写入数据的字节大小大于套接字发送缓冲区的大小. 2、进行MSS大小的TCP分段。( MSS=TCP报文段长度-TCP首部长度) 3、以太网的payload大于MTU进行IP分片。（ MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。） 怎么解决 1、消息定长 2、在包尾部增加回车或者空格符等特殊字符进行分割 3、将消息分为消息头和消息尾，在头部中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息 4、使用其它复杂的协议，如RTMP协议等 为什么UDP不粘包？ 对于UDP，不会使用块的合并优化算法，不存在封包，再加上UDP本身是一个“数据包“协议，也就是两段数据是有界限的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。从TCP和UDP的头部结构体就可以很明显的看到，UDP头部是记录了数据的长度的，而TCP头部里面并没有记录数据长度的变量。 HTTP HTTP 协议是 Hyper Text Transfer Protocol(超文本传输协议)的缩写，是用于从万维网(WWW:World Wide Web)服务器传输超文本到本地浏览器的传送协议。 HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求行(请求的方法、URL、协议版本)、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括状态行(协议的版本、成功或者错误代码、服务器信息)、响应头部和响应数据。 在浏览器输入URL地址到显示主页的过程(HTTP请求过程)？ 大概过程： （1）浏览器向DNS 服务器请求解析该URL 中的域名所对应的IP 地址； （2）解析出IP 地址后，根据该IP 地址和默认端口80，和服务器建立TCP 连接； （3）浏览器发出读取文件（URL 中域名后面部分对应的文件）的HTTP 请求，该请求报文作为TCP 三次握手的第三个报文的数据发送给服务器； （4）服务器对浏览器请求作出响应，并把对应的html 文本发送给浏览器； （5）释放TCP 连接； （6）浏览器将该html 文本解析后显示网页内容； 细致过程（笔试原题，排序）： 1、浏览器输入URL，先解析URL地址是否合法 2、浏览器检查是否有缓存（浏览器缓存 - 系统缓存 - 路由器缓存）。如果有，直接显示。没有，进行（3） 3、在发送HTTP请求前，需要域名解析（DNS解析），解析获取对应的IP地址 4、浏览器向服务器发起TCP连接，进行TCP连接的三次握手 5、握手成功后，浏览器向服务器发送HTTP请求，请求数据包 6、服务器收到请求，进行处理后将数据发送给浏览器 7、浏览器收到HTTP响应 8、浏览器解析响应，如果响应可以缓存则存入缓存 9、浏览器发送请求获取嵌入在HTML的资源（HTML、CSS、JS等），对于未知类型，会弹出对话框 10、浏览器发送异步请求 11、页面全部渲染结束显示网页 HTTP请求方法 GET和POST的区别？ GET 和POST 本质上就是TCP 连接，并无差别。但是由于HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 get 参数通过 url 传递，post 放在 request body 中。 get 请求在 url 中传递的参数是有长度限制的，而 post 没有。 get 请求只能进行 url 编码，而 post 支持多种编码方式。 get 请求会浏览器主动 cache，而 post 支持多种编码方式。 get 请求参数会被完整保留在浏览历史记录里，而post 中的参数不会被保留。 GET 产生一个TCP 数据包；POST 产生两个TCP 数据包。 对于GET 方式的请求，浏览器会把http header 和data 一并发送出去，服务器响应200（返回数据） 对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据） HTTP状态码 HTTP的无连接是什么意思？ 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 HTTP的无状态是什么意思？ 无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。 HTTP1.0、HTTP1.1、HTTP2.0的区别？ HTTP1.0 HTTP1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接。就像打电话一样，一次只能说一件事，说完就要挂断，又因为TCP连接建立一次需要三次握手，所以效率很低。 如果不想断开连接，需要在HTTP相应的Connection字段指定为keep-live connection:keep-alive; HTTP1.1 HTTP1.1引进了持久连接，TCP连接默认不关闭，可以被多个请求复用。客户端和服务端发现对方一段时间没有活动后，可以主动关闭连接；或者客户端在最后一个请求时，主动告诉服务端要关闭连接。响应的顺序必须和请求的顺序一致 HTTP1.0就像打一次电话只能说一次事，HTTP1.1是打完电话先不直接挂断，而是持续一会，这期间如果有事情还可以再次沟通。 HTTP1.1还引入了管道机制，即在同一个TCP连接里，客户端可以同时发送多个请求，这样就进一步改进了HTTP协议的效率。 HTTP2.0 HTTP2.0采用了多路复用，即在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按顺序一一对应。能这样做有一个前提，就是HTTP2.0进行了二进制分帧，即会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码。 负责这个拆分、组装请求和二进制帧的一层就叫做二进制分帧层 也就是说，老板可以同时下达多个命令，员工也可以收到请求A和请求B，于是先回应A，结果发现处理A非常耗时，于是就发送A请求已经处理好的部分，接着回应B请求，完成后 ，再发送A请求剩下的部分。A请求的两部分响应再组合到一起发送给老板 除此之外还有一些其他的优化，比如Header压缩、服务端推送等 Header压缩就是压缩老板和员工之间的对话 服务端推送就是员工事先把一些老板可能询问的事情提前发送到老板的手机上（缓存）。这样老板想要知道的时候就可以直接读取短信（缓存）了。 HTTP 和 HTTPS 的区别？ HTTPS （Hyper Text Transfer Protocol over SecureSocket Layer）：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP+SSL，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。 开销：HTTPS协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。 端口不同：HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 安全性：HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。 资源消耗：HTTP是超文本传输协议，信息是明文传输；HTTPS则是具有安全性的SSL加密传输协议，需要消耗更多的CPU和内存资源 在OSI模型中，HTTP工作于应用层，而HTTPS工作于传输层； HTTPS 优点 HTTPS 传输数据过程中使用密钥进行加密，所以安全性更高 HTTPS 协议可以认证用户和服务器，确保数据发送到正确的用户和服务器 HTTPS 缺点 HTTPS 握手阶段延时较高：由于在进行HTTP 会话之前还需要进行SSL 握手，因此HTTPS 协议握手阶段延时增加 HTTPS 部署成本高：一方面HTTPS 协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS 协议需要进行加解密的计算，占用CPU 资源较多。 ps：对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥是真是假。为了保证发送方的公钥是真的，CA证书机构会负责颁发一个证书，里面的公钥确保是真的，用户请求服务器时，服务器将证书给用户，这个证书是经由系统内置证书的备案过的。 对称加密 加密与解密使用同样的密钥。对称加密效率较高，被广泛应用于各种加密协议，然而在通讯前需要将密钥发送给对方，容易导致密钥泄漏。 非对称加密 非对称加密使用了一对密钥：公钥和私钥。私钥只能由一方保管，不能外泄，而公钥则可以发给任何请求者。通过公钥加密的数据只能由私钥解开。相比对称加密而言，非对称加密是十分安全的，但是加密和解密效率却没有对称加密高。 HTTPS的通信建立过程？ 在使用HTTPS是需要保证服务端配置正确了对应的安全证书 客户端发送请求到服务端 服务端返回公钥和数字证书到客户端 客户端接收后会验证证书的安全性，如果通过，则会随机生成一个随机秘钥，用公钥对其加密，发送到服务端 服务端接受到这个加密后的随机秘钥后，会用私钥对其解密，随后用这个随机秘钥当做对称加密密钥对需要发送的数据进行对称加密 客户端在接收到加密后的数据对称加密密钥与服务器通信。 SSL加密建立 什么是数字签名？ 为了避免数据在传输过程中被替换，比如黑客修改了报文内容，但是用户并不知道，所以需要让发送端做一个数字签名，把数据的摘要信息进行一个加密，比如MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行MD5加密，如果和签名一样，则说明数据是正确的 什么是数字证书？ 对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥是真是假。为了保证发送方的公钥是真的，CA证书机构会负责颁发一个证书，里面的公钥确保是真的，用户请求服务器时，服务器将证书给用户，这个证书是经由系统内置证书的备案过的。 其他 Session和Cookie的区别？ Cookie的工作原理 （1）浏览器端第一次发送请求到服务器端 （2）服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端 （3）浏览器端再次访问服务器端时会携带服务器端创建的Cookie （4）服务器端通过Cookie中携带的数据区分不同的用户 Cookie用途 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） Session的工作原理 浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建JSESSIONID（JSESSIONID实际上是一个cookie，服务器用来记录用户session），然后将该Cookie发送至浏览器端 浏览器端发送第N（N>1）次请求到服务器端,浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象 服务器端根据name为JSESSIONID的Cookie的value(sessionId),去查询Session对象，从而区分不同用户。 区别： 数据存放位置不同：cookie数据存放在客户的浏览器上，session数据放在服务器上。 安全程度不同：cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。 性能使用程度不同：session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。 数据存储大小不同：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，而session则存储与服务端，浏览器对其没有限制。 会话机制不同：session会话机制是一种服务器端机制，它使用类似于哈希表（可能还有哈希表）的结构来保存信息。cookie是服务器存储在本地计算机上的小块文本，并随每个请求发送到同一服务器。 Web服务器使用HTTP标头将cookie发送到客户端。在客户端终端，浏览器解析cookie并将其保存为本地文件，该文件自动将来自同一服务器的任何请求绑定到这些cookie。 什么是SQL 注⼊? 举个例子 SQL注⼊就是通过把SQL命令插入到Web表单提交或输入域名或⻚面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 SQL注⼊攻击的总体思路 寻找到SQL注⼊的位置 判断服务器类型和后台数据库类型 针对不同的服务器和数据库特点进行SQL注入攻击 例子： user: ‘or1=1-- pwd: String sql = “select * from user_table where username=’ “+userName+” ’ and password=’“+password+” ‘”; SELECT * FROM user_table WHERE username=’’or 1 = 1 –- and password=’’ 应对方法 参数绑定 使⽤用正则表达式过滤传⼊入的参数 MTU和MSS分别是什么？ MTU：maximum transmission unit，最大传输单元，IP分片的大小，由硬件规定，如以太网的MTU为1500字节。 IP分片解决不同物理网络最大传输单元(MTU) 的不同造成的传输问题。 MSS：maximum segment size，最大分节大小，为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到。 DDOS 攻击？ 客户端向服务端发送请求链接数据包，服务端向客户端发送确认数据包，客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认 没有彻底根治的办法，除非不使用TCP DDos 预防： 1）限制同时打开SYN半链接的数目 2）缩短SYN半链接的Time out 时间 3）关闭不必要的服务 Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-10-02 16:45:03 "},"操作系统.html":{"url":"操作系统.html","title":"操作系统","keywords":"","body":"操作系统 进程、线程、协程 进程 线程 协程 定义 系统进行资源调度和分配的基本单位 CPU调度和分派的基本单位 用户态的轻量级线程，线程内部调度的基本单位 切换情况 进程CPU环境(栈、寄存器、页表和文件句柄等)的保存以及新调度的进程CPU环境的设置 保存和设置程序计数器、少量寄存器和栈的内容 先将寄存器上下文和栈保存，等切换回来的时候再进行恢复 切换者 操作系统 操作系统 用户 切换过程 用户态->内核态->用户态 用户态->内核态->用户态 用户态(没有陷入内核) 调用栈 内核栈 内核栈 用户栈 拥有资源 CPU资源、内存资源、文件资源和句柄等 程序计数器、寄存器、栈和状态字 拥有自己的寄存器上下文和栈 并发性 不同进程之间切换实现并发，各自占有CPU实现并行 一个进程内部的多个线程并发执行 同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理 系统开销 切换虚拟地址空间，切换内核栈和硬件上下文，CPU高速缓存失效、页表切换，开销很大 切换时只需保存和设置少量寄存器内容，因此开销很小 直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快 通信方面 进程间通信需要借助操作系统 线程间可以直接读写进程数据段(如全局变量)来进行通信 共享内存、消息队列 进程与线程的区别？ 答案一： 单位：进程是资源分配的基本单位，线程是CPU调度的基本单位。两者均可并发执行。 从属：一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。 资源：进程之间的资源是独立的，进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。 系统开销：在创建或撤销进程时，系统都要为之分配或回收资源，系统开销显著大于创建或撤销线程的开销。 在进行进程切换时，设计到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。 而线程切换只需要保存和设置少量寄存器的内容，并不涉及存储管理方面的操作。 切换进程的开销也远大于切换线程的开销。 进程编程调试简单可靠性高，但是创建、销毁、切换开销大；线程正相反，但是编程调试相对复杂 进程之间不会相互影响，一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃会导致整个进程崩溃。所以多进程比多线程健壮。 答案二：根本区别就是多进程每个进程有自己的地址空间，线程则是共享地址空间。 速度：线程创建速度快，线程间通信快、切换快，因为它们在同一地址空间内 资源利用率：线程的资源利用率比较好也是因为它们在同一地址空间 同步问题：线程使用公共变量/内存时需要使用同步机制，也是因为它们在同一地址空间内。 协程 是一种比线程更加轻量级的存在。一个线程可以拥有多个协程;协程不是被操作系统内核管理，而完全是由程序所控制。 协程的开销远远小于线程; 协程拥有自己寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切换回来的时候， 恢复先前保存的寄存器上下文和栈。 每个协程表示一个执行单元，有自己的本地数据，与其他协程共享全局数据和其他资源。 跨平台、跨体系架构、无需线程上下文切换的开销、方便切换控制流，简化编程模型; 协程又称为微线程，协程的完成主要靠yeild关键字，协程执行过程中，在子程序内部可中断，然后转而执行别 的子程序，在适当的时候再返回来接着执行; 协程极高的执行效率，和多线程相比，线程数量越多，协程的性能优势就越明显; 不需要多线程的锁机制; 进程的状态转换 进程包括三种状态：就绪、运行、阻塞 就绪 --> 运行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配处理机后，该进程便由就绪状态变为执行状态 运行 --> 阻塞：正在执行的进程因发生某等待事件而无法运行，则进程由执行状态变为阻塞状态，如进程提出输入/输出请求而变成带带外部设备传入信息的状态；进程申请资源（主存空间或外部设备）得不到满足时编程等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错误等）编程等待干预状态等； 阻塞 --> 就绪：处于阻塞状态的进程，其等待的事件已经发生，如输入/输出完成；资源得到满足；或错误处理完毕时，处于等待状态的进程并不马上转入运行状态，而是先转入就绪状态，再由系统进程调度程序在适当的时候将改进成转为执行状态。 运行 --> 就绪 ：正在执行的进程，因时间片用完而被暂停运行；或在采用抢占式优先级调度算法的系统中，当有更高优先级的进程要运行而被迫让出处理机时，该进程便从运行状态转变为就绪状态 进程调度算法有哪些？ 先来先服务调度算法 有利于长作业，但不利于短作业。 时间片轮转调度算法 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。 短作业优先调度算法 长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。 最短剩余时间优先调度算法： 是针对最短进程优先增加了抢占机制的版本 高响应比优先调度算法： 主要用于作业调度，该算法是对先来先服务调度算法和短作业优先调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间 优先级调度算法 进程间的通信方式有哪些？ 进程间通信是指在不同的进程之间传递数据或共享资源。由于每个进程都有自己的地址空间，因此进程间通信需要使用特殊的技术来实现，如管道、消息队列、共享内存和套接字等。 管道 管道主要包括普通管道和命名管道：普通管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程的通信。 普通管道PIPE(无名管道)： 半双工（数据只能在一个方向上流动），具有固定的读端和写端 只能用于具有亲缘关系的进程间通信（父子进程） 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，不属于其他任何文件系统，并且只存在于内存中。 int pipe(int fd[2]); 当一个管道建立时，会创建两个文件文件描述符，要关闭管道只需将这两个文件描述符关闭即可。 命名管道FIFO： 可以在无关的进程之间交换数据 有路径名与之相关联，以一种特殊设备文件形式存在于文件系统中 int mkfifo(const char* pathname,mode_t mode); 消息队列 消息队列 MQ是把消息和队列结合起来，称之为消息队列（Message Queue）。把要传输的数据（消息）与队列进行绑定，用队列先进先出机制来实现消息传递。消息队列由 生产者 和 消费者 两部分构成；生产者主要负责产生消息并把消息放入队列中，再由消费者去处理。消费者可以到指定队列中获取消息，或者订阅相应的队列，最后由MQ服务端进行消息推送。 什么是订阅？订阅就是为消费者服务的，消费者提前订阅，当消息队列中有消息产出时，自动去获取消息进行消费。生活中有很多这种例子，比如购买腾讯、优酷等视频会员时就会有订阅模式，当你的会员到期时，会自动帮你完成续费。 共享内存 共享内存指两个或多个进程共享一块指定的存储区，不同进程可以即时看到对方进程中对共享内存中数据的更新； 因为多个进程可以同时操作，所以需要进行同步； 信号量和共享内存通常结合在一起使用，信号量用来同步对共享内存的访问； 共享内存是最快的一种进程通信方式，因为进程是直接对内存进行存取。 套接字 SOCKET 是应用层与TCP/IP协议族通信的中间软件抽象层，是一组接口。通过调用接口中已经实现的方法建立用于不同主机之间的进程通信。 服务器的工作流程： （1）创建 socket：创建服务端的socket。 （2）绑定 bind：把服务端用于通信的地址和端口绑定到socket上。 （3）监听 listen：把socket设置为监听模式。 （4）接受连接 accept：接受客户端的连接。 （5）通信 recv( ) / send( ) ：与客户端通信，接收客户端发过来的报文后，回复处理结果，重复此过程。 （6）关闭 close( )：关闭socket，释放资源。 客户端工作流程： （1）创建 socket：创建客户端的socket。 （2）发送连接 connect( )：向服务器发起连接请求。(TCP三次握手) （3）通信 recv( ) / send( )：与服务端通信，发送一个报文后等待回复，然后再发下一个报文。重复此过程，直到全部的数据被发送完。 （4）关闭 close( )：关闭socket，释放资源。 线程的通信方式有哪些？ 线程间通信是指在同一个进程内的不同线程之间传递数据或共享资源。由于所有线程都共享同一个地址空间，因此线程间通信比进程间通信更容易实现。常用的线程间通信方式包括互斥锁、条件变量和信号量等。 （1）临界区： 通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问； （2）信号量： 信号量的值=这种资源的剩余数量（信号量的值如果小于0，说明此时有进程在等待这种资源） P(S)——申请一个资源S，如果资源不够就阻塞等待 V(S)——释放一个资源S，如果有进程在等待该资源，则唤醒一个进程 sem_wait（sem_t *sem）：以原子操作的方式将信号量-1，如果信号量值小于0，则sem_wait将被阻塞，直到这个信号量具有非0 值。 sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。 （3）互斥锁： 互斥锁主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下： pthread_mutex_init: 初始化互斥锁 pthread_mutex_destroy：销毁互斥锁 pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock 调用将阻塞，直到该互斥锁的占有者将其解锁。 pthread_mutex_unlock: 以一个原子操作的方式给一个互斥锁解锁。 （4）事件(信号)，Wait/Notify： 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作 （5）条件变量： 条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下： pthread_cond_init: 初始化条件变量 pthread_cond_destroy：销毁条件变量 pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。 pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。 守护进程、孤儿进程、僵尸进程 守护进程 指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如Web服务器进程HTTP等。 孤儿进程 是指一个父进程退出后，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1 是内核启动的第一个用户级进程）所收养，并且由init进程对它们完成状态收集工作。 僵尸进程 是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有回收子进程，释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程。 区别是：孤儿进程是父进程已退出，子进程未退出；而僵尸进程是父进程未退出，子进程已退出。 如何解决僵尸进程？ （1）一般为了防止产生僵尸进程，在fork子进程之后我们都要及时使用wait系统调用；同时，当子进程退出的时候，内核都会给父进程一个SIGCHLD信号，所以我们可以建立一个捕获SIGCHLD信号的信号处理函数，在函数体中调用wait（或waitpid），就可以清理退出的子进程以达到防止僵尸进程的目的。 （2）使用kill命令。 打开终端并输入下面命令: ps aux | grep Z 会列出进程表中所有僵尸进程的详细内容。 然后输入命令： kill -s SIGCHLD pid(父进程pid) 这样子进程退出后，父进程就会收到信号了。 或者可以强制杀死父进程： kill -9 pid(父进程pid) 这样父进程退出后，这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并且由init进程对它们完成状态收集工作。 内存管理 置换算法有哪些？ 当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下： 最佳置换(OPT)算法：从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。 先进先出(FIFO)算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。 最近最少使用（LRU）算法: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。 时钟（CLOCK）置换算法：最佳置换算法性OPT能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。 所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体，因为算法要循环扫描缓冲区像时钟一样转动。所以叫clock算法。 时钟置换算法是一种性能和开销较均衡的算法，又称CLOCK算法，或最近未用算法(NRU，Not Recently Used) 简单的CLOCK算法实现方法:为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为1。当需要淘汰-一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第- - ~轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描(第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择–个淘汰页面最多会经过两轮扫描) LRU算法及实现 LRU算法用于缓存淘汰。思路是将缓存中最近最少使用的对象删除。实现方式：利用链表和hashmap。 当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。 #include using namespace std; class LRU { public: LRU(int capacity): cap(capacity){} int get(int key){ if(map.find(key) == map.end()) return -1; auto key_value = *map[key]; // 迭代器解引用 cache.erase(map[key]); cache.push_front(key_value); map[key] = cache.begin(); cout > cache; unordered_map>::iterator> map; }; int main(){ LRU lRUCache = LRU(2); lRUCache.put(1, 1); // 缓存是 {1=1} lRUCache.put(2, 2); // 缓存是 {1=1, 2=2} lRUCache.get(1); // 返回 1 lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3} lRUCache.get(2); // 返回 -1 (未找到) lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3} lRUCache.get(1); // 返回 -1 (未找到) lRUCache.get(3); // 返回 3 lRUCache.get(4); // 返回 4 } 分页和分段的区别？ 段是信息的逻辑单位，它是根据用户的需要划分的，因此段是对用户可见的；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的； 段的大小不固定，有它所完成的功能决定；页的大小固定，由系统决定 段向用户提供二维地址空间；页向用户提供的是一维地址空间 段是信息的逻辑单位，便于存储保护和信息共享，页的保护和共享收到限制 物理内存、虚拟内存、物理地址、逻辑地址的概念？ 物理内存 寄存器：速度最快、量少、价格贵。 高速缓存：次之。 主存：再次之。 磁盘：速度最慢、量多、价格便宜。 虚拟内存： 虚拟内存是一种内存管理技术，它会使程序自己认为自己拥有一块很大且连续的内存，然而，这个程序在内存中不是连续的，并且有些还会在磁盘上，在需要时进行数据交换。虚拟内存与物理内存存在映射关系，通过页表寻址完成虚拟地址和物理地址的转换。 物理地址： 它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取，是内存单元的真正地址 逻辑地址： 是指用户看到的地址。逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址（在内存条中的所处的位置）并非是连续的，只是通过操作系统通过地址映射，将逻辑地址映射成连续的，这样使用更符合人们的直观思维 逻辑地址转物理地址 一句话来说：逻辑地址左移四位加偏移地址就是物理地址 逻辑地址 = 段地址：偏移地址 具体运算：段地址×16（左移四位，也就是2的四次方，相当于乘16）+偏移地址=物理地址（可以理解为段地址末尾补一个零） 逻辑地址是 1000H：0001H 那么物理地址为1000H×16+0001H=10001H 因为地址本身一般都是十六进制数，所以只需要把段地址左移一位末尾补0再和偏移地址加起来就是物理地址 虚拟内存的好处和坏处？ 虚拟内存的好处 扩展了可用的内存空间：虚拟内存使得每个进程可以拥有比物理内存更大的地址空间。当物理内存不足时，操作系统可以将一部分暂时不使用的数据或代码存储在磁盘上，从而释放出物理内存供其他进程使用。 提供了更高的内存管理灵活性：虚拟内存允许操作系统将物理内存中的数据映射到磁盘上的文件，或者将磁盘文件映射到进程的地址空间中。这使得进程可以方便地读取和写入磁盘文件，而不需要关心具体的物理存储位置。 实现了内存保护和隔离：每个进程都有自己的虚拟地址空间，彼此之间是隔离的。这样可以防止一个进程意外地访问或修改其他进程的内存，提高了系统的稳定性和安全性。 提高了程序的执行效率：虚拟内存可以将物理内存中的数据按需加载到内存中，而不是一次性将整个程序加载到内存中。这样可以减少启动时间和内存占用，并且允许操作系统在需要时将不常用的数据置换到磁盘上，从而提高了整体的执行效率。 虚拟内存的代价： 虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存 虚拟地址到物理地址的转换，增加了指令的执行时间。 页面的换入换出需要磁盘I/O，这是很耗时的 如果一页中只有一部分数据，会浪费内存。 wait()函数 wait函数是用来及时回收我们的进程资源的。 进程一旦调用了wait函数，就立即阻塞自己本身，然后由wait函数自动分析当前进程的某个子进程是否已经退出，当找到一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞，直到有一个出现为止。函数原型如下： #include #include pid_t wait(int* status); 子进程的结束状态值会由参数status返回，而子进程的进程识别码也会一起返回。如果不需要结束状态值，则参数status可以设成 NULL。 fork()函数 fork函数用来创建一个子进程。对于父进程，fork()函数返回新创建的子进程的PID。对于子进程，fork()函数调用成功会返回0。如果创建出错，fork()函数返回-1。 #include pid_t fork(void); fork()函数不需要参数，返回值是一个进程标识符PID。返回值有以下三种情况： （1） 对于父进程，fork()函数返回新创建的子进程的PID。 （2） 对于子进程，fork()函数调用成功会返回0。 （3） 如果创建出错，fork()函数返回-1。 fork()函数创建一个新进程后，会为这个新进程分配进程空间，将父进程的进程空间中的内容复制到子进程的进程空间中，包括父进程的数据段和堆栈段，并且和父进程共享代码段。这时候，子进程和父进程一模一样，都接受系统的调度。因为两个进程都停留在fork()函数中，最后fork()函数会返回两次，一次在父进程中返回，一次在子进程中返回，两次返回的值不一样，如上面的三种情况。 其他 什么是并发和并行？ 并发：对于单个CPU，在一个时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级，多个任务不停来回快速切换。 并行：对于多个CPU，多个进程同时运行。 区别：并行的\"同时\"是同一时刻可以多个任务在运行，并发的\"同时\"是经过不同线程快速切换，使得看上去多个任务同时都在运行的现象。 同步与异步、阻塞与非阻塞的区别？ 同步：同步是指一个进程在执行请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去。 异步：异步是指进程不需要一直等下去， 而是继续执行下面的操作，当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 阻塞：调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。 非阻塞：非阻塞等待，每隔一段时间就去检查IO事件是否就绪。没有就绪就可以做其他事情。 阻塞和非阻塞是线程的一种状态，同步和异步是指的是线程执行方法的一种方式，当然同步执行时，一般都伴随着线程的阻塞。 内核态与用户态的区别？ 内核态与用户态：内核态（系统态）与用户态是操作系统的两种运行级别。内核态拥有最高权限，可以访问所有系统指令；用户态则只能访问一部分指令。 什么时候进入内核态： 系统调用（Trap） ：用户态进程 主动 要求切换到内核态的一种方式，主要是为了使用内核态才能做的事情比如读取磁盘资源。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现。 中断（Interrupt） ：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 异常（Exception）：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 其中，系统调用是主动的，另外两种是被动的。 为什么区分内核态与用户态： 在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。所以区分内核态与用户态主要是出于安全的考虑。 什么是系统调用？ 运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，系统调用和普通的函数调用非常相似。区别仅仅在于，系统调用由操作系统核心提供，运行于核心态；而普通的函数调用由函数库或用户自己提供，运行于用户态。 系统调用的过程可以简单分为以下几个步骤： 用户态的程序发起系统调用，因为系统调用中涉及一些特权指令（只能由操作系统内核态执行的指令），用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。 发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，也就是开始处理系统调用。 内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。 中断流程？ 中断是指当出现需要时，CPU暂时停止当前进程的执行，转而执行处理新情况的中断处理程序。当执行完该中断处理程序后，则重新从刚才停下的位置继续当前进程的运行。 为了区分不同的中断，每个设备有自己的中断号。系统有0-255一共256个中断。系统有一张中断向量表，用于存放256个中断的中断服务程序入口地址。每个入口地址对应一段代码，即中断服务程序。 外中断和异常有什么区别？ 外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。 异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。 抖动是什么？ 刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数(分配给进程的物理块不够) 为进程分配的物理块太少，会使进程发生抖动现象。为进程分配的物理块太多，又会降低系统整体的并发度，降低某些资源的利用率 为了研究为应该为每个进程分配多少个物理块，Denning 提出了进程工作集” 的概念 什么是死锁，产生的条件，如何解决、避免？ 由于系统中存在一些不可剥夺资源，当两个或两个以上进程在执行过程中，因争夺资源而造成的相互等待，使每个进程都无法向前推进的现象。 产生的条件：死锁发生有四个必要条件： 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源； 请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源； 不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放; 环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链，链中每个进程已获得的资源同时被链中下一个进程所请求。 如何解决： 破坏请求和保持条件： 一次性分配所有资源，这样就不会再有请求了 只要有一个资源得不到分配，就不给这个进程分配其他资源 破坏不可剥夺资源： 当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件 破坏环路等待条件： 资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件 鸵鸟策略：把头埋在沙子里，假装根本没发生问题。忽略死锁。 几种典型锁？ 读写锁 多个读者可以同时进行读 写者必须互斥（只允许一个写者写，也不能读者写者同时进行） 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者） 互斥锁 一次只能一个线程拥有互斥锁，其他线程只有等待 互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁 条件变量 互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说互斥锁是线程间互斥的机制，条件变量则是同步机制。 自旋锁 自旋锁的提出背景 由于在多处理器环境中某些资源的有限性，有时需要互斥访问(mutual exclusion)，这时候就需要引入锁的概念，只有获取了锁的线程才能够对资源进行访问，由于多线程的核心是CPU的时间分片，所以同一时刻只能有一个线程获取到锁。那么就面临一个问题，那么没有获取到锁的线程应该怎么办？ 通常有两种处理方式：一种是没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做自旋锁，它不用将线程阻塞起来(NON-BLOCKING)；还有一种处理方式就是把自己阻塞起来，等待重新调度请求，这种叫做互斥锁。 定义：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -> 等待的机制被称为自旋锁(spinlock)。 悲观锁 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。 先获取锁，再进行业务操作，一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。 当数据库执行SELECT … FOR UPDATE时会获取被SELECT中的数据行的行锁，SELECT FOR UPDATE获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。 乐观锁 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。先进行业务操作，只在最后实际更新数据时检查数据是否被更新过 如果没有发生冲突则直接修改，如果发生冲突则不做任何修改，然后把结果返回给用户，让用户自行处理。 五种IO模型 IO（Input/Output，输入/输出）即数据的读取（接收）或写入（发送）操作。通常用户进程中的一个完整IO分为两阶段：用户进程空间与内核空间之间的相互切换、内核空间与设备空间的相互切换（磁盘、网络等）。我们通常说的IO是指网络IO和磁盘IO两种。Linux中进程无法直接操作I/O设备，其必须通过系统调用请求内核来协助完成I/O动作；内核会为每个I/O设备维护一个缓冲区。对于一个输入操作来说，进程IO系统调用后，内核会先看缓冲区中有没有相应的缓存数据，没有的话再到设备中读取，因为设备IO一般速度较慢，需要等待；内核缓冲区有数据则直接复制到进程空间。所以，对于一个网络输入操作通常包括两个不同阶段： 等待网络数据到达网卡→读取到内核缓冲区，数据准备好； 从内核缓冲区复制数据到进程空间。 5种IO模型如下： 阻塞IO：进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。调用者将一直等待，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。 非阻塞IO：进程发起IO系统调用后，进程被阻塞，内核数据还没好，不想让进程等待，就返回一个错误，这样进程就不阻塞了。进程每隔一段时间就发起IO系统调用去检查IO事件是否就绪。这样就实现非阻塞了。每个进程都有一个时间片，轮询的时候读取IO，时间片到了就要换另一个进程做其他事情了，这样就做到了每隔一段时间发起IO系统调用。 IO多路复用：Linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检查。select/poll会监听所有的IO，直到有数据可读或可写时，才真正调用IO操作函数。 信号驱动IO：Linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO信号，然后处理IO事件。这个好理解，这个信号直接通知进程数据到了。 异步IO：进程发起IO系统调用后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。用户可以直接去使用数据。具体操作是进程调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回。 前四种属于同步IO，原因就在于进程发起IO系统调用读取数据时，这个真正拿到数据的过程依然是阻塞的，直到完成数据读取还要把数据拷贝到用户空间中，进程才能继续做其他事。 而异步IO就不一样了，进程完全做自己的事情，数据都不需要它读取，而是由内核读取数据并将数据拷贝到缓冲区后，再通知应用程序。用户可以直接去使用数据。 I/O 多路复用（ IO multiplexing） IO多路复用就是通过一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作的一种机制。 I/O多路复用的本质是使用select ，poll 或 epoll函数，挂起进程，当一个或多个IO事件发生之后，将控制返回给用户进程。 以服务器编程为例，传统的多进程（多线程）并发模型，在处理用户连接时都是开启一个新的线程或进程去处理一个新的连接，而IO多路复用则是可以在一个进程（线程）中同时监听多个网络IO事件，也就是多个文件描述符 I/O复用函数本身是阻塞的，能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力。 select int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 每次调用select，都需要把监听的文件描述符集合 fd_set从用户态拷贝多内核态，从算法角度来说就是$O(N)$的时间开销 每次调用select返回之后都需要遍历所有文件描述符，判断哪些文件描述符有读写事件发生，也是$O(N)$的时间开销 内核对被监控的文件描述符的集合大小做了限制，并且这个是通过宏控制的，大小不可改变，为1024。这一点和上一个缺点是矛盾的，文件描述符设大了，遍历时间就长，其效率也会下降 poll int poll (struct pollfd *fds, unsigned int nfds, int timeout); struct pollfd { int fd; /* file descriptor */ short events; /* requested events to watch */ short revents; /* returned events witnessed */ }; poll和select本质上没有差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。 select采用fdset（fdset采用了bitmap），poll采用了数组，所以表示的描述符比select大 poll和select同样存在一个缺点就是，文件描述符的数组被整体复制于用户态和内核态的地址空间之间，而不管这些文件描述符是否有事件，它们的开销随着文件描述符数量的增加而线性增大。 poll返回后，也需要遍历整个描述符的数组才能得到有事件的描述符 epoll int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)； int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); epoll解决了select和poll在文件描述符集合拷贝和遍历上的问题，能够在一个进程中监听多个文件描述符，并且十分高效 在内核当中epoll是以红黑树的方式组织监听事件的，所以查询开销是O(logn)。采用回调的方式检测就绪事件，时间复杂度是O(1) 在注册监听事件时从用户态将数据传入内核态；当返回时需要将就绪队列的内容拷贝到用户空间 对于select和poll来说，所有文件描述符都是在用户态被加入其文件描述符集合的，每次调用都需要将整个集合拷贝到内核态；epoll则将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都需要执行一个系统调用。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，epoll可能会慢于select和poll由于这些大量的系统调用开销。 select使用线性表描述文件描述符集合，文件描述符有上限；poll使用链表来描述；epoll底层通过红黑树来描述，并且维护一个ready list，将事件表中已经就绪的事件添加到这里，在使用epoll_wait调用时，仅观察这个list中有没有数据即可。 select和poll的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，它们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll则不需要去以这种方式检查，当有活动产生时，会自动触发epoll回调函数通知epoll文件描述符，然后内核将这些就绪的文件描述符放到之前提到的ready list中等待epoll_wait调用后被处理。 select和poll都只能工作在相对低效的LT模式下，而epoll同时支持LT和ET模式。 综上，当监测的fd数量较小，且各个fd都很活跃的情况下，建议使用select和poll；当监听的fd数量较多，且单位时间仅部分fd活跃的情况下，使用epoll会明显提升性能。 LT（电平触发） 假设委托内核检测读事件 -> 检测fd的读缓冲区 读缓冲区有数据 - > epoll检测到了会给用户通知 a.用户不读数据，数据一直在缓冲区，epoll 会一直通知 b.用户只读了一部分数据，epoll会通知 c.缓冲区的数据读完了，不通知 LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的。 效率会低于ET触发，尤其在高并发大流量的情况下。但是LT对代码编写要求比较低，不容易出现问题。LT模式服务编写上的表现是：只要有数据没有被获取，内核就不断通知你，因此不用担心时间丢失的情况。 ET（边缘触发） 假设委托内核检测读事件 -> 检测fd的读缓冲区 读缓冲区有数据 - > epoll检测到了会给用户通知 a.用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了 b.用户只读了一部分数据，epoll不通知 c.缓冲区的数据读完了，不通知 ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。效率非常高，在高并发大流量的情况下，会比LT少很多epoll的系统调用，因此效率高。但是对编程要求高，需要细致的处理每个请求，否则容易发生丢失事件的情况。 对于采用LT工作模式的文件描述符，当epoll_wait检测到其上有事 件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。 这样，当应用程序下一次调用epoll_wait时，epoll_wait还会再次向应用 程序通告此事件，直到该事件被处理。而对于采用ET工作模式的文件 描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序 后，应用程序必须立即处理该事件，因为后续的epoll_wait调用将不再 向应用程序通知这一事件。 EPOLLIN ： 表示对应的文件描述符可以读（包括对端SOCKET正常关闭）； EPOLLOUT： 表示对应的文件描述符可以写； EPOLLPRI： 表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）； EPOLLERR： 表示对应的文件描述符发生错误； EPOLLHUP： 表示对应的文件描述符被挂断； EPOLLET： 将 EPOLL设为边缘触发(Edge Triggered)模式（默认为水平触发），这是相对于水平触发(Level Triggered)来说的。 EPOLLONESHOT： 只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列 epoll_create() 创建红黑树的根节点 epoll_ctl() add,del,mod 增加、删除、修改结点 epoll_wait() 把就绪队列的结点copy到用户态放到events里面，跟recv函数很像。等待事件的产生 Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-10-06 09:37:27 "},"数据库.html":{"url":"数据库.html","title":"数据库","keywords":"","body":"数据库 MySQL逻辑架构 分为连接层、服务层、存储引擎层 连接层 系统（客户端）访问 MySQL 服务器前，需要建立 TCP 连接。经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。 服务层 SQL Interface: SQL接口 接收用户的SQL命令，并且返回用户需要查询的结果。 Caches & Buffers： 查询缓存组件 因为查询缓存命中率不高，MySQL 8.0中删除。（相同的查询操作才会命中查询缓存） Parser: 解析器 对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构。 Optimizer: 查询优化器 SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划 存储引擎层 负责数据的存储和提取。MySQL>=5.5之后，默认采用InnoDB引擎（优先考虑InnoDB引擎）。 InnoDB 和 MyISAM的区别 存储引擎 InnoDB MyISAM 事务 支持 不支持 全文索引 不支持 支持 数据量过大时使用count() 瞬间返回，因为MyISAM会直接存储总行数 需要按行扫描再返回结果 外键 支持 不支持 锁 支持表锁、行锁，默认行锁 只支持表锁 一条SQL语句在数据库框架中的执行流程 应用程序把查询SQL语句发送给服务器执行； 查询缓存，如果缓存是打开的，服务器在收到查询请求后，并不会直接去数据库查询，而是在数据库的查询缓存中找是否有相同的查询数据，如果存在，直接返回给客户端。只有缓存不存在时，才会进行下面的操作 查询优化处理，生成执行计划。包括解析SQL、预处理、优化SQL、执行计划 MySQL根据相应的执行计划完成整个查询 将查询结果返回给客户端 数据库三大范式是什么？ 第一范式 数据表的每一列都是不可分割的原子数据项（原子性） 第二范式 要求实体的属性完全依赖于主关键字（唯一性），所谓完全依赖是指不能存在依赖主关键字一部分的属性。（员工id号） 满足1NF，非主属性完全函数依赖于候选码 第三范式 任何主属性不依赖于其他非主属性（每列都与主键有直接关系，不存在传递依赖）。 符合2NF，并且消除了非主属性对于候选码的传递函数依赖。 总结： 第一范式：字段不可分。第二范式：有主键，非主键字段依赖主键。第三范式：非主键字段不能相互依赖。 查询性能的优化方法？ 减少请求的数据量 只返回必要的列：最好不要使用 SELECT * 语句 只返回必要的行：使用 LIMIT 语句来限制返回的数据 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能是非常明显的 减少服务端扫描的行数： 使用索引来覆盖查询 索引 索引（Index）是帮助MySQL高效获取数据的数据结构。 索引的优缺点 优点：降低数据库的IO成本、加速表和表之间的连接、减少查询中分组和排序的时间 ，降低了CPU的消耗、通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。 缺点：创建索引和维护索引要耗费时间、索引需要占磁盘空间、降低更新表的速度 索引的分类 从功能逻辑上说，索引主要有 4 种，分别是普通索引（允许在定义索引的列中插入重复值和空值）、唯一索引（唯一，允许有空值）、主键索引（唯一，不允许有空值）、全文索引（支持值的全文查找）。按照物理实现方式 ，索引可以分为 2 种：聚簇索引和非聚簇索引。 按照作用字段个数进行划分，分成单列索引和联合索引。 聚簇索引 聚簇索引是对磁盘上实际数据重新组织，然后按指定的一个或多个列的值排序的算法。 聚簇索引的特点是存储数据的顺序和索引顺序一致。 一般情况下主键会默认创建聚簇索引，而且一张表只允许存在一个聚簇索引 辅助索引（非聚簇索引） 辅助索引是根据索引键创建的一棵B+树，与聚簇索引不同的是，其叶子节点仅存放索引键值，以及该索引键值指向的主键。也就是说，如果通过辅助索引来查找数据，那么当找到辅助索引的叶子节点后，还需要根据主键值查找聚簇索引来得到数据，这个过程称为回表。 联合索引 同时为多个列建立索引，比方说我们想让B+树按照 c2和c3列 的大小进行排序，这个包含两层含义：先把各个记录和页按照c2列进行排序，在记录的c2列相同的情况下，采用c3列进行排序。 适合建立索引的情况： 在频繁使用的、需要排序的字段上建立索引 字段的数值有唯一性的限制 频繁作为 WHERE 查询条件的字段 经常 GROUP BY 和 ORDER BY 的列 DISTINCT 字段需要创建索引 不适合建索引的情况： 对于查询中很少涉及的列或重复值比较多的列，不适合建立索引 对于一些特殊的数据类型，不适合建立索引，比如文本字段 (text)等 在where中使用不到的字段，不要设置索引 数据量小的表最好不要使用索引 有大量重复数据的列上不要建立索引 避免对经常更新的表创建过多的索引 什么时候索引失效？ 1、索引列参与表达式计算 SELECT 'sname' FROM 'stu' WHERE 'age' + 10 = 30; 2、函数运算： SELECT 'sname' FROM 'stu' WHERE LEFT('date',4) 3、%语句% 模糊查询: SELECT * FROM 'manong' WHERE 'uname' LIKE '%码农%' -- 走索引 SELECT * FROM 'manong' WHERE 'uname' LIKE \"%码农%\" -- 不走索引 4、字符串与数字比较不走索引： CREATE TABLE 'a' ('a' char(10)); EXPLAIN SELECT * FROM 'a' WHERE 'a' = \"1\"; -- 走索引 EXPLAIN SELECT * FROM 'a' WHERE 'a' = 1; -- 不走索引，同样也是使用了函数运算 5、查询条件中有or，即时其中有条件带索引也不会使用（前后有非索引的列） SELECT * FROM dept WHERE dname='xxx' or loc='xx' or deptno=45; 6、正则表达式不使用索引 7、MySQL内部优化器会对SQL语句进行优化，如果优化器估算使用全表扫描比使用索引快，则不使用索引。使用不等于（!=或者<>） 如何判断数据库的索引有没有生效？ 使用Explain命令查看语句的执行计划，MySQL在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了很多信息。可以通过其中和索引有关的信息来分析是否命中了索引，例如：possible_key、key、key_len等字段，分别说明了此语句可能会使用的索引、实际使用的索引以及索引的长度。 索引的底层数据结构 索引的数据结构和具体存储引擎的实现有关，常用的有Hash索引，B+树索引等。InnoDB存储引擎默认索引实现为B+树索引。 b树（平衡多路查找树） B树是一种平衡的多分树，通常我们说 m阶(B树中一个节点的子节点数目的最大值) 的B树，它必须满足如下条件： 每个节点最多只有m个子节点 每个非叶子节点（除了根）具有至少[m/2]子节点 如果根不是叶节点，则根至少有两个子节点 具有k个子节点的非叶节点包含k -1个键 所有叶子都出现在同一水平，没有任何信息（高度一致） b+树 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B树的叶子节点并没有包括全部需要查找的信息)； 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B树的非终节点也包含需要查找的有效信息)； B树与B+树的差异 B+树由分块查找进化而来；B树由二叉排序树进来而来 B+树支持顺序查找和多路查找；B树只支持多路查找 在B+树中，仅叶子节点包含信息，非叶子节点仅起索引作用；在B树中，全部节点的关键字都包含信息。 在B+树中，叶结点包含了全部的关键字，非叶节点中出现的关键字一定会出现在叶子结点中；在B树中，任何节点的关键字都不会重复。 B树的每个节点，有m个key，m+1个指针，B+树的每个节点，有m+1个key，m+1个指针。 事务 事务的特性 原子性（atomicity）A 是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。 一致性（consistency）C 一致性是指事务执行前后，数据从一个合法性状态变换到另外一个合法性状态 。这种状态是语义上的而不是语法上的，跟具体的业务有关。 隔离型（isolation）I 事务的隔离性是指一个事务的执行 不能被其他事务干扰 ，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（durability）D 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的 ，接下来的其他操作和数据库故障不应该对其有任何影响。 事务的隔离级别 读未提交（READ UNCOMMITTED）最低的隔离级别，允许读取尚未提交的数据变更 读提交 （READ COMMITTED）允许读取并发事务已经提交的数据 可重复读 （REPEATABLE READ）对同一字段的多次读取结果都是一致的，除非数据是被本事务自己所修改 串行化 （SERIALIZABLE）最高隔离级别，完全服从ACID的隔离级别。所有的事务依次执行，这样事务之间就完全不可能产生干扰，严重影响程序的性能，通常情况都不会使用该级别。 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITTED 可能 可能 可能 READ COMMITTED 不可能 可能 可能 REPEATABLE READ 不可能 不可能 可能 SERIALIZABLE 不可能 不可能 不可能 默认隔离级别： MySQL：REPEATABLE_READ ORACLE：READ_COMMITTED MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方案解决，也可以采用加锁方案解决。（间隙锁） 什么是脏读、不可重复读、幻读？ 脏读：当前事务(A)中可以读到其他事务(B)未提交的数据（脏数据），这种现象是脏读。 不可重复读：在事务A中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。 幻读：在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。 MVCC（Multi-Version Concurrency Control, 多版本并发控制） 通过数据行的多个版本管理来实现数据库的并发控制，简单来说就是保存数据的历史版本。可以通过比较版本号决定数据是否显示出来。读取数据的时候不需要加锁可以保证事务的隔离效果。 读——读：不存在任何问题，也不需要并发控制 读——写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读 写——写：有线程安全问题，可能会存在更新丢失的问题 MVCC 可以为数据库解决以下问题： 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发的读写性能 可以解决脏读、不可重复读、幻读等事务隔离问题，但不能解决更新丢失问题。 锁 操作类型划分 共享锁（S Lock），读锁，针对同一份数据，多个事务的读操作可以同时进行而不会互相影响。 排他锁（X Lock），写锁，当前写操作没有完成前，它会阻断其他写锁和读锁。 粒度划分 表级锁： 开销⼩，加锁快，不会出现死锁。锁定粒度大，发⽣锁冲突的概率最⾼，并发量最低。 行锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高。 页级锁 意向锁（表级别） 意向共享锁（IS Lock），事务有意向对表中的某些行加共享锁（S锁） 意向排他锁（IX Lock），事务有意向对表中的某些行加排他锁（X锁） InnoDB 存储引擎的锁算法有哪些？ Record Lock：单个行记录上的锁。 Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。 Next-Key Lock∶Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。 其他 主从复制是什么？主从复制中涉及到哪三个线程？ 主从复制是什么？ 主从复制是用来建立一个和主数据库完全一样的数据库环境，称为从数据库；主数据库一般是实时的业务数据库，从数据库的作用和使用场合一般有几个： 一是作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作； 二是可在从数据库作备份、数据统计等工作，这样不影响主数据库的性能； 主从复制中涉及到哪三个线程？ binlog线程：负责将主服务器上的数据更改写入二进制日志（Binary log）中 I/O线程：负责从主服务器上读取二进制日志，并写入从服务器的重放日志（Relay log）中 SQL线程：负责读取重放日志并重放其中的SQL数据 内存、磁盘 索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。 内存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响。 机械硬盘结构：磁盘转动，磁头沿半径方向移动（实际是斜切向运动）。磁盘的每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。 当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。 局部性原理与磁盘预读 由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。 Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-10-06 09:34:02 "},"Linux常用命令.html":{"url":"Linux常用命令.html","title":"Linux常用命令","keywords":"","body":"linux常用命令 文件和目录常用命令 pwd查看当前所在目录 cd ~ # 进入当前用户主目录 cd .. # 进入上级目录 cd / # 进入系统根目录 ls -a # 列出目录下所有文件和目录 ls -l # 等同于ll 将文件的名字、权限、所有者、文件大小等信息详细列出来 touch 新建文件命令 mkdir 创建一个空目录 rm -f # 强制删除 rm -r # 删除目录和目录里所有文件 rm -rf /* # 删库跑路 mv a.txt b.txt # 修改文件名 mv b.txt ../ # 将文件移动到上级目录 cp 源文件 目标文件（夹） # 复制一个源文件到目标文件（夹） cp -r 源文件夹 目标文件夹 # 复制源文件夹到目标文件夹下 cp -u 源文件 目标文件 # 只有源文件较目标文件新时复制。 chmod 权限 Linux系统中一切都是文件。Linux使用不同的字符来区分不同的文件： 普通文件 目录文件 链接文件 块设备文件 字符设备文件 管道文件 - d l b c p 每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。 文件权限的数字表示法基于字符（rwx）的权限计算而来，其目的是简化权限的表示方式。例如，若某个文件的权限为7，则代表可读、可写、可执行（4+2+1）；若权限为6，则代表可读、可写（4+2）。 chmod who operator permission file` 如`chmod u+x rumenz.txt who(用户类型) who 用户类型 说明 u user 文件所有者 g group 文件所有者所在组 o others 所有其他用户 a all 所用用户, 相当于 ugo operator(符号模式表) Operator 说明 + 为指定的用户类型增加权限 - 去除指定用户类型的权限 = 设置指定用户权限的设置，即将用户类型的所有权限重新设置 permission(权限) 模式 名字 说明 r 读 设置为可读权限 w 写 设置为可写权限 x 执行权限 设置为可执行权限 常见的数字权限 400 -r———— 拥有者能够读，其他任何人不能进行任何操作； 644 -rw-r—r— 拥有者都能够读，但只有拥有者可以编辑； 660 -rw-rw—— 拥有者和组用户都可读和写，其他人不能进行任何操作； 664 -rw-rw-r— 所有人都可读，但只有拥有者和组用户可编辑； 700 -rwx——— 拥有者能够读、写和执行，其他用户不能任何操作； 744 -rwxr—r— 所有人都能读，但只有拥有者才能编辑和执行； 755 -rwxr-xr-x 所有人都能读和执行，但只有拥有者才能编辑； 777 -rwxrwxrwx 所有人都能读、写和执行（该设置通常不是好想法）。 对文件test赋权chmod 777 test或对一个目录赋权要加 -R，递归执行，如对yzj目录执行赋权，chmod -R 777 yzj grep 搜索内容 grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 格式：grep [选项] ”模式“ [文件] 内容和文件名均可写作正则表达式 -i：在搜索的时候忽略大小写 -n：显示结果所在行号 -c：统计匹配到的行数，注意，是匹配到的总行数，不是匹配到的次数 -o：只显示符合条件的字符串，但是不整行显示，每个符合条件的字符串单独显示一行 -v：输出不带关键字的行（反向查询，反向匹配） -w：匹配整个单词，如果是字符串中包含这个单词，则不作匹配 -Ax：在输出的时候包含结果所在行之后的指定行数，这里指之后的x行，A：after -Bx：在输出的时候包含结果所在行之前的指定行数，这里指之前的x行，B：before -Cx：在输出的时候包含结果所在行之前和之后的指定行数，这里指之前和之后的x行，C：context -e：实现多个选项的匹配，逻辑or关系 -P：表示使用兼容perl的正则引擎。 -E：使用扩展正则表达式，而不是基本正则表达式，在使用\"-E\"选项时，相当于使用egrep。 find 搜索文件 find 搜索路径 [选项] 搜索内容 -name 通过文件名字来查找 find . -name a.cpp # 从当前目录搜索 cat、more、tail 显示文本文件内容 cat 文件名：cat命令一次显示整个文件的内容 more 文件名：more命令分页显示文件的内容，按空格键显示下一页，按b键显上一页，按q键退出。 tail -f 文件名：tail -f用于显示文本文件的最后几行，如果文件的内容有增加，就实时的刷新。对程序员来说，tail -f极其重要，可以动态显示后台服务程序的日志，用于调试和跟踪程序的运行。 进程管理 常用命令 作用 ps -ef 查看所有进程 ps -ef \\ grep expression 用正则表达式过滤出所需要的进程 kill -s name kill指定名称进程 kill -s pid kill指定pid的进程 top 实时显示进程状态 iostate 查看io读写/cpu使用情况 sar -u 1 10 查询cpu使用情况（1秒1次，共10次） sar -d 1 10 查询磁盘性能 网络 常用命令 作用 ifconfig 查看网络接口属性 ip addr 查看ip地址 ipconfig eh0 192.168.1.1 netmask 255.255.255.255 配置ip地址 netstat 查看各种网络相关信息 netstat -lntp 查看所有监听端口 netstat -antp 查看已经建立的TCP连接 netstat -lutp 查看TCP/UDP的状态信息 route -n 查看路由表 系统服务 常用命令 作用 systemctl status 查看某个服务 systemctl start 启动某个服务 systemctl stop 终止某个服务 systemctl restart 重启某个服务 systemctl enable 开启自启动 systemctl disable 关闭自启动 chkconfig --list 列出系统服务 使用systemctl命令 配置防火墙的过程如下 查看防火墙的命令： 1）查看防火墙的版本。firewall-cmd --version 2）查看firewall的状态。firewall-cmd --state 3）查看firewall服务状态（普通用户可执行）。systemctl status firewalld 4）查看防火墙全部的信息。firewall-cmd --list-all 5）查看防火墙已开通的端口。firewall-cmd --list-port 6）查看防火墙已开通的服务。firewall-cmd --list-service 7）查看全部的服务列表（普通用户可执行）。firewall-cmd --get-services 8）查看防火墙服务是否开机启动。 systemctl is-enabled firewalld 配置防火墙的命令： 1）启动、重启、关闭防火墙服务。 systemctl start firewalld # 启动 systemctl restart firewalld # 重启 systemctl stop firewalld # 关闭 2）开放、移去某个端口。 firewall-cmd --zone=public --add-port=80/tcp --permanent # 开放80端口 firewall-cmd --zone=public --remove-port=80/tcp --permanent # 移去80端口 3）开放、移去范围端口。 firewall-cmd --zone=public --add-port=5000-5500/tcp --permanent # 开放5000-5500之间的端口 firewall-cmd --zone=public --remove-port=5000-5500/tcp --permanent # 移去5000-5500之间的端口 4）开放、移去服务。 firewall-cmd --zone=public --add-service=ftp --permanent # 开放ftp服务 firewall-cmd --zone=public --remove-service=ftp --permanent # 移去http服务 5）重新加载防火墙配置（修改配置后要重新加载防火墙配置或重启防火墙服务）。 firewall-cmd --reload 6）设置开机时启用、禁用防火墙服务。 systemctl enable firewalld # 启用服务 systemctl disable firewalld # 禁用服务 其他 tar -xvf xxx.tar 解压tar包 *.tar 用 tar –xvf 解压 *.gz 用 gzip -d或者gunzip 解压 .tar.gz和.tgz 用 tar –xzf 解压 *.bz2 用 bzip2 -d或者用bunzip2 解压 *.tar.bz2用tar –xjf 解压 *.Z 用 uncompress 解压 *.tar.Z 用tar –xZf 解压 *.rar 用 unrar e解压 *.zip 用 unzip 解压 *.xz 用 xz -d 解压 *.tar.xz 用 tar -zJf 解压 整理 首先是一些文件和目录操作的命令，比如： cd 、pwd、 ls、 创建 touch 、mkdir，删除 rm、移动或重命名 rm，复制cp cat、more、tail 查看文件内容 还有一些重要的命令，如chmod 权限管理、grep 搜索内容、find 搜索文件 还有一些和网络相关的命令 ipconfig 查看网络接口属性，配置ip地址 netstat 查看各种网络相关信息 route 查看路由 ping 进程管理的常用命令有： ps -ef 查看所有进程信息 kill 杀死进程 系统方面常用的有： top 可以动态显示cpu、内存、进程等情况 iostat 可以查看io读写/cpu使用情况 sar 查询cpu、磁盘使用情况 env 可以查看环境变量 date 显示日期 还有一些服务的常用命令 systemctl 管理服务 firewall-cmd 防火墙 vsftpd 文件传输 一些软件安装管理的 rpm、yum、dpkg、apt-get用于安装管理软件 解压缩有： tar -xvf xxx.tar 解压tar包 zip、unzip gzip与gunzip git 1、git init：初始化一个Git仓库； 2、git clone：从远程仓库克隆代码到本地； 3、git add：添加文件到暂存区； 4、git commit：将暂存区的文件提交到本地仓库； 5、git push：将本地仓库的代码推送到远程仓库； 6、git pull：从远程仓库拉取最新代码； 7、git branch：列出所有本地分支； 8、git checkout：切换分支或恢复工作树文件； 9、git merge：合并指定分支到当前分支； 10、git status：显示工作树的状态； 11、git log：显示提交日志； 12、git diff：显示工作树与暂存区或本地仓库之间的差异； 13、git stash：将当前工作区的变更储存到一个临时区域； 14、git tag：添加、列出或删除标签； 15、git remote：管理远程仓库； 16、git fetch：从远程仓库拉取最新代码，但不自动合并到本地仓库； Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-09-07 16:09:11 "},"SQL.html":{"url":"SQL.html","title":"SQL","keywords":"","body":"SQL语法 参考：MySQL必知必会 SQL语法顺序 SQL SELECT 检索数据 SELECT 列 FROM 表名; # 单个列 SELECT 列1,列2,列3 FROM 表名; # 多个列 SELECT * FROM 表名; # 所有列 DISTINCT 去重，只返回选择列唯一的行。 SELECT DISTINCT 列 FROM 表名; LIMIT 限制结果，只显示前n行。 SELECT 列 FROM 表名 LIMIT 5,5; # 从行5开始的5行 限定名 SELECT 表名.列 FROM 表名 # 限制列名 SELECT 表名.列 FROM 数据库.表名 # 限制表名 ORDER BY 默认升序排列（从A到Z） SELECT 列 FROM 表名 ORDER BY 列; SELECT 列1,列2,列3 FROM 表名ORDER BY 列1,列2; # 先按列1排序，然后再按列2排序 DESC 降序排序，从Z到A排序 SELECT 列 FROM 表名 ORDER BY 列 DESC; WHERE 过滤数据 SELECT 列1,列2 FROM 表名 WHERE 列1 = 2.5 # 从表中检索两个列，只返回列1值等于2.5的行 WHERE子句操作符 操作符 说明 = 等于 <> 不等于 != 不等于 小于 小于等于 > 大于 >= 大于等于 BETWEEN 在指定的两个值之间 例：BETWEEN 5 AND 10 对字符串操作时需要加单引号 # 空值检查 SELECT 列1,列2 FROM 表名 WHERE 列1 IS NULL; # 返回列1为空（不是为0） AND 用在WHERE子句中的关键字，用来指示检索满足所有给定条件的行。 OR OR操作符与AND操作符不同，它指示MySQL检索匹配任一条件的行。 IN IN操作符用来指定条件范围，功能与OR相当。 SELECT 列1,列2 FROM 表名 WHERE 列1 IN (1002,1003); NOT NOT WHERE子句中用来否定后跟条件的关键字。 LIKE 通配符：%表示任何字符出现任意次数，_用途与%一样但下划线只匹配单个字符而不是多个字符。 SELECT 列1,列2 FROM 表名 WHERE 列1 LIKE 'jet%'; # 检索任意以jet起头的词 REGEXP REGEXP后所跟的东西作为正则表达式 Concat() 把两个列拼接起来 SELECT Concat(列1,'(',列2,')') FROM 表名; # 列1(列2) AS 起别名 文本处理函数 函数 说明 Left() 返回串左边的字符 Length() 返回串的长度 Locate() 找出串的一个子串 Lower() 将串转换为小写 LTrim() 去掉串左边的空格 Right() 返回串右边的字符 RTrim() 去掉串右边的空格 Soundex() 返回串的SOUNDEX值 SubString() 返回子串的字符 Upper() 将串转换为大写 日期和时间处理函数 略。 数值处理函数 函数 说明 Abs() 返回一个数的绝对值 Cos() 返回一个角度的余弦 Exp() 返回一个数的指数值 Mod() 返回除操作的余数 Pi() 返回圆周率 Rand() 返回一个随机数 Sin() 返回一个角度的正弦 Sqrt() 返回一个数的平方根 Tan() 返回一个角度的正切 聚集函数 运行在行组上，计算和返回单个值的函数 函数 说明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 GROUP BY 根据一个或多个列对结果集进行分组。在分组的列上我们通常配合 COUNT, SUM, AVG等函数一起使用。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 HAVING 过滤分组 HAVING和WHERE的差别：WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。这是一个重要的区别，WHERE排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组。WHERE过滤行，而HAVING过滤分组。 ORDER BY GROUP BY 排序产生的输出 分组行。但输出可能不是分组的顺序 任意列都可以使用（甚至非选择的列也可以使用） 只可能使用选择列或表达式列，而且必须使用每个选择列表达式 不一定需要 如果与聚集函数一起使用列（或表达式），则必须使用 子查询 在WHERE子句中使用子查询，应该保证SELECT语句具有与WHERE子句中相同数目的列。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。 连结表 联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。 SELECT 列1,列2,列3 FROM 表1,表2 WHERE 表1.列4 = 表2.列4; 没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。 可视化网站：https://joins.spathon.com/ UNION 组合查询 UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔。 UNION中的每个查询必须包含相同的列、表达式或聚集函数。 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型。 使用UNION ALL，MySQL不取消重复的行。 INSERT 插入数据、UPDATE 更新数据、DELETE 删除数据 CREATE TABLE 创建表 AUTO_INCREMENT，本列每当增加一行时自动增量 ALTER TABLE 更新表、DROP TABLE 删除表、RENAME TABLE 重命名表 CREATE VIEW 视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。 为什么使用视图？ 重用SQL语句。 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。 使用表的组成部分而不是整个表。 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 CREATE VIEW viewname AS SELECT 列1,列2 FROM 表名 WHERE 列1 = 2.2; # 创建视图 SHOW CREATE VIEW viewname; # 查看创建的视图 DROP VIEW viewname; # 删除视图 存储过程 为什么要使用存储过程？ 通过把处理封装在容易使用的单元中，简化复杂的操作。 简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，只需要更改存储过程的代码。 由于不要求反复建立一系列处理步骤，这保证了数据的完整性。 提高性能。因为使用存储过程比使用单独的SQL语句要快。 存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码。 CREATE PROCEDURE productpricing() # 创建存储过程 BEGIN SELECT 列1,列2 FROM 表名 WHERE 列1 = 2.2; END; # 此存储过程名为productpricing,BEGIN和END语句用来限定存储过程体,过程体本身是一个SELECT语句 CALL productpricing() # 使用存储过程 DROP PROCEDURE productpricing() # 删除存储过程 # 可以使用参数 暂时略 SHOW CREATE PROCEDURE productpricing() # 检查存储过程 游标 游标（cursor）是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。 CREATE PROCEDURE processorders() BEGIN DECLARE ordernumbers CURSOR # 游标用DECLARE语句创建 FOR SELECT order_num FROM orders; END; OPEN ordernumbers; # 打开游标 FETCH ordernumbers INTO o; # 检索当前行的order_num列（将自动从第一行开始）到一个名为o的局部声明的变量中。 CLOSE ordernumbers; # 关闭游标 触发器 触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）：DELETE、INSERT、UPDATE。只有表才支持触发器，视图不支持，每个表最多支持6个触发器。 CREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW SELECT 'Product added'; # CREATE TRIGGER 创建触发器 # AFTER INSERT 在INSERT语句成功执行后执行 BEFORE 在之前 # FOR EACH ROW 对每个插入行执行 DROP TRIGGER newproduct # 删除触发器 事务 事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。 START TRANSACTION; # 事务开始 ROLLBACK; # 回退 COMMIT; # 提交 SAVEPOINT delete1; # 使用保留点 ROLLBACK TO delete1; # 回退到保留点 事务处理用来管理INSERT、UPDATE和DELETE语句。不能回退SELECT语句或CREATE或DROP操作。 插入、更新、删除 INSERT INTO 表名 VALUES(,,); UPDATE 表名 SET 列名 = ' ' WHERE 过滤条件 # 可以删除某个列的值 DELETE FROM 表名 WHERE 过滤条件 # 删除特定的行 创建表 CREATE TABLE 表名(); Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-10-05 16:00:21 "},"剑指offer.html":{"url":"剑指offer.html","title":"剑指offer","keywords":"","body":"剑指offer 链表 //Definition for singly-linked list struct ListNode{ int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; 06. 从尾到头打印链表 法一：用栈解决 class Solution { public: vector reversePrint(ListNode* head){ ListNode *p=head; stack a; vector b; while(p!=nullptr){ a.push(p->val); p = p->next; } while(!a.empty()){ b.push_back(a.top()); a.pop(); } return b; } }; 法二：递归 class Solution { public: vector a; vector reversePrint(ListNode* head){ if (head!=nullptr){ if(head->next!=nullptr){ reversePrint(head->next); } a.push_back(head->val); } return a; } }; 18. 删除链表的节点 class Solution { public: ListNode* deleteNode(ListNode* head, int val) { ListNode *p = new ListNode; p->next=head; ListNode *cur = p; while(cur!=nullptr &&cur->next!=nullptr){ if(cur->next->val == val){ cur->next=cur->next->next; } cur=cur->next; } return p->next; } }; 22. 链表中倒数第k个节点 法一： class Solution { public: ListNode* getKthFromEnd(ListNode* head, int k) { int l = 0; ListNode *p=head; ListNode *q=head; while(p!=nullptr){ l++; p=p->next; } for(int i =0;inext; } return q; } }; 法二：快慢指针 p先走k步，然后p、q指针同时走，直到p走到尾后返回q。 class Solution { public: ListNode* getKthFromEnd(ListNode* head, int k) { ListNode *p = head; ListNode *q = head; for(int i=0;inext; } while(p!=nullptr){ p=p->next; q=q->next; } return q; } }; 24. 反转链表 法一：双指针 class Solution { public: ListNode* reverseList(ListNode* head) { ListNode *p=nullptr; ListNode *q=head; while(q!=nullptr){ ListNode *t = q->next; q->next=p; p=q; q=t; } return p; } }; 法二：递归 class Solution { public: ListNode* reverseList(ListNode* head) { return recur(head, nullptr); // 调用递归并返回 } private: ListNode* recur(ListNode* cur, ListNode* pre) { if (cur == nullptr) return pre; // 终止条件 ListNode* res = recur(cur->next, cur); // 递归后继节点 cur->next = pre; // 修改节点引用指向 return res; // 返回反转链表的头节点 } }; 25. 合并两个排序的链表 class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode *d=new ListNode(); ListNode *a=d; while(l1!=nullptr && l2!=nullptr){ if(l1->val>l2->val){ a->next=l2; l2=l2->next; } else{ a->next=l1; l1=l1->next; } a=a->next; } if(l1==nullptr){ a->next=l2; return d->next; } else{ a->next=l1; return d->next; } } }; 35. 复杂链表的复制 利用哈希表构建 class Solution { public: Node* copyRandomList(Node* head) { if(head==nullptr){ return head; } unordered_map ma; Node *p=head; while(p!=nullptr){ ma[p]=new Node(p->val); p=p->next; } p=head; while(p!=nullptr){ ma[p]->next=ma[p->next]; ma[p]->random=ma[p->random]; p=p->next; } return ma[head]; } }; 52. 两个链表的第一个公共节点 利用set集合查询是否为同一个节点，是则返回。 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { unordered_set se; ListNode *p = headA; while(p!=nullptr){ se.insert(p); p=p->next; } ListNode *q = headB; while(q!=nullptr){ if(se.find(q)!=se.end()){ return q; } q=q->next; } return NULL; } }; 二叉树 //Definition for a binary tree node struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; 二叉树的前中后序遍历 题号：144、94、145 class Solution { public: void preorder(TreeNode *root, vector &res) { if (root == nullptr) { return; } res.push_back(root->val); // 位置 前中后 preorder(root->left, res); //左节点 preorder(root->right, res); //右节点 } vector preorderTraversal(TreeNode *root) { vector res; preorder(root, res); return res; } }; 07. 重建二叉树 class Solution { public: TreeNode* buildTree(vector& preorder, vector& inorder) { this->preorder=preorder; for(int i=0;i ma; vector preorder; //root 根节点在先序遍历中的索引 left 子树在中序遍历的左边界 right 子树在中序遍历的右边界 TreeNode* build(int root,int left,int right){ if(left>right) return nullptr; TreeNode *node=new TreeNode(preorder[root]); int i=ma[preorder[root]]; // 根节点在中序遍历的索引位置 node->left=build(root+1,left,i-1); // 左子树 node->right=build(root+i-left+1,i+1,right); // 右子树 return node; } }; 26. 树的子结构 class Solution { public: bool isSubStructure(TreeNode* A, TreeNode* B) { return (A!=nullptr && B!=nullptr) && (digui(A,B) || isSubStructure(A->left,B) || isSubStructure(A->right,B)); } bool digui(TreeNode* A, TreeNode* B){ if(B==nullptr) return true; if(A==nullptr || A->val != B->val) return false; return digui(A->left,B->left) && digui(A->right,B->right); } }; 27. 二叉树的镜像 class Solution { public: TreeNode* mirrorTree(TreeNode* root) { digui(root); return root; } void digui(TreeNode *root){ if(root==nullptr){ return; } TreeNode *tmp=root->left; root->left=root->right; root->right=tmp; digui(root->left); digui(root->right); } }; 28. 对称的二叉树 class Solution { public: bool isSymmetric(TreeNode* root) { if(root == nullptr) return true; return digui(root->left,root->right); } bool digui(TreeNode *a,TreeNode *b){ if((a==nullptr && b==nullptr)) return true; if(a==nullptr || b==nullptr || a->val!=b->val) return false; return digui(a->left,b->right) && digui(b->left,a->right); } }; 32 - I. 从上到下打印二叉树 层序遍历 BFS（广度优先搜索），queue+vector 解决。 class Solution { public: vector levelOrder(TreeNode* root) { vector res; if(root==nullptr) return res; queue q; q.push(root); while(q.size()){ TreeNode* node=q.front(); res.push_back(node->val); q.pop(); if(node->left!=nullptr) q.push(node->left); if(node->right!=nullptr) q.push(node->right); } return res; } }; 32 - II. 从上到下打印二叉树 class Solution { public: vector> levelOrder(TreeNode* root) { vector> a; queue q; if(root==nullptr) return a; q.push(root); while(q.size()){ int s=q.size(); vector b; for(int i=0;ival); q.pop(); if(t->left!=nullptr) q.push(t->left); if(t->right!=nullptr) q.push(t->right); } a.push_back(b); } return a; } }; 32 - III. 从上到下打印二叉树 class Solution { public: vector> levelOrder(TreeNode* root) { int cnt=1; vector> a; queue q; if(root==nullptr) return a; q.push(root); while(q.size()){ int s=q.size(); vector b; for(int i=0;ival); q.pop(); if(t->left!=nullptr) q.push(t->left); if(t->right!=nullptr) q.push(t->right); } if(cnt%2==0) reverse(b.begin(),b.end()); cnt++; a.push_back(b); } return a; } }; 33. 二叉搜索树的后序遍历序列 找大于根节点的位置来划分左右子树递归判断 class Solution { public: bool verifyPostorder(vector& postorder) { return digui(postorder,0,postorder.size()-1); } bool digui(vector& postorder,int i,int j){ if(i>=j) return true; int p=i; while(postorder[p]postorder[j]) p++; return p==j && digui(postorder,i,m-1) &&digui(postorder,m,j-1); } }; 34. 二叉树中和为某一值的路径 回溯法： 某一种可能情况向前探索，并生成一个子节点。 过程中，一旦发现原来的选择不符合要求，就回溯至父亲结点，然后重新选择另一方向，再次生成子结点，继续向前探索。 如此反复进行，直至求得最优解。 class Solution { public: vector> pathSum(TreeNode* root, int target) { recur(root, target); return res; } private: vector> res; vector path; void recur(TreeNode *root, int tar) { if (root == nullptr) return; path.push_back(root->val); tar -= root->val; if (tar == 0 && root->left == nullptr && root->right == nullptr) { res.push_back(path); } recur(root->left, tar); recur(root->right, tar); path.pop_back(); } }; 36. 二叉搜索树与双向链表 二叉搜索树的中序遍历为 递增序列 //right 上一个 left 下一个 class Solution { public: Node* treeToDoublyList(Node* root) { if(root==nullptr) return nullptr; digui(root); head->left=pre; pre->right=head; return head; } private: Node *pre,*head; void digui(Node* cur){ if(cur==nullptr) return; digui(cur->left); if(pre==nullptr) head=cur; else{ pre->right=cur; } cur->left=pre; pre=cur; digui(cur->right); } }; 37. 序列化二叉树 难 层次遍历 54. 二叉搜索树的第k大节点 class Solution { public: vector a; int kthLargest(TreeNode* root, int k) { digui(root); return a[k-1]; } void digui(TreeNode* root){ if(root==nullptr) return; digui(root->right); a.push_back(root->val); digui(root->left); } }; 55 - I. 二叉树的深度 class Solution { public: int maxDepth(TreeNode* root) { if(root==nullptr) return 0; return max(maxDepth(root->left),maxDepth(root->right))+1; } }; 55 - II. 平衡二叉树 class Solution { public: bool isBalanced(TreeNode* root) { if(root==nullptr) return true; return abs(digui(root->left) - digui(root->right)) left) && isBalanced(root->right); } int digui(TreeNode *root){ if(root==nullptr) return 0; return max(digui(root->left),digui(root->right))+1; } }; 68 - I. 二叉搜索树的最近公共祖先 //分三种情况 1.都是左节点后代 2.都是右节点后代 3.分别是左右节点后代 class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(p->val > root->val &&q->val>root->val){ return lowestCommonAncestor(root->right,p,q); } if(p->val val &&q->valval){ return lowestCommonAncestor(root->left,p,q); } return root; } }; 68 - II. 二叉树的最近公共祖先 class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == nullptr || root == p || root == q) return root; TreeNode *left = lowestCommonAncestor(root->left, p, q); TreeNode *right = lowestCommonAncestor(root->right, p, q); if(left == nullptr && right == nullptr) return nullptr; // 1. if(left == nullptr) return right; // 3. if(right == nullptr) return left; // 4. return root; // 2. if(left != null and right != null) } }; 栈和队列 09. 用两个栈实现队列 class CQueue { public: CQueue() { } void in2out(){ while(!s1.empty()){ s2.push(s1.top()); s1.pop(); } } void appendTail(int value) { s1.push(value); } int deleteHead() { if(s2.empty()){ if(s1.empty()){ return -1; } in2out(); } int v = s2.top(); s2.pop(); return v; } private: stack s1; stack s2; }; 30. 包含min函数的栈 class MinStack { public: MinStack() { smin.push(INT_MAX); } void push(int x) { s.push(x); if(x s; stack smin; }; 31. 栈的压入、弹出序列 class Solution { public: bool validateStackSequences(vector& pushed, vector& popped) { stack s; int i =0; for(int a: pushed){ s.push(a); while(!s.empty() && s.top() == popped[i]){ s.pop(); i++; } } return s.empty(); } }; 58 - I. 翻转单词顺序 用栈麻烦，二次翻转或者getline class Solution { public: string reverseWords(string s) { stringstream iss(s); string ret=\"\"; string str; while(getline(iss,str,' ')) { if(str!=\"\") { if(ret==\"\") ret=str; else ret=str+\" \"+ret; } } return ret; } }; 59 - I. 滑动窗口的最大值 难 59 - II. 队列的最大值 class MaxQueue { public: MaxQueue() { } int max_value() { return deq.empty() ? -1 : deq.front(); } void push_back(int value) { que.push(value); while(!deq.empty() && deq.back() que; deque deq; }; 堆 40. 最小的k个数 class Solution { public: void quicksort(vector &a, int low,int high){ if(lowlow && a[--n]>=base); if(m getLeastNumbers(vector& arr, int k) { quicksort(arr,0,arr.size()-1); vector res; for(int i=0;i 41. 数据流中的中位数 难 字符串 19. 正则表达式匹配 难 20. 表示数值的字符串 class Solution { private: // 整数的格式可以用[+|-]B表示, 其中B为无符号整数 bool scanInteger(const string s, int& index){ if(s[index] == '+' || s[index] == '-') ++index; return scanUnsignedInteger(s, index); } bool scanUnsignedInteger(const string s, int& index){ int befor = index; while(index != s.size() && s[index] >= '0' && s[index] befor; } public: // 数字的格式可以用A[.[B]][e|EC]或者.B[e|EC]表示， // 其中A和C都是整数（可以有正负号，也可以没有），而B是一个无符号整数 bool isNumber(string s) { if(s.size() == 0) return false; int index = 0; //字符串开始有空格，可以返回true while(s[index] == ' ') //书中代码没有该项测试 ++index; bool numeric = scanInteger(s, index); // 如果出现'.'，接下来是数字的小数部分 if(s[index] == '.'){ ++index; // 下面一行代码用||的原因： // 1. 小数可以没有整数部分，例如.123等于0.123； // 2. 小数点后面可以没有数字，例如233.等于233.0； // 3. 当然小数点前面和后面可以有数字，例如233.666 numeric = scanUnsignedInteger(s, index) || numeric; } // 如果出现'e'或者'E'，接下来跟着的是数字的指数部分 if(s[index] == 'e' || s[index] == 'E'){ ++index; // 下面一行代码用&&的原因： // 1. 当e或E前面没有数字时，整个字符串不能表示数字，例如.e1、e1； // 2. 当e或E后面没有整数时，整个字符串不能表示数字，例如12e、12e+5.4 numeric = numeric && scanInteger(s ,index); } //字符串结尾有空格，可以返回true while(s[index] == ' ') ++index; cout 58 - II. 左旋转字符串 与189. 轮转数组相同 // nums = \"----->-->\"; n =5 result = \"-->----->\"; // reverse \"----->-->\" we can get \"----->\" (k-n,k) class Solution { public: string reverseLeftWords(string s, int n) { int k=s.size(); reverse(s.begin(),s.end()); reverse(s.begin(),s.begin()+k-n); reverse(s.begin()+k-n,s.end()); return s; } }; 67. 把字符串转换成整数 状态机 class Solution { public: int strToInt(string str) { int border=INT_MAX/10; //1、去除空格 int i=0; while(iborder|| (ans==border && str[j]>'7')) return sign?INT_MIN:INT_MAX; //！！！这里注意先作str[j]-'0' 不然直接加ASCI码出界报错 ans=ans*10+(str[j]-'0'); } } //5、根据符号判断返回值为正数还是负数 return sign?ans*-1:ans; } }; 哈希表 50. 第一个只出现一次的字符 class Solution { public: char firstUniqChar(string s) { unordered_map ma; for(char x:s){ ma[x]++; } for(char x: s){ if(ma[x]==1) return x; } return ' '; } }; 56 - II. 数组中数字出现的次数II 异或？ class Solution { public: int singleNumber(vector& nums) { map ma; for(auto x:nums){ ma[x]++; } for(auto x: ma){ if(x.second==1){ return x.first; } } return -1; } }; 57. 和为s的两个数字 class Solution { public: vector twoSum(vector& nums, int target) { int i=0,j=nums.size()-1; while(itarget){ j--; } else if(nums[i]+nums[j] 位运算 15. 二进制中1的个数 class Solution { public: int hammingWeight(uint32_t n) { int res=0; while(n){ res+=n&1; n=n>>1; } return res; } }; 56 - I. 数组中数字出现的次数I 异或 异为1 同为0 0^0=0，0^1=1 0异或任何数＝任何数 1^0=1，1^1=0 1异或任何数=任何数取反 任何数异或自己＝把自己置0 class Solution { public: vector singleNumbers(vector& nums) { int x = 0, y = 0, n = 0, m = 1; for(int num : nums) // 1. 遍历异或 n ^= num; //n =x^y while((n & m) == 0) // 2. 循环左移，计算 m m {x, y}; // 5. 返回出现一次的数字 } }; 64. 求1+2+…+n 利用逻辑运算符的短路效应和递归。 if(A && B) // 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A && B 为 false if(A || B) // 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true class Solution { public: int res=0; int sumNums(int n) { bool x=n>1 && sumNums(n-1); res+=n; return res; } }; 65. 不用加减乘除做加法 class Solution { public: int add(int a, int b) { //因为不允许用+号，所以求出异或部分和进位部分依然不能用+ 号，所以只能循环到没有进位为止 while(b!=0) { //保存进位值，下次循环用 int c=(unsigned int)(a&b) 图 12. 矩阵中的路径 回溯+dfs class Solution { public: bool exist(vector>& board, string word) { rows = board.size(); cols = board[0].size(); for(int i = 0; i >& board, string word, int i, int j, int k) { if(i >= rows || i = cols || j 13. 机器人的运动范围 动态规划 给定一个问题，把它拆成一个个子问题，直到子问题可以直接解决。然后把子问题答案保存起来，以减少重复计算。再根据子问题答案反推，得出原问题解的一种方法。 10- I. 斐波那契数列 class Solution { public: int fib(int n) { if(n == 0) return 0; vector dp(n+1); dp[0]=0; dp[1]=1; for(int i =2;i 10- II. 青蛙跳台阶问题 n-1个台阶有f(n-1)种跳法，最后还剩一个台阶，最后青蛙只能最后一跳 n-2个台阶有f(n-2)种跳法，最后剩余二个台阶，有两种跳法： ①一次跳两个台阶 ②一次跳一个台阶 但是这种跳法其实已经在n-1个台阶里包含了，所以 f(n)=f(n-1)+f(n-2) class Solution { public: int numWays(int n) { if(n==0) return 1; if(n==1) return 1; vector dp(n+1); dp[0]=1; dp[1]=1; for(int i=2;i 14- I. 剪绳子 // 当所有绳段长度相等时，乘积最大 // 最优的绳段长度为3 // j*(i-j) 两段 dp[j]*(i-j) >2段 class Solution { public: int cuttingRope(int n) { vector dp(n+1); dp[1]=1; for(int i=2;i 14- II. 剪绳子 II 不值得用动态规划做，用数学方法。 // 循环取余 class Solution { public: int cuttingRope(int n) { if(n 39. 数组中出现次数超过一半的数字 跟动态规划没关系 class Solution { public: int majorityElement(vector& nums) { unordered_map hash; int res = 0, len = nums.size(); for(int i = 0; i len/2) res = nums[i]; } return res; } }; 42. 连续子数组的最大和 class Solution { public: int maxSubArray(vector& nums) { int pre=0,maxans=nums[0]; for(auto x: nums){ pre=max(pre+x,x); maxans=max(maxans,pre); } return maxans; } }; 46. 把数字翻译成字符串 class Solution { public: int translateNum(int num) { string src = to_string(num); int len =src.size(); vector dp(len+1); dp[0] =1; dp[1] =1; for(int i = 2; i=\"10\") ? dp[i-1]+dp[i-2]:dp[i-1]; } return dp[len]; } }; 47. 礼物的最大价值 class Solution { public: int maxValue(vector>& grid) { int m=grid.size(); int n=grid[0].size(); vector> dp(m+1,vector(n+1,0)); for(int i=1;i 60. n个骰子的点数 class Solution { public: vector dicesProbability(int n) { vector dp(6, 1.0 / 6.0); for (int i = 2; i tmp(5 * i + 1, 0); for (int j = 0; j 63. 股票的最大利润 class Solution { public: int maxProfit(vector& nums) { if (!nums.size()) return 0; int res = 0; int minValue = nums[0]; for (int i = 1; i 贪心 45. 把数组排成最小的数 // x+y>y+x 则 x “大于” y ； // x+y& nums) { vector strs; for(int i=0;i &strs, int l,int r){ if(l= strs[l]+strs[j] && i 查找 04. 二维数组中的查找 法一：二分查找 class Solution { public: bool findNumberIn2DArray(vector>& matrix, int target) { for (int i = 0; i target) b = mid-1; else a = mid+1; } } return false; } }; 法二： class Solution { public: bool findNumberIn2DArray(vector>& matrix, int target) { int i = matrix.size() - 1, j = 0; while(i >= 0 && j target) i--; else if(matrix[i][j] 53 - I. 在排序数组中查找数字I class Solution { public: int search(vector& nums, int target) { unordered_map ma; for(auto x: nums){ ma[x]++; } auto m=ma.find(target); if(m!=ma.end()){ return m->second; } return 0; } }; 53 - II. 0～n-1中缺失的数 class Solution { public: int missingNumber(vector& nums) { if(nums[0]==1) return 0; for(int i=0;i 双指针 21. 调整数组顺序使奇数位于偶数前面 // 参考快排 // 指针i从左向右寻找偶数； // 指针j从右向左寻找奇数； // 将偶数nums[i]和奇数 nums[j]交换。 class Solution { public: vector exchange(vector& nums) { int i = 0, j = nums.size() - 1; while (i 48. 最长不含重复字符的子字符串 hash+dp class Solution { public: int lengthOfLongestSubstring(string s) { int n = s.size(); if(n==0) return 0; vector dp(n,0);//dp[i] :包含第i个数的最长不重复数量 dp[0]=1; unordered_map map;//下标key为字符，值value为该字符的位置。 比如“ab” 的map为 map[a]=0 map[b]=1 map[s[0]] = 0; for(int i = 1; i hash+ 双指针 57 - II. 和为s的连续正数序列 滑动窗口 class Solution { public: vector> findContinuousSequence(int target) { int i = 1, j = 2, s = 3; vector> res; while(i ans; for(int k = i; k target) { s -= i; i++; } else { j++; s += j; } } return res; } }; 回溯 38. 字符串的排列 ？？？？？？ 数学 17. 打印从1到最大的n位数 class Solution { public: vector printNumbers(int n) { vector res; int i = 1; int maxi = pow(10,n); while(i 43. 1～n 整数中 1 出现的次数 难 44. 数字序列中某一位的数字 找规律题 49. 丑数 61. 扑克牌中的顺子 class Solution { public: bool isStraight(vector& nums) { set repeat; int max = 0, min = 14; for(int num:nums) { if(num == 0) continue; // 跳过大小王 max = max > num?max:num; // 最大牌 max(max, num) min = min 62. 圆圈中最后剩下的数字 约瑟夫环 背 class Solution { public: int lastRemaining(int n, int m) { int x = 0; for (int i = 2; i 其他 03. 数组中重复的数字 class Solution { public: int findRepeatNumber(vector& nums) { unordered_map ma; for(auto x: nums){ if(ma[x]) return x; ma[x]=true; } return -1; } }; class Solution { public: int findRepeatNumber(vector& nums) { int i=0; while(i 05. 替换空格 class Solution { public: string replaceSpace(string s) { int count=0,len=s.size(); for(auto x: s){ if(x==' ') count++; } s.resize(len + 2*count); for(int i=len-1,j=s.size()-1;i 11. 旋转数组的最小数字 class Solution { public: int minArray(vector& nums) { int i=0,j=nums.size()-1; while(i>1; if(nums[j]>nums[m]){ j=m; } else if(nums[j] 16. 数值的整数次方 快速幂？ class Solution { public: double myPow(double x, int n) { bool flag = false; long long N = n; if (N == 0) return 1; if (N 29. 顺时针打印矩阵 class Solution { public: vector spiralOrder(vector>& matrix) { if (matrix.empty()) return {}; vector res; int l = 0; //左边界 int r = matrix[0].size() - 1; //右边界 int t = 0; //上边界 int b = matrix.size() - 1; //下边界 while (true) { //left -> right for (int i = l; i b) break; //top -> bottom for (int i = t; i left for (int i = r; i >= l; i--) res.push_back(matrix[b][i]); if (--b top for (int i = b; i >= t; i--) res.push_back(matrix[i][l]); if (++l > r) break; } return res; } }; 51. 数组中的逆序对 归并排序 66. 构建乘积数组 ？ class Solution { public: vector constructArr(vector& a) { int len = a.size(); if(len == 0) return {}; vector b(len, 1); b[0] = 1; int tmp = 1; for(int i = 1; i = 0; i--) { // 上三角 tmp *= a[i + 1]; b[i] *= tmp; } return b; } }; 树 二叉排序/搜索/查找树 （1）若左子树不空，则左子树上所有结点的值均小于它的根节点的值； （2）若右子树不空，则右子树所有结点的值均大于或等于它的根结点的值； （3）左、右子树也分别为二叉排序树 平衡二叉树 它是一棵空树或它的左右两个子树的高度差（称为平衡因子）不大于1的二叉排序树，并且左右两个子树都是一棵平衡二叉树。 AVL 平衡二叉查找树 红黑树（Red-Black Tree）是一种自平衡的二叉搜索树（Binary Search Tree）。它在每个节点上增加了一个额外的存储位来表示节点的颜色，可以是红色或黑色。通过一些特定的规则和操作，红黑树保持了以下性质： 每个节点要么是红色，要么是黑色。 根节点是黑色的。 每个叶子节点（空节点）是黑色的。 如果一个节点是红色的，那么它的两个子节点都是黑色的。 对于每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数量的黑色节点。 Java 中的 TreeMap，JDK 1.8 中的 HashMap、C++ STL 中的 map 均是基于红黑树结构实现。 Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-08-26 09:31:49 "},"排序算法.html":{"url":"排序算法.html","title":"排序算法","keywords":"","body":"排序算法 1 冒泡排序 void bubblesort(vector &nums) { for (int i = 0; i nums[j + 1]) { swap(nums[j], nums[j + 1]); } } } } 2 选择排序 void selectsort(vector &nums) { for (int i = 0; i 3 插入排序 void insertsort(vector &num) { for (int i = 1; i = 0; j--) { if (num[j] > insert_num) num[j + 1] = num[j]; else break; } num[j + 1] = insert_num; } } 4 快速排序 int partition(vector &arr, int low, int high) { int pivot = arr[high]; int i = (low - 1); for (int j = low; j &arr, int low, int high) { if (low void quicksort(vector &v,int start,int end) {//快速排序 if (start start && v[--heigh] >= base);//从右往左找到数组中第一个比base小的值为止 if (low 5 堆排序 void heapify(vector &nums, int n, int i) { if (i >= n) { return; } int c1 = 2 * i + 1; //子节点 c1 c2 int c2 = 2 * i + 2; int max = i; // 父节点 max if (c1 nums[max]) { max = c1; } if (c2 nums[max]) { max = c2; } if (max != i) { swap(nums[max], nums[i]); heapify(nums, n, max); } } void build_heap(vector &nums, int n) { int last_node = n - 1; int parent = (last_node - 1) / 2; for (int i = parent; i >= 0; --i) { heapify(nums, n, i); } } void heap_sort(vector &nums, int n) { build_heap(nums, n); for (int i = n - 1; i >= 0; i--) { swap(nums[i], nums[0]); heapify(nums, i, 0); } } 6 归并排序 vector merge(vector left, vector right) { vector res; int i = 0, j = 0; while (i mergeSort(vector& arr) { if (arr.size() left(arr.begin(), arr.begin() + mid); vector right(arr.begin() + mid, arr.end()); return merge(mergeSort(left), mergeSort(right)); } #include \"vector\" using namespace std; void print(vector &nums) { for (int i = 0; i num = {3, 1, 5, 8, 6, 2, 0, 9, 4, 7}; print(num); //quicksort(num, 0, 9); //selectsort(num); //bubblesort(num); //insertsort(num); //heap_sort(num, 10); vector b = mergeSort(num); print(b); return 0; } 排序算法 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性 冒泡排序 O(n²) O(n²) O(n) O(1) 稳定 选择排序 O(n²) O(n²) O(n) O(1) 不稳定 插入排序 O(n²) O(n²) O(n) O(1) 稳定 快速排序 O(nlogn) O(n²) O(nlogn) O(nlogn) 不稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 希尔排序 O(nlogn) O(ns) O(n) O(1) 不稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定 计数排序 O(n+k) O(n+k) O(n+k) O(n+k) 稳定 基数排序 O(N*M) O(N*M) O(N*M) O(M) 稳定 一个算法所花费的时间与其中语句的执行次数成正比例，算法中的基本操作的执行次数，为算法的时间复杂度。 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度 。 Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-08-13 16:14:03 "},"WebServer.html":{"url":"WebServer.html","title":"WebServer","keywords":"","body":"WebServer 代码框架 代码架构 ├─ CGImysql // 数据库连接池 │ ├─ sql_connection_pool.cpp │ └─ sql_connection_pool.h ├─ http // 实现HTTP协议连接、销毁 │ ├─ http_conn.cpp │ └─ http_conn.h ├─ lock // 封装互斥锁、信号量等 │ └─ locker.h ├─ log // 日志 阻塞队列 │ ├─ block_queue.h │ ├─ log.cpp │ └─ log.h ├─ main.cpp // 主函数 ├─ makefile ├─ root // 前端 网页 ├─ threadpool // 线程池 │ └─ threadpool.h └─ timer // 定时器 ├─ README.md └─ lst_timer.h 文件描述符 Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。在操作这些所谓的文件的时候，我们每操作一次就找一次名字，这会耗费大量的时间和效率。所以Linux中规定每一个文件对应一个索引，这样要操作文件的时候，直接找到索引就可以对其进行操作了。 文件描述符（file descriptor）就是内核为了高效管理这些已经被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符来实现。同时还规定系统刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。这意味着如果此时去打开一个新的文件，它的文件描述符会是3，再打开一个文件文件描述符就是4...... ls -l /proc/pid/fd // 查看文件描述符 pid是代表的进程号 事件处理模式 Reactor 要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写），若有，则立即通知工作线程，将socket可读可写事件放入请求队列，读写数据、接受新连接及处理客户请求均在工作线程中完成。(需要区别读和写事件) Proactor 主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑 Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑（给予相应的返回url）。如主线程读完成后users[sockfd].read()，选择一个工作线程来处理客户请求pool->append(users + sockfd)。 同步I/O方式模拟出Proactor模式原理：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。 工作流程如下： 1）主线程往epoll内核事件表中注册socket上的读就绪事件。 2）主线程调用epoll_wait等待socket上有数据可读。 3）当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。 4）睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。 5）主线程调用epoll_wait等待socket可写。 6）当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。 threadpool.h threadpool(connection_pool *connPool, int thread_number = 8, int max_request = 10000); ~threadpool(); bool append(T *request); // 向请求队列中插入任务请求 static void *worker(void *arg); // 工作线程运行的函数，它不断从工作队列中取出任务并执行之 void run(); //调用void http_conn::process() int pthread_create (pthread_t *thread_tid, //返回新生成的线程的id const pthread_attr_t *attr, //指向线程属性的指针,通常设置为NULL void * (*start_routine) (void *), //处理线程函数的地址 static函数没有this指针 void *arg); //start_routine()中的参数 所谓线程池，就是一个pthread_t类型的普通数组，通过pthread_create()函数创建m_thread_number个线程，用来执行worker()函数以执行每个请求处理函数（HTTP请求的process函数），通过pthread_detach()将线程设置成脱离态（detached）后，当这一线程运行结束时，它的资源会被系统自动回收，而不再需要在其它线程中对其进行 pthread_join() 操作。 操作工作队列一定要加锁（locker），因为它被所有线程共享。 用信号量来标识请求队列中的请求数，通过m_queuestat.wait();来等待一个请求队列中待处理的HTTP请求，然后交给线程池中的空闲线程来处理。 为什么要使用线程池？ 当你需要限制你应用程序中同时运行的线程数时，线程池非常有用。因为启动一个新线程会带来性能开销，每个线程也会为其堆栈分配一些内存等。为了任务的并发执行，我们可以将这些任务任务传递到线程池，而不是为每个任务动态开启一个新的线程。（空间换时间） 线程池实现 #include #include #include #include #include #include using namespace std; template class threadpool { public: threadpool(int thread_number = 8, int max_request = 10000); ~threadpool(); bool append(T request); private: static void *worker(void *arg); void run(); private: int m_thread_number; // 线程池中的线程数 int m_max_requests; // 请求队列中允许的最大请求数 pthread_t *m_threads; // 描述线程池的数组，其大小为m_thread_number list m_workqueue; // 请求队列 链表实现 pthread_mutex_t m_mutex; // 互斥锁 sem_t m_sem; // 信号量 int sval; // 信号量值 bool m_stop; //是否结束线程 }; template threadpool::threadpool(int thread_number, int max_requests) : m_thread_number(thread_number), m_max_requests(max_requests), m_stop(false), m_threads(NULL) { m_threads = new pthread_t[m_thread_number]; sem_init(&m_sem, 0, 0); pthread_mutex_init(&m_mutex, NULL); for (int i = 0; i threadpool::~threadpool() { delete[] m_threads; m_stop = true; } template bool threadpool::append(T request) { pthread_mutex_lock(&m_mutex); if (m_workqueue.size() > m_max_requests) { pthread_mutex_unlock(&m_mutex); return false; } m_workqueue.push_back(request); pthread_mutex_unlock(&m_mutex); sem_post(&m_sem); // 解锁 +1 sem_getvalue(&m_sem,&sval); cout void *threadpool::worker(void *arg) { threadpool *pool = (threadpool *)arg; pool->run(); } template void threadpool::run() { while (!m_stop) { sem_wait(&m_sem); // 加锁 -1 =0阻塞 pthread_mutex_lock(&m_mutex); if (m_workqueue.empty()) { pthread_mutex_unlock(&m_mutex); continue; } T request = m_workqueue.front(); m_workqueue.pop_front(); sem_getvalue(&m_sem,&sval); cout *pool = NULL; pool = new threadpool; for(int i =1;iappend(i); } sleep(5); //防止子线程没有抢占到CPU且此时主线程已经执行完并退出 } 线程池的设计思路，线程池中线程的数量由什么确定？ 设计思路： 实现线程池有以下几个步骤： （1）设置一个生产者消费者队列，作为临界资源。 （2）初始化n个线程，并让其运行起来，加锁去队列里取任务运行 （3）当任务队列为空时，所有线程阻塞。 （4）当生产者队列来了一个任务后，先对队列加锁，把任务挂到队列上，然后使用条件变量去通知阻塞中的一个线程来处理。 线程池中线程数量： 线程数量和哪些因素有关：CPU，IO、并行、并发 CPU密集型应用，则线程池大小设置为：CPU数目+1 IO密集型应用，则线程池大小设置为：2CPU数目+1 所以线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。 线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors/cores)的数量N：如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程阻塞）；对于IO密集型的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费，公式：最佳线程数 = CPU当前可使用的Cores数 * 当前CPU的利用率 * (1 + CPU等待时间 / CPU处理时间) 为什么要创建线程池： 创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。同时线程池也是为了提升系统效率。 locker.h 封装了信号量、互斥锁、条件变量 sem(); // 信号量 bool wait(); // p操作 -1 bool post(); // v操作 +1 locker(); // 互斥锁 保证同一时刻只能有一个线程去操作 bool lock(); //加锁 bool unlock(); //解锁 cond(); // 条件变量 bool wait(); // 先把调用线程放入条件变量的请求队列，然后将互斥锁解锁，当函数成功返回为0时，表示重新抢到了互斥锁，互斥锁会再次被锁上 bool broadcast(); // 以广播的方式唤醒所有等待目标条件变量的线程 sql_connection_pool.h 数据库连接池 单例模式、list实现连接池、连接池为静态大小、互斥锁实现线程安全 每一个HTTP连接获取一个数据库连接，获取其中的用户账号密码进行对比（有点损耗资源，实际场景下肯定不是这么做的），而后再释放该数据库连接。 http_conn.h HTTP的报文处理流程分为以下三个步骤： 连接处理：浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理。 处理报文请求：工作线程取出任务后，调用process_read函数，通过主、从状态机对请求报文进行解析。 返回响应报文：解析完之后，跳转do_request函数生成响应报文，通过process_write写入buffer，返回给浏览器端。 void http_conn::init(int sockfd, const sockaddr_in &addr); // 外部调用初始化 bool http_conn::read_once(); // 读取数据存储到m_read_buf void http_conn::process(); // 调用process_read()和process_write(read_ret) HTTP_CODE process_read(); // 从m_read_buf读取，并处理请求报文 HTTP_CODE parse_request_line(char *text); // 主状态机解析报文中的请求行数据 获得请求方法，目标url及http版本号 HTTP_CODE parse_headers(char *text); // 主状态机解析报文中的请求头数据 HTTP_CODE parse_content(char *text); // 主状态机解析报文中的请求内容 char *get_line() { return m_read_buf + m_start_line; }; // get_line用于将指针向后偏移，指向未处理的字符 http_conn::LINE_STATUS http_conn::parse_line()// 返回值为行的读取状态，有LINE_OK,LINE_BAD,LINE_OPEN bool process_write(HTTP_CODE ret); // //向m_write_buf写入响应报文数据 有限状态机一种逻辑单元内部的一种高效编程方法，在服务器编程中，服务器可以根据不同状态或者消息类型进行相应的处理逻辑，使得程序逻辑清晰易懂。 通过while循环，对主从状态机进行封装，对报文的每一行进行循环处理。这里的主状态机，指的是process_read()函数，从状态机是指parse_line()函数。 从状态机负责读取报文的一行（并对其中的\\r\\n进行修改为\\0\\0），主状态机负责对该行数据进行解析，主状态机内部调用从状态机，从状态机驱动主状态机。它们之间的关系如下图所示： 主状态机初始状态是CHECK_STATE_REQUESTLINE，而后调用parse_request_line()解析请求行，获得HTTP的请求方法、目标URL以及HTTP版本号，状态变为CHECK_STATE_HEADER。 此时进入循环体之后，调用parse_headers()解析请求头部信息。先要判断是空行还是请求头，空行进一步区分POST还是GET。若是请求头，则更新长短连接状态、host等等。 注：GET和POST请求报文的区别之一是有无消息体部分。 当使用POST请求时，需要进行CHECK_STATE_CONTENT的解析，取出POST消息体中的信息（用户名、密码）。 HTTP报文 HTTP报文分为请求报文和响应报文两种，其中，浏览器端向服务器发送的为请求报文，服务器处理后返回给浏览器端的为响应报文。 HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。 GET和POST是最常见的HTTP请求方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。 GET 请求指定的页面内容，并返回实体主体 GET /favicon.ico HTTP/1.1 Host: 49.232.165.212:9006 Connection: keep-alive User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36 Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8 Referer: http://49.232.165.212:9006/ Accept-Encoding: gzip, deflate Accept-Language: zh,en-US;q=0.9,en;q=0.8,zh-TW;q=0.7,zh-CN;q=0.6 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据包含在请求体中。POST请求可能会导致新的资源的建立或者已有资源的修改。 POST /2CGISQL.cgi HTTP/1.1 Host: 49.232.165.212:9006 Connection: keep-alive Content-Length: 17 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://49.232.165.212:9006 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Referer: http://49.232.165.212:9006/1 Accept-Encoding: gzip, deflate Accept-Language: zh,en-US;q=0.9,en;q=0.8,zh-TW;q=0.7,zh-CN;q=0.6 user=a&password=a 请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本。 请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。 HOST，给出请求资源所在服务器的域名。 User-Agent，HTTP客户端程序的信息，该信息由你发出请求使用的浏览器来定义,并且在每个请求中自动发送等。 Accept，说明用户代理可处理的媒体类型。 Accept-Encoding，说明用户代理支持的内容编码。 Accept-Language，说明用户代理能够处理的自然语言集。 Content-Type，说明实现主体的媒体类型。 Content-Length，说明实现主体的大小。 Connection，连接管理，可以是Keep-Alive或close。 空行，请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。 请求数据也叫主体，可以添加任意的其他数据。 响应报文 HTTP/1.1 200 OK Content-Length:360 Connection:keep-alive 状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为OK。 消息报头，用来说明客户端要使用的一些附加信息。 第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8。 空行，消息报头后面的空行是必须的。 响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。 注册登录 log.h 单例模式 // 懒汉模式 class single{ private: single(){ cout // 饿汉模式 class single{ private: single(){ cout 最常用的设计模式之一，保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。 懒汉模式 即非常懒，不用的时候不去初始化，所以在第一次被使用时才进行初始化（实例的初始化放在getinstance函数内部） 经典的线程安全懒汉模式，使用双检测锁模式（p == NULL检测了两次） 利用局部静态变量实现线程安全懒汉模式 饿汉模式：即迫不及待，在程序运行时立即初始化（实例的初始化放在getinstance函数外部，getinstance函数仅返回该唯一实例的指针）。 日志系统的运行机制 日志文件 局部变量的懒汉模式获取实例 生成日志文件，并判断同步和异步写入方式 同步 判断是否分文件 直接格式化输出内容，将信息写入日志文件 异步 判断是否分文件 格式化输出内容，将内容写入阻塞队列（循环数组、条件变量实现），创建一个写线程，从阻塞队列取出内容写入日志文件 block_queue.h 阻塞队列(循环数组实现队列，STL queue也可以)封装了生产者-消费者模型，push为生产者，pop为消费者。 lst_timer.h 服务器首先创建定时器容器有序链表，然后用统一事件源将（统一事件源是指将信号事件与其他事件一样被处理。）异常事件、读写事件和信号事件统一处理，根据不同事件的对应逻辑使用定时器。 具体的，浏览器与服务器连接时，创建该连接对应的定时器，并将该定时器添加到定时器容器链表上；处理异常事件时，执行定时事件，服务器关闭连接，从链表上移除对应定时器；处理定时信号时，将定时标志设置为true，以便执行定时器处理函数；处理读/写事件时，若某连接上发生读事件或某连接给浏览器发送数据，将对应定时器向后移动，否则，执行定时事件。 压力测试 WebBench首先fork出多个子进程，每个子进程都循环做web访问测试。子进程把访问的结果通过pipe告诉父进程，父进程做最终的统计结果。 QBS是一台服务器每秒能够相应的查询次数 Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-09-07 15:52:06 "},"RPC.html":{"url":"RPC.html","title":"RPC","keywords":"","body":"RPC RPC(Remote Procedure Call Protocol) 远程过程调用，客户端应用可以像调用本地函数一样，直接调用运行在远程服务器上的方法。RPC 的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失本地调用的语义简洁性。 muduo+protoobuf+zookeeper 流程框架 文件框架 rpcheader.proto rpcheader.pb.h/.pb.cc mprpcapplication.h/.cc mprpcconfig.h/.cc rpcprovider.h/.cc mprpccontroller.h/.cc mprpcchannel.h/.cc zookeeperutil.h/.cc logger.h/.cc lockqueue.h MprpcApplication MprpcApplication类负责mprpc框架的一些初始化操作，例如mprpc服务器需要监听的端口号还有所在地址。这些信息由配置文件来载入例如test.conf. 项目初始化的时候，会根据传入的命令行参数信息找到配置文件。如符合规范则找到配置文件会调用MprpcConfig::LoadConfigFile方法来解析加载配置文件。 // mprpc框架基础类 负责框架的一些初始化操作 class MprpcApplication{ public: static void Init(int argc, char **argv); static MprpcApplication& GetInstance(); static MprpcConfig& GetConfig(); private: static MprpcConfig m_config; MprpcApplication(){} MprpcApplication(const MprpcApplication&) = delete; MprpcApplication(MprpcApplication&&) = delete; }; 命令行输入的合法性检测 void MprpcApplication::Init(int argc, char **argv){ if(argc MprpcConfig 用于读取配置文件，需要去掉注释和字符串前后多余的空格，还需检测配置项是否合法。 //rpcserverip rpcserverport zookeeperip zookeeperport //框架读取配置文件类 class MprpcConfig{ public: //负责解析加载配置文件 void LoadConfigFile(const char *config_file); //查询配置项信息 std::string Load(const std::string &key); private: std::unordered_mapm_configMap; //去掉字符串前后的空格 void Trim(std::string &src_buf); }; 测试配置文件加载功能 编写test.conf文件 # rpc节点的ip地址 rpcserverip=127.0.0.1 # rpc节点的port端口号 rpcserverport=8080 # zk的IP地址 zookeeperip=127.0.0.1 # zk的port端口号 zookeeperport=2181 RpcProvider RpcProvider是一个框架专门为发布rpc服务的网络对象类。在服务端会用此类来注册服务，故RpcProvider类需要支持所有服务的发布。因此设计的NotifyService方法的参数必须要是这些服务的基类，也就是google::protobuf::Service。 因为protobuf只是提供了数据的序列化和反序列化还有RPC接口，并没有提供网络传输的相关代码。所以此项目用了muduo库实现网络传输。 同时还需要将服务注册到zookeeper上。 RpcProvider类源码 class RpcProvider{ public: // 这里是框架提供给外部使用的，可以发布RPC方法的接口 void NotifyService(google::protobuf::Service *service); // 启动RPC服务结点，开始提供RPC远程网络调用服务 void Run(); private: // 组合了EventLoop muduo::net::EventLoop m_eventLoop; // 服务类型信息 struct ServiceInfo{ google::protobuf::Service *m_service; // 保存服务对象 std::unordered_map m_methodMap; // 保存服务方法 }; // 存储注册成功的服务对象和其他服务方法的所有信息 std::unordered_map m_serviceMap; // 新的socket连接回调 void OnConnection(const muduo::net::TcpConnectionPtr&); // 已建立连接用户的读写事件回调 void OnMessage(const muduo::net::TcpConnectionPtr&, muduo::net::Buffer*, muduo::Timestamp); // Closure的回调操作，用于序列化RPC的响应和网络发送 void SendRpcResponse(const muduo::net::TcpConnectionPtr&, google::protobuf::Message*); }; NotifyService 利用NotifyService发布服务 从*service获取服务对象的描述信息，此接口由protobuf提供。 从描述信息中获取到服务名字和服务对象service的方法和数量。 遍历service获取服务对象指定的服务方法描述，并将其注册到m_methodMap上，例如FriendServiceRpc/GetFriendsList. 最后将其加入服务对象集合m_serviceMap中。 void RpcProvider::NotifyService(google::protobuf::Service *service){ ServiceInfo service_info; const google::protobuf::ServiceDescriptor *perviceDesc = service->GetDescriptor(); std::string service_name = perviceDesc->name(); int methodCnt = perviceDesc->method_count(); LOG_INFO(\"service_name:%s\", service_name.c_str()); for (int i = 0; i method(i); std::string method_name = pmethodDesc->name(); service_info.m_methodMap.insert({method_name, pmethodDesc}); LOG_INFO(\"method_name:%s\", method_name.c_str()); } service_info.m_service = service; m_serviceMap.insert({service_name, service_info}); } 开启远程服务 从RPC的框架中获取到IP和PORT，创建TCPserver对象 设置muduo库的线程数量 把当前结点要发布的服务注册到zookeeper上，让客户端可以从zookeeper上发现服务 启动网络服务 void RpcProvider::Run(){ std::string ip = MprpcApplication::GetInstance().GetConfig().Load(\"rpcserverip\"); uint16_t port = atoi(MprpcApplication::GetInstance().GetConfig().Load(\"rpcserverport\").c_str()); muduo::net::InetAddress address(ip, port); muduo::net::TcpServer server(&m_eventLoop, address, \"RpcProvider\"); server.setConnectionCallback(std::bind(&RpcProvider::OnConnection, this, std::placeholders::_1)); server.setMessageCallback(std::bind(&RpcProvider::OnMessage, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3)); server.setThreadNum(4); ZkClient zkcli; zkcli.Start(); for(auto &sp : m_serviceMap){ std::string service_path = \"/\" + sp.first; zkcli.Create(service_path.c_str(), nullptr, 0); for(auto &mp : sp.second.m_methodMap){ std::string method_name = service_path + \"/\" + mp.first; char method_path_data[128] = {0}; sprintf(method_path_data, \"%s:%d\", ip.c_str(), port); zkcli.Create(method_name.c_str(), method_path_data, strlen(method_path_data), ZOO_EPHEMERAL); } } LOG_INFO(\"RpcProvider start service at ip::%s port:%d\", ip.c_str(), port); server.start(); m_eventLoop.loop(); } 客户端发起请求服务端接收到 当接收到客户端的请求时。OnMessage回调函数会被调用，可以从客户端发过来的数据得知他想要调用那一个类的那一个方法以及其参数是什么。 为了防止TCP的粘包问题需要在自定义一个协议，本项目采用了将消息分为消息头和消息体，消息头包含此消息的总长度，每次都需要先读消息头，从而得知我们这次发过来的消息要读到那里。 从网络上接收远程的RPC调用请求的字符串。 从字符串中先读取前四个字节的内容，从而得知此次消息的长度。 根据header_size读取数据头的原始字符串，反序列化数据得到RPC请求的详细消息。 获取service对象和method对象。 生成RPC方法调用请求request和相应response参数。 在框架上根据远端的RPC请求调用当前的RPC结点方法。 void RpcProvider::OnMessage(const muduo::net::TcpConnectionPtr& conn, muduo::net::Buffer *buffer, muduo::Timestamp){ std::string recv_buf = buffer->retrieveAllAsString(); uint32_t header_size = 0; recv_buf.copy((char *)&header_size, 4, 0); std::string rpc_header_str = recv_buf.substr(4, header_size); mprpc::RpcHeader rpcHeader; std::string service_name; std::string method_name; uint32_t args_size; if(rpcHeader.ParseFromString(rpc_header_str)){ service_name = rpcHeader.service_name(); method_name = rpcHeader.method_name(); args_size = rpcHeader.args_size(); } else{ LOG_ERR(\"rec_header_str:%sparse error!\", rpc_header_str.c_str()); return; } std::string args_str = recv_buf.substr(4 + header_size, args_size); auto it = m_serviceMap.find(service_name); if(it == m_serviceMap.end()){ LOG_ERR(\"%sis not exist\", service_name.c_str()); return; } auto mit = it->second.m_methodMap.find(method_name); if(mit == it->second.m_methodMap.end()){ LOG_ERR(\"%s:%sis not exist\", service_name.c_str(), method_name.c_str()); return; } google::protobuf::Service *service = it->second.m_service; const google::protobuf::MethodDescriptor *method = mit->second; google::protobuf::Message *request = service->GetRequestPrototype(method).New(); if(!request->ParseFromString(args_str)){ LOG_ERR(\"request parse error! content:%s\", args_str.c_str()); return; } google::protobuf::Message *response = service->GetResponsePrototype(method).New(); // 给下面的method的方法的调用，绑定一个Closure的回调函数 google::protobuf::Closure *done = google::protobuf::NewCallback(this,&RpcProvider::SendRpcResponse, conn, response); service->CallMethod(method, nullptr, request, response, done); } 服务端处理完请求返回数据给客户端 当service->CallMethod执行完毕后，调用通过done绑定的回调函数。将服务器处理后的结果序列化，然后通过muduo网络库发回给客户端。 void RpcProvider::SendRpcResponse(const muduo::net::TcpConnectionPtr& conn, google::protobuf::Message *response){ std::string response_str; if(response->SerializeToString(&response_str)){ conn->send(response_str); } else{ LOG_ERR(\"serialize response_str error!\"); } conn->shutdown(); } MprpcController MprpcContrller模块继承于google::protobuf::RpcController，他声明于service.h文件下，而RpcController是一个抽象类，他的成员都是纯虚函数，需要我们自己重写实现，我们可以通过RpcController的方法得到RPC方法执行过程中的状态和RPC方法执行过程中的错误信息。 class PROTOBUF_EXPORT RpcController { public: inline RpcController() {} virtual ~RpcController(); virtual void Reset() = 0; virtual bool Failed() const = 0; virtual std::string ErrorText() const = 0; virtual void StartCancel() = 0; virtual void SetFailed(const std::string& reason) = 0; virtual bool IsCanceled() const = 0; virtual void NotifyOnCancel(Closure* callback) = 0; private: GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(RpcController); }; RpcController的API 这里只提及本项目涉及到的接口 Reset()可以将RpcController重新设定为初始状态，以便他可以被重用。他不能在RPC进行时调用。 virtual void Reset() = 0; Failed()在一个调用结束以后，如果调用失败则返回ture。失败的原因取决于RPC的实现。Failed()不能在调用结束前被调用。如果返回true则响应消息的内容未被定义。 virtual bool Failed() const = 0; 如果Failed()返回为true此方法则返回一个用户可读的错误描述。 virtual std::string ErrorText() const = 0; StartCancel()通知RPC系统，调用者希望RPC调用取消，RPC系统可以立刻取消，也可以等待一段时间后再取消调用，也可以不取消。如果调用被取消，done回调任然会被调用，RpcController会表明当时的调用失败。 virtual void StartCancel() = 0; MprpcController声明 class MprpcController : public google::protobuf::RpcController{ public: MprpcController(); void Reset(); bool Failed() const; std::string ErrorText() const; void SetFailed(const std::string& reason); // 目前未实现具体的功能 void StartCancel(); bool IsCanceled() const; void NotifyOnCancel(google::protobuf::Closure* callback); private: bool m_failed; // RPC方法执行过程中的状态 std::string m_errText; // RPC方法执行过程中的错误信息 }; MprpcController实现 MprpcController::MprpcController(){ m_failed = false; m_errText = \"\"; } void MprpcController::Reset(){ m_failed = false; m_errText = \"\"; } bool MprpcController::Failed() const{ return m_failed; } std::string MprpcController::ErrorText() const{ return m_errText; } void MprpcController::SetFailed(const std::string& reason){ m_failed = true; m_errText = reason; } // 目前未实现具体的功能 void MprpcController::StartCancel(){} bool MprpcController::IsCanceled() const{return false;} void MprpcController::NotifyOnCancel(google::protobuf::Closure* callback){} MprpcChannel MprpcChannel模块继承于google::protobuf::RpcChannel是一个RPC通道的抽象接口，表示一个到服务的通信线路，这个线路用于客户端远程调用服务端的方法。我们需要继承这个类并重写他的CallMethod方法。 class PROTOBUF_EXPORT RpcChannel { public: inline RpcChannel() {} virtual ~RpcChannel(); virtual void CallMethod(const MethodDescriptor* method, RpcController* controller, const Message* request, Message* response, Closure* done) = 0; private: GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(RpcChannel); }; class MprpcChannel : public google::protobuf::RpcChannel{ public: void CallMethod(const google::protobuf::MethodDescriptor* method, google::protobuf::RpcController* controller, const google::protobuf::Message* request, google::protobuf::Message* response, google::protobuf::Closure* done); }; CallMethod方法 所有通过stub代理对象调用的RPC方法都走到了这里，统一做RPC方法调用的数据序列化和网络发送 获取客户端请求的方法和序列化 从CallMethod的参数method获取service_name和method_name; 将获取到的参数序列化为字符串，并获取他的长度。 定义RPC的请求header. 组织待发送的RPC请求的字符串 const google::protobuf::ServiceDescriptor* sd = method->service(); std::string service_name = sd->name(); std::string method_name = method->name(); uint32_t args_size = 0; std::string args_str; if(request->SerializeToString(&args_str)){ args_size = args_str.size(); } else{ controller->SetFailed(\"serialize request error!\"); return; } mprpc::RpcHeader rpcHeader; rpcHeader.set_service_name(service_name); rpcHeader.set_method_name(method_name); rpcHeader.set_args_size(args_size); uint32_t header_size = 0; std::string rpc_header_str; if(rpcHeader.SerializeToString(&rpc_header_str)){ header_size = rpc_header_str.size(); } else{ controller->SetFailed(\"serialize rpc header error!\"); return; } std::string send_rpc_str; send_rpc_str.insert(0, std::string((char*)&header_size, 4)); send_rpc_str += rpc_header_str; send_rpc_str += args_str; 使用TCP编程完成RPC方法的远程调用 因为CallMethod方法用于客户端远程调用服务端的方法，考虑到这里不需要高并发，故没有使用muduo网络库。 通过 socket 函数在内核中创建一个套接字 RPC调用方法想要调用service_name的method_name服务，需要到zookeeper上查询该服务的所在的host信息。 查询到了mathod_name服务的IP和PORT后，连接RPC服务结点 发送RPC请求 接收RPC请求的响应值 最后反序列化服务器发回来的响应数据 int client_fd = socket(AF_INET, SOCK_STREAM, 0); if(client_fd == -1){ char errtxt[512] = {0}; sprintf(errtxt, \"create socket error! error:%d\", errno); controller->SetFailed(errtxt); return; } ZkClient zkcli; zkcli.Start(); std::string method_path = \"/\" + service_name + \"/\" + method_name; // 127.0.0.1:8080 std::string host_data = zkcli.GetData(method_path.c_str()); if(host_data == \"\"){ controller->SetFailed(method_path + \"is not exist!\"); return; } int idx = host_data.find(\":\"); if(idx == -1){ controller->SetFailed(method_path + \"address is invalid!\"); return; } std::string ip = host_data.substr(0, idx); uint16_t port = atoi(host_data.substr(idx + 1, host_data.size() - idx).c_str()); struct sockaddr_in server_addr; server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port); server_addr.sin_addr.s_addr = inet_addr(ip.c_str()); if(connect(client_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1){ close(client_fd); char errtxt[512] = {0}; sprintf(errtxt, \"connect error! error:%d\", errno); controller->SetFailed(errtxt); return; } if(send(client_fd, send_rpc_str.c_str(), send_rpc_str.size(), 0) == -1){ close(client_fd); char errtxt[512] = {0}; sprintf(errtxt, \"send error! errno:%d\", errno); controller->SetFailed(errtxt); return; } char recv_buf[1024] = {0}; int recv_size = 0; if((recv_size = recv(client_fd, recv_buf, 1024, 0)) == -1){ close(client_fd); char errtxt[512] = {0}; sprintf(errtxt, \"recv error! error:%d\", errno); controller->SetFailed(errtxt); return; } if(!response->ParseFromArray(recv_buf, recv_size)){ close(client_fd); char errtxt[512] = {0}; sprintf(errtxt, \"parse error! response_str%s\", recv_buf); controller->SetFailed(errtxt); return; } close(client_fd); 环境配置与示例 环境配置 muduo Muduo环境配置 Zookeeper下载链接 cd /src/c sudo apt-get install openjdk-8-jdk //安装java sudo ./configure sudo make sudo make install // #include sudo ./configure sudo make sudo make install // #include cmake配置 ln -s /root/cmake-2.8.12.1-Linux-i386/bin/* /usr/bin/ 软连接 cmake unlink ccmake cmake cmake-gui cpack ctest 解除软连接 ln -s /root/cmake-3.0.0-Linux-i386/bin/* /usr/bin/ 重新绑定3.0cmake /usr/local/include /usr/include/ /usr/local/lib/ 示例 chmod 777 autobuild.sh ./autobuild.sh 在zookeeper-3.4.10/bin下启动zookeeper root@iZ0jl7c15vkxg7t9i5hscaZ:~/zip/zookeeper-3.4.10/bin# ./zkServer.sh start //启动服务 ZooKeeper JMX enabled by default Using config: /root/zip/zookeeper-3.4.10/bin/../conf/zoo.cfg Starting zookeeper ... STARTED root@iZ0jl7c15vkxg7t9i5hscaZ:~/zip/zookeeper-3.4.10/bin# ./zkCli.sh //启动客户端 Connecting to localhost:2181 2023-08-20 12:59:17,417 [myid:] - INFO [main:Environment@100] - Client environment:zookeeper.version=3.4.10-39d3a4f269333c922ed3db283be479f9deacaa0f, built on 03/23/2017 10:13 GMT 2023-08-20 12:59:17,420 [myid:] - INFO [main:Environment@100] - Client environment:host.name=iZ0jl7c15vkxg7t9i5hscaZ 2023-08-20 12:59:17,420 [myid:] - INFO [main:Environment@100] - Client environment:java.version=1.8.0_292 2023-08-20 12:59:17,422 [myid:] - INFO [main:Environment@100] - Client environment:java.vendor=Private Build 2023-08-20 12:59:17,422 [myid:] - INFO [main:Environment@100] - Client environment:java.home=/usr/lib/jvm/java-8-openjdk-amd64/jre 2023-08-20 12:59:17,422 [myid:] - INFO [main:Environment@100] - Client environment:java.class.path=/root/zip/zookeeper-3.4.10/bin/../build/classes:/root/zip/zookeeper-3.4.10/bin/../build/lib/*.jar:/root/zip/zookeeper-3.4.10/bin/../lib/slf4j-log4j12-1.6.1.jar:/root/zip/zookeeper-3.4.10/bin/../lib/slf4j-api-1.6.1.jar:/root/zip/zookeeper-3.4.10/bin/../lib/netty-3.10.5.Final.jar:/root/zip/zookeeper-3.4.10/bin/../lib/log4j-1.2.16.jar:/root/zip/zookeeper-3.4.10/bin/../lib/jline-0.9.94.jar:/root/zip/zookeeper-3.4.10/bin/../zookeeper-3.4.10.jar:/root/zip/zookeeper-3.4.10/bin/../src/java/lib/*.jar:/root/zip/zookeeper-3.4.10/bin/../conf: 2023-08-20 12:59:17,422 [myid:] - INFO [main:Environment@100] - Client environment:java.library.path=/usr/java/packages/lib/amd64:/usr/lib/x86_64-linux-gnu/jni:/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:/usr/lib/jni:/lib:/usr/lib 2023-08-20 12:59:17,422 [myid:] - INFO [main:Environment@100] - Client environment:java.io.tmpdir=/tmp 2023-08-20 12:59:17,422 [myid:] - INFO [main:Environment@100] - Client environment:java.compiler= 2023-08-20 12:59:17,422 [myid:] - INFO [main:Environment@100] - Client environment:os.name=Linux 2023-08-20 12:59:17,422 [myid:] - INFO [main:Environment@100] - Client environment:os.arch=amd64 2023-08-20 12:59:17,422 [myid:] - INFO [main:Environment@100] - Client environment:os.version=4.4.0-210-generic 2023-08-20 12:59:17,422 [myid:] - INFO [main:Environment@100] - Client environment:user.name=root 2023-08-20 12:59:17,422 [myid:] - INFO [main:Environment@100] - Client environment:user.home=/root 2023-08-20 12:59:17,423 [myid:] - INFO [main:Environment@100] - Client environment:user.dir=/root/zip/zookeeper-3.4.10/bin 2023-08-20 12:59:17,423 [myid:] - INFO [main:ZooKeeper@438] - Initiating client connection, connectString=localhost:2181 sessionTimeout=30000 watcher=org.apache.zookeeper.ZooKeeperMain$MyWatcher@69d0a921 2023-08-20 12:59:17,438 [myid:] - INFO [main-SendThread(localhost:2181):ClientCnxn$SendThread@1032] - Opening socket connection to server localhost/0:0:0:0:0:0:0:1:2181. Will not attempt to authenticate using SASL (unknown error) Welcome to ZooKeeper! JLine support is enabled 2023-08-20 12:59:17,504 [myid:] - INFO [main-SendThread(localhost:2181):ClientCnxn$SendThread@876] - Socket connection established to localhost/0:0:0:0:0:0:0:1:2181, initiating session [zk: localhost:2181(CONNECTING) 0] 2023-08-20 12:59:17,519 [myid:] - INFO [main-SendThread(localhost:2181):ClientCnxn$SendThread@1299] - Session establishment complete on server localhost/0:0:0:0:0:0:0:1:2181, sessionid = 0x18a114fb21c0000, negotiated timeout = 30000 WATCHER:: WatchedEvent state:SyncConnected type:None path:null [zk: localhost:2181(CONNECTED) 2] ls /FiendServiceRpc/GetFriendsList [] 启动服务端 root@iZ0jl7c15vkxg7t9i5hscaZ:~/mprpc/bin# ./provider -i test.conf 2023-08-20 13:00:37,470:25849(0x7fc3f0cd4a00):ZOO_INFO@log_env@726: Client environment:zookeeper.version=zookeeper C client 3.4.10 2023-08-20 13:00:37,470:25849(0x7fc3f0cd4a00):ZOO_INFO@log_env@730: Client environment:host.name=iZ0jl7c15vkxg7t9i5hscaZ 2023-08-20 13:00:37,470:25849(0x7fc3f0cd4a00):ZOO_INFO@log_env@737: Client environment:os.name=Linux 2023-08-20 13:00:37,470:25849(0x7fc3f0cd4a00):ZOO_INFO@log_env@738: Client environment:os.arch=4.4.0-210-generic 2023-08-20 13:00:37,470:25849(0x7fc3f0cd4a00):ZOO_INFO@log_env@739: Client environment:os.version=#242-Ubuntu SMP Fri Apr 16 09:57:56 UTC 2021 2023-08-20 13:00:37,470:25849(0x7fc3f0cd4a00):ZOO_INFO@log_env@747: Client environment:user.name=root 2023-08-20 13:00:37,470:25849(0x7fc3f0cd4a00):ZOO_INFO@log_env@755: Client environment:user.home=/root 2023-08-20 13:00:37,470:25849(0x7fc3f0cd4a00):ZOO_INFO@log_env@767: Client environment:user.dir=/root/mprpc/bin 2023-08-20 13:00:37,470:25849(0x7fc3f0cd4a00):ZOO_INFO@zookeeper_init@800: Initiating client connection, host=127.0.0.1:2181 sessionTimeout=30000 watcher=0x43a680 sessionId=0 sessionPasswd= context=(nil) flags=0 2023-08-20 13:00:37,470:25849(0x7fc3ee318700):ZOO_INFO@check_events@1728: initiated connection to server [127.0.0.1:2181] 2023-08-20 13:00:37,474:25849(0x7fc3ee318700):ZOO_INFO@check_events@1775: session establishment complete on server [127.0.0.1:2181], sessionId=0x18a114fb21c0002, negotiated timeout=30000 zookeeper_init success! znode create success... path:/FiendServiceRpc/GetFriendsList RpcProvider start service at ip:127.0.0.1 port:8000 20230820 05:02:06.765811Z 25849 INFO TcpServer::newConnection [RpcProvider] - new connection [RpcProvider-127.0.0.1:8000#1] from 127.0.0.1:35490 - TcpServer.cc:80 ============================================ header_size: 35 rpc_header_str: FiendServiceRpcGetFriendsList service_name: FiendServiceRpc method_name: GetFriendsList args_str:� ============================================ do GetFriendsList service! userid:1000 20230820 05:02:06.766073Z 25849 INFO TcpServer::removeConnectionInLoop [RpcProvider] - connection RpcProvider-127.0.0.1:8000#1 - TcpServer.cc:109 启动客户端 root@iZ0jl7c15vkxg7t9i5hscaZ:~/mprpc/bin# ./consumer -i test.conf ============================================ header_size: 35 rpc_header_str: FiendServiceRpcGetFriendsList service_name: FiendServiceRpc method_name: GetFriendsList args_str:� ============================================ 2023-08-20 13:02:06,761:25861(0x7f18ef302740):ZOO_INFO@log_env@726: Client environment:zookeeper.version=zookeeper C client 3.4.10 2023-08-20 13:02:06,761:25861(0x7f18ef302740):ZOO_INFO@log_env@730: Client environment:host.name=iZ0jl7c15vkxg7t9i5hscaZ 2023-08-20 13:02:06,761:25861(0x7f18ef302740):ZOO_INFO@log_env@737: Client environment:os.name=Linux 2023-08-20 13:02:06,761:25861(0x7f18ef302740):ZOO_INFO@log_env@738: Client environment:os.arch=4.4.0-210-generic 2023-08-20 13:02:06,761:25861(0x7f18ef302740):ZOO_INFO@log_env@739: Client environment:os.version=#242-Ubuntu SMP Fri Apr 16 09:57:56 UTC 2021 2023-08-20 13:02:06,762:25861(0x7f18ef302740):ZOO_INFO@log_env@747: Client environment:user.name=root 2023-08-20 13:02:06,762:25861(0x7f18ef302740):ZOO_INFO@log_env@755: Client environment:user.home=/root 2023-08-20 13:02:06,762:25861(0x7f18ef302740):ZOO_INFO@log_env@767: Client environment:user.dir=/root/mprpc/bin 2023-08-20 13:02:06,762:25861(0x7f18ef302740):ZOO_INFO@zookeeper_init@800: Initiating client connection, host=127.0.0.1:2181 sessionTimeout=30000 watcher=0x417b00 sessionId=0 sessionPasswd= context=(nil) flags=0 2023-08-20 13:02:06,762:25861(0x7f18ed147700):ZOO_INFO@check_events@1728: initiated connection to server [127.0.0.1:2181] 2023-08-20 13:02:06,764:25861(0x7f18ed147700):ZOO_INFO@check_events@1775: session establishment complete on server [127.0.0.1:2181], sessionId=0x18a114fb21c0003, negotiated timeout=30000 zookeeper_init success! 2023-08-20 13:02:06,766:25861(0x7f18ef302740):ZOO_INFO@zookeeper_close@2527: Closing zookeeper sessionId=0x18a114fb21c0003 to [127.0.0.1:2181] rpc GetFriendsList response success! index:1 name:gao yang index:2 name:liu hong index:3 name:wang shuo protobuf 官方文档 Protobuf(Protocol Buffers)，是Google公司开发的一种跨语言和平台的序列化数据结构的方式，是一个灵活的、高效的用于序列化数据的协议。与XML和JSON格式相比，protobuf更小、更快、更便捷。protobuf是跨语言的，并且自带一个编译器(protoc)，只需要用protoc进行编译，就可以编译成Java、Python、C++、C#、Go等多种语言代码，然后可以直接使用，不需要再写其它代码，自带有解析的代码。只需要将要被序列化的结构化数据定义一次(在.proto文件定义)，便可以使用特别生成的源代码(使用protobuf提供的生成工具)轻松的使用不同的数据流完成对结构数据的读写操作。甚至可以更新.proto文件中对数据结构的定义而不会破坏依赖旧格式编译出来的程序。 优点： 性能好，效率高 序列化后字节占用空间比XML少3-10倍，序列化的时间效率比XML快20-100倍。 有代码生成机制 将对结构化数据的操作封装成一个类，便于使用。 支持向后和向前兼容 当客户端和服务器同时使用一块协议的时候， 当客户端在协议中增加一个字节，并不会影响客户端的使用 支持多种编程语言Protobuf目前已经支持Java，C++，Python、Go、Ruby等多种语言。 缺点： 二进制格式导致可读性差 1.创建.proto文件，定义数据结构，格式如下： message xxx { // 字段规则：required -> 字段只能也必须出现 1 次 // 字段规则：optional -> 字段可出现 0 次或1次 // 字段规则：repeated -> 字段可出现任意多次（包括 0） // 类型：int32、int64、sint32、sint64、string、32-bit .... // 字段编号：0 ~ 536870911（除去 19000 到 19999 之间的数字） 字段规则 类型 名称 = 字段编号; } 2.protoc编译.proto文件生成xxx.pb.h，xxx.pb.cpp // $SRC_DIR: .proto 所在的源目录 // --cpp_out: 生成 c++ 代码 // $DST_DIR: 生成代码的目标目录 // xxx.proto: 要针对哪个 proto 文件生成接口代码 protoc -I=$SRC_DIR --cpp_out=$DST_DIR $SRC_DIR/xxx.proto protoc ./xxx.proto --cpp_out=./ 3.调用接口 #include #include #include \"test.pb.h\" #include \"google/protobuf/io/zero_copy_stream_impl.h\" #include \"google/protobuf/text_format.h\" //g++ -g -o test test.cpp ./test.pb.cc -I. -lprotobuf -pthread -std=c++11 using namespace test; int main(){ User p; p.set_name(\"yangzejin\"); p.set_id(\"0507\"); //------------------将pb二进制信息保存到字符串 std::string str; p.SerializeToString(&str); std::cout 删除protobuf which protoc # protoc: /usr/bin/protoc rm -rf /usr/bin/protoc # protoc: /usr/bin/protoc sudo rm -rf /usr/include/google/protobuf #头文件 sudo rm -rf /usr/local/include/google/protobuf #头文件 sudo rm -rf /usr/lib/libproto* #库文件 sudo rm -rf /usr/local/lib/libproto* # 库文件 zookeeper ZooKeeper是一个分布式的应用程序协调服务，我们client在调用RPC框架服务的时候需要一个服务配置中心来记录那个服务器提供了那个服务，通俗些讲就是client需要知道他想要远程调用的服务被放在了哪一台服务器上他的IP:PORT是什么，所以我们需要一个中间件ZooKeeper来告诉client他想要调用的服务在哪。 ZooKeeper提供了什么 正如上文所说，zookeeper为我们提供文件系统和通知机制 文件系统 zookeeper提供了一个多层级的命名空间（结点znode）。与文件系统不同的是，这些结点都可以设置一个关联的数据，而文件系统只有叶子结点可以存放数据目录结点则不行。zookeeper为了保持高吞吐了低延迟，在内存中维护了这个树状的树形结构。这种特质的原因使得zookeeper每个结点只能存储1MB的数据。 通知机制 client端会对某一个znode建立一个watcher事件，当znode发生变化时，client会接收到zk发过来的通知，从而根据znode的变化做出业务上的改变。 结点类型 zookeeper节点类型可以分为持久节点（PERSISTENT）、临时节点（EPHEMERAL）和顺序节点（SEQUENTIAL）三大类，而本项目只会用到前两类。 持久节点（PERSISTENT） 所谓持久性结点就是指该数据节点被创建了之后，会一直保留在zookeeper服务器上，直到有删除操作来主动清除这个节点。例如项目中的service_name也就是/FriendServiceRpc就会被注册为持久结点，这里即使RPC结点超时未发送心跳，zk也不会删除这个结点。（心跳概念见下文） 临时节点（EPHEMERAL） 和持久性节点不同的是，临时结点的生命周期和客户端的会话绑定在一起的。因此只要客户端会话失效，那么这个节点就会被自动清理掉。注意，这里提到的是客户端会话失效，而非TCP连接断开。同时zookeeper规定了不能在临时结点上创建子结点，即临时结点只能作为叶子结点。我们这里做一个测试。 通过自述文件的方法启动zookeeper。（这里不做演示） 启动provider发布服务到zk上，这里能看到我们已经发布成功了。 ubuntu% ./provider -i test.conf rpcserverip:127.0.0.1 rpcserverport:8080 zookeeperip:127.0.0.1 zookeeperport:2181 2023-04-23 00:00:22,262:4806(0x7f7333731a00):ZOO_INFO@log_env@726: Client environment:zookeeper.version=zookeeper C client 3.4.10 2023-04-23 00:00:22,262:4806(0x7f7333731a00):ZOO_INFO@log_env@730: Client environment:host.name=ubuntu 2023-04-23 00:00:22,262:4806(0x7f7333731a00):ZOO_INFO@log_env@737: Client environment:os.name=Linux 2023-04-23 00:00:22,262:4806(0x7f7333731a00):ZOO_INFO@log_env@738: Client environment:os.arch=5.4.0-146-generic 2023-04-23 00:00:22,262:4806(0x7f7333731a00):ZOO_INFO@log_env@739: Client environment:os.version=#163~18.04.1-Ubuntu SMP Mon Mar 20 15:02:59 UTC 2023 2023-04-23 00:00:22,263:4806(0x7f7333731a00):ZOO_INFO@log_env@747: Client environment:user.name=zixuanhuang 2023-04-23 00:00:22,263:4806(0x7f7333731a00):ZOO_INFO@log_env@755: Client environment:user.home=/home/zixuanhuang 2023-04-23 00:00:22,263:4806(0x7f7333731a00):ZOO_INFO@log_env@767: Client environment:user.dir=/home/zixuanhuang/mprpc/bin 2023-04-23 00:00:22,263:4806(0x7f7333731a00):ZOO_INFO@zookeeper_init@800: Initiating client connection, host=127.0.0.1:2181 sessionTimeout=30000 watcher=0x55c06a84ef18 sessionId=0 sessionPasswd= context=(nil) flags=0 2023-04-23 00:00:22,263:4806(0x7f7330ecf700):ZOO_INFO@check_events@1728: initiated connection to server [127.0.0.1:2181] 2023-04-23 00:00:22,266:4806(0x7f7330ecf700):ZOO_INFO@check_events@1775: session establishment complete on server [127.0.0.1:2181], sessionId=0x1879d16838c0045, negotiated timeout=30000 zookeeper_init sucess! znode create success... path:/FriendServiceRpc znode create success... path:/FriendServiceRpc/GetFriendsList 回到zkcli.sh查看是否注册了这个节点，可以看到已经注册成功了。 [zk: localhost:2181(CONNECTED) 6] ls / [zookeeper, FriendServiceRpc] [zk: localhost:2181(CONNECTED) 7] ls /FriendServiceRpc/GetFriendsList [] [zk: localhost:2181(CONNECTED) 8] 这个时候我们将provider的会话关掉，可以看到/FriendServiceRpc目录下已经为空。 provider: ^C ubuntu% zkcli.sh: [zk: localhost:2181(CONNECTED) 8] ls / [zookeeper, FriendServiceRpc] [zk: localhost:2181(CONNECTED) 9] ls /FriendServiceRpc [] 心跳消息 client和ZooKeeper之间通信，需要创建一个Session，这个Session会有一个超时时间，因为Zookeeper集群会把Client的Session信息持久化，所以在Session没超时之前，client与Zookeeper server的连接可以在各个Zookeeper server之间透明地移动。在实际的应用中，如果client与server之间的通信足够频繁，Session的维护就不需要其他额外的消息了。否则，ZooKeeper client每t/3ms就需要发一次心跳给Service，如果超过了t的事件Service还没有接收到client发过来的心跳消息，那么ZooKeeper Service就会认为这个client失效了，从而注销掉他的服务。 远程zkClient API存在的问题 设置监听watcher只能是一次性的，每次触发后需要重复设置 .znode节点只存储简单的byte字节数组，如果存储对象，需要自己转换对象生成字节数组 项目应用 Roc_provider中注册到了unordered_map中，这里需要连接ZkClient，注册到ZooKeeper中。这里需要创建指定的路径和数据。 路径为：/FriendServiceRpc/GetFriendList 数据为：127.0.0.1:2181 对于提供RPC服务端，在RpcProvider的Run()方法做以下修改 ZkClient zkcli; zkcli.Start(); for(auto &sp : m_serviceMap){ std::string service_path = \"/\" + sp.first; zkcli.Create(service_path.c_str(), nullptr, 0); for(auto &mp : sp.second.m_methodMap){ std::string method_name = service_path + \"/\" + mp.first; char method_path_data[128] = {0}; sprintf(method_path_data, \"%s:%d\", ip.c_str(), port); zkcli.Create(method_name.c_str(), method_path_data, strlen(method_path_data), ZOO_EPHEMERAL); } } 对于调用RPC方法的客户端，在MprpcChannel的CallMethod方法做以下修改 ZkClient zkcli; zkcli.Start(); std::string method_path = \"/\" + service_name + \"/\" + method_name; std::string host_data = zkcli.GetData(method_path.c_str()); if(host_data == \"\"){ controller->SetFailed(method_path + \"is not exist!\"); return; } int idx = host_data.find(\":\"); if(idx == -1){ controller->SetFailed(method_path + \"address is invalid!\"); return; } std::string ip = host_data.substr(0, idx); uint16_t port = atoi(host_data.substr(idx + 1, host_data.size() - idx).c_str()); Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-09-03 09:42:15 "},"GPT.html":{"url":"GPT.html","title":"搭建自己的GPT","keywords":"","body":"搭建GPT 快捷指令 获取免费的GPT3 API 部署教程 https://github.com/Yidadaa/ChatGPT-Next-Web/ 示例：https://gpt.yangzejin.com/ Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-08-19 13:34:38 "},"服务器防止暴力破解.html":{"url":"服务器防止暴力破解.html","title":"服务器防止暴力破解","keywords":"","body":"服务器防暴力破解 最近服务器一直被人暴力破解... lastb命令会显示最近错误登录的日志，包括通过ssh服务错误登录的日志。 没办法，只能修改登陆端口了。 1.先查看服务器端口范围 [root@iZ2zei0fg2v7x4egtl0wllZ /]# sysctl -a|grep ip_local_port_range sysctl: reading key \"net.ipv6.conf.all.stable_secret\" sysctl: reading key \"net.ipv6.conf.default.stable_secret\" sysctl: reading key \"net.ipv6.conf.eth0.stable_secret\" sysctl: reading key \"net.ipv6.conf.lo.stable_secret\" net.ipv4.ip_local_port_range = 32768 60999 ssh端口范围在(32768~60999)之间就可以 ，也可以用netstat -lnp|grep 10086查看端口是否被占用 2.修改配置文件 vim /etc/ssh/sshd_config找到#Port 22修改成 Port 22 Port 10086 3.重启服务 systemctl restart sshd.service，查看sshd状态systemctl status sshd.service 4.如果可以用新端口连接，把默认22端口禁用。 vim /etc/ssh/sshd_config在Port 22前加上# ps:阿里云服务器需要在控制台添加安全组规则即可。 Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-08-23 21:25:53 "},"Vultr配置Shadowsocks.html":{"url":"Vultr配置Shadowsocks.html","title":"Vultr配置Shadowsocks","keywords":"","body":"首先在Vultr上购买vps，推荐NewYork 3.5美金/月,你也可以在这个网站测试本地到Vultr各个区域的延迟 https://ping.gaomeluo.com/vultr/ 。 接下来用putty连接服务器，搭建Shdowsocks。 安装python和shadowsocks $ yum install m2crypto python-setuptools $ easy_install pip $ pip install shadowsocks 配置文件 $ vi /etc/shadowsocks.json { \"server\":\"0.0.0.0\", \"server_port\":8989, \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"password\":\"yourpwd\", \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\": false } server_port可自定义，password是你登陆shadowsocks的密码，最后:wq退出保存即可。 配置防火墙 # 安装防火墙 $ yum install firewalld # 启动防火墙 $ systemctl start firewalld Vultr上的vps防火墙已经安装完了，这步可以省略。 下一步开放防火墙对应的端口 # 端口是上面server_port设置的端口 $ firewall-cmd --permanent --zone=public --add-port=8989/tcp #重启防火墙 $ firewall-cmd --reload 启动Shaodwsocks ssserver -c /etc/shadowsocks.json -d start #启动 ssserver -c /etc/shadowsocks.json -d stop #停止 ssserver -c /etc/shadowsocks.json -d restart #重启 最后用Shadowsocks客户端连接即可 看油管1080p速度还是很快的。 多用户和aes-256-gcm加密配置 #多用户配置 { \"server\":\"0.0.0.0\", \"local_address\":\"127.0.0.1\", \"local_port\":1080, \"port_password\":{ \"8990\":\"pwd1\", \"8989\":\"pwd2\" }, \"timeout\":300, \"method\":\"aes-256-gcm\", \"fast_open\": false } aes-256-gcm配置 #更新shadowsocks版本，之前的版本不支持aes-256-gcm pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -U 安装libsodium #先安装GCC yum -y groupinstall \"Development Tools\" #下载libsodium wget https://download.libsodium.org/libsodium/releases/LATEST.tar.gz #解压，cd进入解压目录下 tar xf LATEST.tar.gz && libsodium #编译 ./configure && make -j4 && make install echo /usr/local/lib > /etc/ld.so.conf.d/usr_local_lib.conf ldconfig Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-08-24 08:47:08 "}}