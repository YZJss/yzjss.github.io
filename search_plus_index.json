{"./":{"url":"./","title":"简介","keywords":"","body":"个人博客 好记性不如寄笔记！ Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-05-18 20:24:02 "},"C++1.html":{"url":"C++1.html","title":"C++ (1)","keywords":"","body":" C++语言的特点 C++如何选择类型？ include头文件双引号\"\"和尖括号<>的区别 结构体和共用体的区别 简述C++有几种传值方式，之间的区别是什么？ 全局变量和局部变量的区别 请说说原码、反码、补码 数组和指针的区别 引用和指针的区别 数组指针与指针数组的区别 指针函数与函数指针的区别 内存分布模型 堆和栈的区别 什么是野指针 如何避免野指针 请你说说内存泄露 请你说说malloc内存管理原理 new和malloc的区别和实现原理 使用指针需要注意什么？ 初始化为0的全局变量在bss还是data 动态链接与静态链接两者有什么区别？ 导入C函数的关键字是什么，C++编译时和C有什么不同？ 为什么要少使用宏？C++有什么解决方案？ 请你说说内联函数，为什么使用内联函数？需要注意什么？ 内联函数和函数的区别，内联函数的作用。 什么是字节对齐？为什么要字节对齐？ 如何看类型声明？ const的作用 static的作用 1.静态局部变量 2.静态全局变量和静态函数 3.静态成员变量 4.静态成员函数 为什么静态成员变量不能在类内初始化 为什么静态成员函数不能访问非静态成员 静态成员函数与普通成员函数的区别 volatile和mutable 左值和右值 右值引用的作用 移动语义的原理 面对对象和面对过程的区别？ 类的访问权限有几种 继承类型和访问属性 拷贝构造函数的参数类型为什么必须是引用 什么是友元函数 初始化列表的使用场景 深拷贝与浅拷贝的区别 什么是this指针 C++中 struct 和 class 的区别 C++结构体和C结构体的区别 析构函数必须为虚函数吗？构造函数可以为虚函数吗？ 当类存在继承的情况下，需要注意什么？ 构造与析构的顺序 说说你对多态的理解 重载和重写的区别 虚函数的工作机制 虚函数表在什么时候创建？每个对象都有一份虚函数表吗？ 纯虚函数什么情况下使用？ 空类大小？ 为什么要使用操作符重载？ 哪些操作符不能重载？ 智能指针 unique_ptr shared_ptr weak_ptr shared_ptr会不会出现内存泄露？怎么解决？ decltype 类型指示符 #ifdef ifndef #endif ifdef 当且仅当变量已定义时为真，#ifndef 当且仅当变量未定义时为真，一旦检查结果为真，则执行后续操作直至遇到#endif为止。 命名空间的using声明 assert预处理宏 explicit enum strcpy和memcpy C语言和C++的区别 C语言是C++的子集，C++可以很好兼容C语言。但是C++又有很多新特性，如引用、智能指针、auto变量等。 C++是面向对象的编程语言，C++引入了新的数据类型——类，由此引申出了三大特性：（1）封装。（2）继承。（3）多态。而C语言则是面向过程的编程语言。 C语言有一些不安全的语言特性，如指针使用的潜在危险、强制转换的不确定性、内存泄露等。而C++对此增加了不少新特性来改善安全性，如const常量、引用、cast转换、智能指针、try—catch等等； C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL（Standard Template Library）。STL的一个重要特点是数据结构和算法的分离，其体现了泛型化程序设计的思想。C++的STL库相对于C语言的函数库更灵活、更通用。 C++语言的特点 C++在C语言基础上引入了面向对象的机制，同时也兼容C语言。 C++有三大特性（1）封装。（2）继承。（3）多态； C++语言编写出的程序结构清晰、易于扩充，程序可读性好。 C++生成的代码质量高，运行效率高，仅比汇编语言慢10%～20%； C++更加安全，增加了const常量、引用、四类cast转换（static_cast、dynamic_cast、const_cast、reinterpret_cast）、智能指针、try—catch等等； C++可复用性高，C++引入了模板的概念，后面在此基础上，实现了方便开发的标准模板库STL（Standard Template Library）。 同时，C++是不断在发展的语言。C++后续版本更是发展了不少新特性，如C++11中引入了nullptr、auto变量、Lambda匿名函数、右值引用、智能指针。 C++如何选择类型？ 1.超过int 选择long long 2.算术表达式不要使用 char bool 3.执行浮点数运算选择double 以0开头为八进制，0x为十六进制 切勿混用带符号signed类型和无符号unsigned类型！！！例： int main(){ int a = -1; unsigned int b = 1; cout include头文件双引号\"\"和尖括号<>的区别 区别： （1）尖括号<>的头文件是系统文件，双引号\"\"的头文件是自定义文件。 （2）编译器预处理阶段查找头文件的路径不一样。 查找路径： （1）使用尖括号<>的头文件的查找路径：编译器设置的头文件路径-->系统变量。 （2）使用双引号\"\"的头文件的查找路径：当前头文件目录-->编译器设置的头文件路径-->系统变量。 结构体和共用体的区别 struct和union都是由多个不同的数据类型成员组成。 struct的所有成员都存在；但在任何同一时刻, union中只存放了一个被选中的成员，共用体是共用内存空间，所以每个成员都是读写同一个内存空间，那么内存空间里面的内容不停的被覆盖，而同一时刻，都只能操作一个成员变量。否则会出现读错误。 在不考虑字节对齐的情况下，struct变量的总长度等于所有成员长度之和。Union变量的长度等于最长的成员的长度。 struct的不同成员赋值是互不影响的；而对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了。 简述C++有几种传值方式，之间的区别是什么？ 值传递：形参即使在函数体内值发生变化，也不会影响实参的值；在函数传参的过程中，函数会为形参申请新的内存空间，并将实参的值复制给形参。形参的改变当然不会影响实参的值。 引用传递：形参在函数体内值发生变化，会影响实参的值； 指针传递：在指针指向没有发生改变的前提下，形参在函数体内值发生变化，会影响实参的值； 全局变量和局部变量的区别 作用域不同：全局变量的作用域为整个程序，而局部变量的作用域为当前函数或循环等 内存存储方式不同：全局变量存储在全局数据区中，局部变量存储在栈区 生命期不同：全局变量的生命期和主程序一样，随程序的销毁而销毁，局部变量在函数内部或循环内部，随函数的退出或循环退出就不存在了 使用方式不同：全局变量在声明后程序的各个部分都可以用到，但是局部变量只能在局部使用。函数内部会优先使用局部变量再使用全局变量。 当局部变量被定义时，系统不会对其初始化，必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值： 数据类型 初始化默认值 int 0 char '\\0' float 0 double 0 pointer NULL 请说说原码、反码、补码 整型数值在计算机的存储里，最左边的一位代表符号位，0代表正数，1代表负数。 （1）原码：为二进制的数，如：10 原码为0000 1010 （2）反码：正数的反码与原码相同：如：10 原码为0000 1010，反码为0000 1010 负数为原码0变1，1变0，（符号位不变）：如：-10 原码为1000 1010，反码为1111 0101 （3）补码：正数的补码与原码相同：如：10 原码为0000 1010，补码为0000 1010 负数的补码为反码加1：如：-10 反码为1111 0101，补码为1111 0110 数组和指针的区别 概念： （1）数组：数组是用于储存多个相同类型数据的集合。 数组名是首元素的地址。 （2）指针：指针相当于一个变量，但是它和普通变量不一样，它存放的是其它变量在内存中的地址。指针名指向了内存的首地址。 区别： （1）赋值：同类型指针变量可以相互赋值；数组不行，只能一个一个元素的赋值或拷贝 （2）存储方式： 数组：数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的，数组的存储空间，不是在静态区就是在栈上。 指针：指针本身就是一个变量，作为局部变量时存储在栈上。 （3）求sizeof： 数组所占存储空间的内存大小：sizeof（数组名）/sizeof（数据类型） 在32位平台下，无论指针的类型是什么，sizeof（指针名）都是4，在64位平台下，无论指针的类型是什么，sizeof（指针名）都是8。 引用和指针的区别 （1）指针是实体，占用内存空间；引用是别名，与变量共享内存空间。 （2）指针不用初始化或初始化为NULL；引用定义时必须初始化。 （3）指针中途可以修改指向；引用不可以。 （4）指针可以为NULL；引用不能为空。 （5）sizeof(指针)计算的是指针本身的大小；而sizeof(引用)计算的是它引用的对象的大小。 （6）如果返回的是动态分配的内存或对象，必须使用指针，使用引用会产生内存泄漏。 （7）指针使用时需要解引用；引用使用时不需要解引用‘*’。 （8）有二级指针；没有二级引用。 数组指针与指针数组的区别 数组指针是一个指针变量，指向了一个一维数组， 如int (*p)[4]，(*p)[4]就成了一个二维数组，p也称行指针；指针数组是一个数组，只不过数组的元素存储的是指针变量, 如int *p[4]。 指针函数与函数指针的区别 （1）定义不同 指针函数本质是一个函数，其返回值为指针。 函数指针本质是一个指针，其指向一个函数。 （2）写法不同 指针函数：int *fun(int x,int y); 函数指针：int (*fun)(int x,int y); （3）用法不同 指针函数返回一个指针。 函数指针使用过程中指向一个函数。通常用于函数回调的应用场景。 内存分布模型 如上图，从低地址到高地址，一个程序由代码段、数据段、BSS段、堆栈段组成。 代码段：存放程序执行代码的一块内存区域。只读，不允许修改，代码段的头部还会包含一些只读的常量，如字符串常量字面值（注意：const变量虽然属于常量，但是本质还是变量，不存储于代码段）。 数据段data：存放程序中已初始化的非零全局变量和静态变量的一块内存区域。 BSS 段：存放程序中未初始化的全局变量和静态变量的一块内存区域。 可执行程序在运行时又会多出两个区域：堆区和栈区。 堆区：动态申请内存用。堆从低地址向高地址增长。 栈区：存储局部变量、函数参数值。栈从高地址向低地址增长。是一块连续的空间。 最后还有一个文件映射区（共享区），位于堆和栈之间。 堆和栈的区别 堆栈空间分配不同。栈由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等，栈有着很高的效率；堆一般由程序员分配释放，堆的效率比栈要低的多。 堆栈缓存方式不同。栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放；堆则是存放在二级缓存中，速度要慢些。 空间大小： 栈的空间大小并不大，一般最多为2M，超过之后会报Overflow错误。堆的空间非常大，理论上可以接近3G。（针对32位程序来说，可以看到内存分布，1G用于内核空间，用户空间中栈、BSS、data又要占一部分，所以堆理论上可以接近3G，实际上在2G-3G之间）。 能否产生碎片： 栈的操作与数据结构中的栈用法是类似的。‘后进先出’的原则，以至于不可能有一个空的内存块从栈被弹出。因为在它弹出之前，在它上面的后进栈的数据已经被弹出。它是严格按照栈的规则来执行。但是堆是通过new/malloc随机申请的空间，频繁的调用它们，则会产生大量的内存碎片。这是不可避免地。 什么是野指针 野指针就是指针指向的位置是不可知的（随机的、不正确的、没有明确限制的） 野指针不同于空指针，空指针是指一个指针的值为null，而野指针的值并不为null，野指针会指向一段实际的内存，只是它指向哪里我们并不知情，或者是它所指向的内存空间已经被释放，所以在实际使用的过程中，我们并不能通过指针判空去识别一个指针是否为野指针。 出现野指针的情况： 指针变量的值未被初始化： 声明一个指针的时候，没有显示的对其进行初始化，那么该指针所指向的地址空间是乱指一气的。如果指针声明在全局数据区，那么未初始化的指针缺省为空，如果指针声明在栈区，那么该指针会随意指向一个地址空间。 指针所指向的地址空间已经被free或delete：在堆上malloc或者new出来的地址空间，如果已经free或delete，那么此时堆上的内存已经被释放，但是指向该内存的指针如果没有人为的修改过，那么指针还会继续指向这段堆上已经被释放的内存，这时还通过该指针去访问堆上的内存，就会造成不可预知的结果，给程序带来隐患。 指针操作超越了作用域 如何避免野指针 1）初始化置NULL （2）申请内存后判空：malloc申请内存后需要判空，而在现行C++标准中，如C++11，使用new申请内存后不用判空，因为发生错误将抛出异常。 （3）使用时不要超出指针作用域。 （4）指针释放后置NULL （5）使用智能指针。 请你说说内存泄露 简单地说就是申请了一块内存空间，使用完毕后没有释放掉。 （1）new和malloc申请资源使用后，没有用delete和free释放； （2）子类继承父类时，父类析构函数不是虚函数。 （3）比如文件句柄、socket、自定义资源类没有使用对应的资源释放函数。 （4）shared_ptr共享指针成环，造成循环引用计数，资源得不到释放。 有以下几种避免方法： 第一：良好的编码习惯，使用了内存分配的函数，一旦使用完毕,要记得使用其相应的函数释放掉。 第二：将分配的内存的指针以链表的形式自行管理，使用完毕之后从链表中删除，程序结束时可检查改链表。 第三：使用智能指针。 第四：一些常见的工具插件可以帮助检测内存泄露，如ccmalloc、Dmalloc、Leaky、Valgrind等等。 请你说说malloc内存管理原理 当开辟的空间小于 128K 时，调用 brk()函数； brk是将数据段(.data)的最高地址指针_edata往高地址推； 当开辟的空间大于 128K 时，调用mmap()函数。 mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。 malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块连接，每一个空闲块记录了一个未分配的、连续的内存地址。 new和malloc的区别和实现原理 new是操作符，而malloc是函数。 new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数；而malloc没有构造函数和析构函数。 malloc需要给定申请内存的大小，返回的指针需要强转；new会调用构造函数，不用指定内存的大小，返回指针不用强转。 new可以被重载；malloc不行 new分配内存更直接和安全。 new发生错误抛出异常，malloc返回null 使用指针需要注意什么？ 定义指针时，先初始化为NULL。 用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。在现行C++标准中，如C++11，使用new申请内存后不用判空，因为发生错误将抛出异常。 不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。 避免数字或指针的下标越界，特别要当心发生“多1”或者“少1”操作 动态内存的申请与释放必须配对，防止内存泄漏 用free或delete释放了内存之后，立即将指针设置为NULL，防止“野指针” 初始化为0的全局变量在bss还是data BSS段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。 动态链接与静态链接两者有什么区别？ 静态链接，是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中，就算你在去把静态库删除也不会影响可执行程序的执行；生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。 动态链接，是在链接的时候没有把调用的函数代码链接进去，而是在执行的过程中，再去找要链接的函数，生成的可执行文件中没有函数代码，只包含函数的重定位信息，所以当你删除动态库时，可执行程序就不能运行。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀。 区别 静态链接是将各个模块的obj和库链接成一个完整的可执行程序；而动态链接是程序在运行的时候寻找动态库的函数符号（重定位） 静态链接运行快、可独立运行；动态链接运行较慢(事实上，动态库被广泛使用，这个缺点可以忽略)、不可独立运行。 静态链接浪费空间，存在多个副本，同一个函数的多次调用会被多次链接进可执行程序，当库和模块修改时，main也需要重编译；动态链接节省空间，相同的函数只有一份，当库和模块修改时，main不需要重编译。 导入C函数的关键字是什么，C++编译时和C有什么不同？ 关键字：在C++中，导入C函数的关键字是extern，表达形式为extern “C”， extern \"C\"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern \"C\"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。 编译区别：由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。 为什么要少使用宏？C++有什么解决方案？ 由程序编译的四个过程，知道宏是在预编译阶段被展开的。在预编译阶段是不会进行语法检查、语义分析的，宏被暴力替换，正是因为如此，如果不注意细节，宏的使用很容易出现问题。比如在表达式中忘记加括号等问题。 正因为如此，在C++中为了安全性，我们就要少用宏。 不带参数的宏命令我们可以用常量const来替代，比如const int PI = 3.1415，可以起到同样的效果，而且还比宏安全，因为这条语句会在编译阶段进行语法检查。 而带参数的宏命令有点类似函数的功能，在C++中可以使用内联函数或模板来替代，内联函数与宏命令功能相似，是在调用函数的地方，用函数体直接替换。但是内联函数比宏命令安全，因为内联函数的替换发生在编译阶段，同样会进行语法检查、语义分析等，而宏命令发生在预编译阶段，属于暴力替换，并不安全。 请你说说内联函数，为什么使用内联函数？需要注意什么？ C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。 如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline。 为什么使用内联函数？ 函数调用是有调用开销的，执行速度要慢很多，调用函数要先保存寄存器，返回时再恢复，复制实参等等。 如果本身函数体很简单，那么函数调用的开销将远大于函数体执行的开销。为了减少这种开销，我们才使用内联函数。 内联函数使用的条件 以下情况不宜使用内联： （1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 （2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。 内联不是什么时候都能展开的，一个好的编译器将会根据函数的定义体，自动地取消不符合要求的内联。 内联函数和函数的区别，内联函数的作用。 内联函数比普通函数多了关键字inline 内联函数避免了函数调用的开销；普通函数有调用的开销 普通函数在被调用的时候，需要寻址（函数入口地址）；内联函数不需要寻址。 内联函数有一定的限制，内联函数体要求代码简单，不能包含复杂的结构控制语句；普通函数没有这个要求。 内联函数的作用：内联函数在调用时，是将调用表达式用内联函数体来替换。避免函数调用的开销。 什么是字节对齐？为什么要字节对齐？ 为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，即所谓的“对齐”，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除，也即“对齐”跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。 为什么要字节对齐？ （1）需要字节对齐的根本原因在于CPU访问数据的效率问题。 （2）一些系统对对齐要求非常严格，比如sparc系统，如果取未对齐的数据会发生错误，而在x86上就不会出现错误，只是效率下降。 （3）各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些平台每次读都是从偶地址开始 结构体字节对齐三原则： 1.每个数据成员存储起始位置要从该成员大小的整数倍开始 2.结构体作为成员时应从内部最大元素的整数倍地址开始存储 3.结构体总大小为内部最大成员的整数倍 如何看类型声明？ 第一步，找到变量名，如果没有变量名，找到最里面的结构 第二步，向右看，读出你看到的东西，但是不要跳过括号 第三步，再向左看，读出你看到的东西，但是也不要跳过括号 第四步，如果有括号的话，跳出一层括号 第五步，重复上述过程，直到你读出最终的类型 const的作用 指针常量（顶层const）和常量指针（底层const） const修饰普通类型的变量，告诉编译器某值是保持不变的。 const 修饰指针变量，根据const出现的位置和出现的次数分为三种 指向常量的指针：指针指向一个常量对象，目的是防止使用该指针来修改指向的值。 常指针：将指针本身声明为常量，这样可以防止改变指针指向的位置。 指向常量的常指针：一个常量指针指向一个常量对象。 const修饰参数传递，可以分为三种情况。 值传递的 const 修饰传递，一般这种情况不需要 const 修饰 当 const 参数为指针时，可以防止指针被意外篡改。 自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。 const修饰函数返回值，分三种情况。 const 修饰内置类型的返回值，修饰与不修饰返回值作用一样。 const 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。 const 修饰返回的指针或者引用，是否返回一个指向 const 的指针，取决于我们想让用户干什么。 const修饰成员函数 const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。 static的作用 1.静态局部变量 用于函数体内部修饰变量 （1）该变量在全局数据区分配内存(局部变量在栈区分配内存); （2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化(局部变量每次函数调用都会被初始化); （3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0(局部变量不会被初始化); （4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，也就是不能在函数体外面使用它(局部变量在栈区，在函数结束后立即释放内存); 2.静态全局变量和静态函数 定义在函数体外，用于修饰全局变量，表示该变量只在本文件可见。 （1）静态全局变量不能被其它文件所用(全局变量可以); （2）其它文件中可以定义相同名字的变量，不会发生冲突(自然了，因为static隔离了文件，其它文件使用相同的名字的变量，也跟它没关系了); 3.静态成员变量 所有的对象都只维持一份拷贝，可以实现不同对象间的数据共享； 不需要实例化对象即可访问 注意不能再类内部初始化！要在类外部初始化，初始化时不加static！ 4.静态成员函数 这个函数不接受this指针，只能访问类的静态成员 这个函数不需要实例化对象即可访问 为什么静态成员变量不能在类内初始化 因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。 为什么静态成员函数不能访问非静态成员 静态成员函数不属于任何一个对象，因此C++规定静态成员函数没有this指针。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行访问。 静态成员函数与普通成员函数的区别 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。 普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。 volatile和mutable mutable是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中，甚至结构体变量或者类对象为const，其mutable成员也可以被修改。mutable在类中只能够修饰非静态数据成员。 一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器每次会从内存里重新读取这个变量的值，而不是从寄存器里读取。特别是多线程编程中，变量的值在内存中可能已经被修改，而编译器优化优先从寄存器里读值，读取的并不是最新值。这就是volatile的作用了。 左值和右值 C++ 中有两种类型的表达式： 左值（lvalue）：指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。 右值（rvalue）：术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。 变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。 右值引用的作用 && C++11引入右值引用主要是为了实现移动语义和完美转发。 移动语义为了避免临时对象的拷贝，为类增加移动构造函数。 完美转发，就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是右值，可能是左值，如果还能继续保持参数的原有特征，那么它就是完美的。 移动语义的原理 移动语义为了避免临时对象的拷贝，为类增加移动构造函数。移动构造函数与拷贝构造不同，它并不是重新分配一块新的空间同时将要拷贝的对象复制过来，而是\"拿\"了过来，将自己的指针指向别人的资源，然后将别人的指针修改为nullptr 面对对象和面对过程的区别？ 面向过程的编程思想，就是关注问题解决的过程，按顺序一步一步执行解决问题。而面向对象的编程思想，是把构成问题的各个事务分解成各个对象，即问题建模。建立对象的目的不是为了完成一个步骤，而是为了描述一个事务在解决问题中经过的步骤和行为。 类的访问权限有几种 （1）私有成员（变量和函数）只限于类成员访问，由private限定； （2）公有成员（变量和函数）允许类成员和类外的任何访问，由public限定； （3）受保护成员（变量和函数）允许类成员和派生类成员访问，不允许类外的任何访问。所以protected对外封闭，对派生类开放。 继承类型和访问属性 当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。 我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则： 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。 总结: 不管是哪种继承方式，派生类中新增成员可以访问基类的公有成员和保护成员，无法访问私有成员。但是只有公有继承中，派生类的对象能访问基类的公有成员。使用友元（friend）可以访问保护成员和私有成员。 拷贝构造函数的参数类型为什么必须是引用 如果拷贝构造函数中的参数不是一个引用，即形如CClass(const CClass c_class)，那么就相当于采用了传值的方式(pass-by-value)，而传值的方式会调用该类的拷贝构造函数，从而造成无穷递归地调用拷贝构造函数。因此拷贝构造函数的参数必须是一个引用。否则无法完成拷贝，而且栈也会满。 什么是友元函数 类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。 如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend 调用方式 可以直接调用友元函数，不需要通过对象或指针。 缺陷 友元函数有权访问类的所有私有（private）成员和保护（protected）成员。破坏了类的封装性。 初始化列表的使用场景 成员类型是没有默认构造函数的类。若没有提供显示初始化式，则编译器隐式使用成员类型的默认构造函数，若类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。 const 成员或引用类型的成员。因为 const 对象或引用类型只能初始化，不能对他们赋值。 深拷贝与浅拷贝的区别 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 什么是this指针 在每一个成员函数中都包含一个特殊的指针，这个指针的名字是固定的，称为this指针。它是指向本类对象的指针，它的值是当前被调用的成员函数所在的对象的起始地址。 对于一个类的实例来说，你可以看到它的成员函数、成员变量，但是实例本身呢？ this是一个指针，它时时刻刻指向你这个实例本身。 C++中 struct 和 class 的区别 struct 一般用于描述一个数据结构集合，而 class 是对一个对象数据的封装； struct 中默认的访问控制权限是 public 的，而 class 中默认的访问控制权限是 private 的，例如： struct A{ int iNum; // 默认访问控制权限是 public } class B{ int iNum; // 默认访问控制权限是 private } 在继承关系中，struct 默认是公有继承，而 class 是私有继承； class 关键字可以用于定义模板参数，就像 typename，而 struct 不能用于定义模板参数，例如： template // 可以把typename 换成 class int Func(const T& t, const Y& y) { //TODO } C++结构体和C结构体的区别 （1）C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数。 （2）C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种。 （3）C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的。 （4）C 中使用结构体需要加上 struct 关键字，或者对结构体使用 typedef 取别名，而 C++ 中可以省略 struct 关键字直接使用。 析构函数必须为虚函数吗？构造函数可以为虚函数吗？ C++默认析构函数不是虚函数，因为申明虚函数会创建虚函数表，占用一定内存，当不存在继承的关系时，析构函数不需要申明为虚函数。 若存在继承关系时，析构函数必须申明为虚函数，这样父类指针指向子类对象，释放基类指针时才会调用子类的析构函数释放资源，否则内存泄漏。 构造函数不能为虚函数，当申明一个函数为虚函数时，会创建虚函数表，那么这个函数的调用方式是通过虚函数表来调用。若构造函数为虚函数，说明调用方式是通过虚函数表调用，需要借助虚表指针，但是没构造对象，哪里来的虚表指针？但是没有虚表指针，怎么访问虚函数表从而调用构造函数呢？这就成了一个先有鸡还是先有蛋的问题。 当类存在继承的情况下，需要注意什么？ 若存在继承关系时，析构函数必须申明为虚函数，这样父类指针指向子类对象，释放基类指针时才会调用子类的析构函数释放资源，否则内存泄漏。 构造与析构的顺序 构造顺序：基类构造函数》对象成员构造函数》子类构造函数 析构顺序：子类析构函数》对象成员析构函数》基类析构函数 从里向外构造，从外向里析构 说说你对多态的理解 利用虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。 换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism）。 重载和重写的区别 重载overload 函数名相同，参数列表不同（参数类型、参数顺序),不能用返回值区分。 特点： （1）作用域相同； （2）函数名相同； （3）参数列表必须不同，但返回值无要求； 特殊情况：若某一重载版本的函数前面有virtual关键字修饰，则表示它是虚函数，但它也是重载的一个版本。 作用效果：编译器根据函数不同的参数列表，将函数与函数调用进行早绑定，重载与多态无关，与面向对象无关，它只是一种语言特性。 重写override 派生类重定义基类的虚函数，既会覆盖基类的虚函数(多态)。 特点： （1）作用域不同； （2）函数名、参数列表、返回值相同； （3）基类函数是virtual； 特殊情况：若派生类重写函数是一个重载版本，那么基类的其他同名重载函数将在子类中隐藏。 作用效果：父类指针和引用指向子类的实例时，通过父类指针或引用可以调用子类的函数，这就是C++的多态。 虚函数的工作机制 C++实现虚函数的原理是虚函数表+虚表指针。 当一个类里存在虚函数时，编译器会为类创建一个虚函数表，虚函数表是一个数组，数组的元素存放的是类中虚函数的地址。 同时为每个类的对象添加一个隐藏成员，该隐藏成员保存了指向该虚函数表的指针。该隐藏成员占据该对象的内存布局的最前端。 所以虚函数表只有一份，而有多少个对象，就对应多少个虚函数表指针。 虚函数表在什么时候创建？每个对象都有一份虚函数表吗？ 当一个类里存在虚函数时，编译器会为类创建一个虚函数表，发生在编译期。 虚函数表只有一份，而有多少个对象，就对应多少个虚函数表指针。 纯虚函数什么情况下使用？ 后面加=0 纯虚函数的类称为抽象类（Abstract Class）。之所以说它抽象，是因为它无法实例化，也就是无法创建对象。原因很明显，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间。 抽象类通常是作为基类，让派生类去实现纯虚函数。派生类必须实现纯虚函数才能被实例化。 空类大小？ 空类sizeof大小为1，为了区分地址 为什么要使用操作符重载？ 对于C++提供的所有操作符，通常只支持对于基本数据类型（如int、float）和标准库中提供的类（如string）的操作，而对于用户自己定义的类，如果想要通过该操作符实现一些基本操作（比如比较大小，判断是否相等），就需要用户自己来定义关于这个操作符的具体实现了。 哪些操作符不能重载？ .：成员访问运算符 .*, ->*：成员指针访问运算符 ::：域运算符 sizeof：长度运算符 ?:：条件运算符 #： 预处理符号 操作符被重载的基本前提： 1、只能为自定义类型重载操作符； 2、不能对操作符的语法(优先级、结合性、操作数个数、语法结构)、语义进行颠覆； 3、不能引入新的自定义操作符。 智能指针 智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。 因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，自动释放资源。这样程序员就不用再担心内存泄露的问题了。 C++里面有四个指针：auto_ptr、unique_ptr、shared_ptr、weak_ptr，auto_ptr被C++11弃用。 unique_ptr unique指针规定一个智能指针独占一块内存资源。当两个智能指针同时指向一块内存，编译报错。 我们只需要将拷贝构造函数和赋值拷贝构造函数申明为private或delete。不允许拷贝构造函数和赋值操作符 shared_ptr 实现原理：有一个引用计数的指针类型变量，专门用于引用计数，使用拷贝构造函数和赋值拷贝构造函数时，引用计数加1，当引用计数为0时，释放资源 #include #include using namespace std; template class mysharedPtr { public: mysharedPtr(T* p = NULL); ~mysharedPtr(); mysharedPtr(const mysharedPtr& other); mysharedPtr& operator=(const mysharedPtr& other); private: T* m_ptr; unsigned int* m_count; }; template mysharedPtr::mysharedPtr(T* p) { m_ptr = p; m_count = new unsigned int(0); ++(*m_count); cout mysharedPtr::~mysharedPtr() { --(*m_count); if ((*m_count) == 0) { delete[] m_ptr; m_ptr = NULL; delete[] m_count; m_count = NULL; cout mysharedPtr::mysharedPtr(const mysharedPtr& other) { m_ptr = other.m_ptr; m_count = other.m_count; ++(*m_count); cout mysharedPtr& mysharedPtr::operator=(const mysharedPtr& other) { // 《C++ primer》：“这个赋值操作符在减少左操作数的使用计数之前使other的使用计数加1， // 从而防止自身赋值”而导致的提早释放内存 ++(*other.m_count); --(*m_count); // 将左操作数对象的使用计数减1，若该对象的使用计数减至0，则删除该对象 if ((*m_count) == 0) { delete[] m_ptr; m_ptr = NULL; delete[] m_count; m_count = NULL; cout weak_ptr shared_ptr会不会出现内存泄露？怎么解决？ 会出现内存泄露问题。 共享指针的循环引用计数问题：当两个类中相互定义shared_ptr成员变量，同时对象相互赋值时，就会产生循环引用计数问题，最后引用计数无法清零，资源得不到释放。 可以使用weak_ptr，weak_ptr是弱引用，weak_ptr的构造和析构不会引起引用计数的增加或减少。我们可以将其中一个改为weak_ptr指针就可以了。 decltype 类型指示符 作用是选择并返回操作数的数据类型。 decltype(f()) sum=x; //sum的类型就是函数f的返回类型 #ifdef ifndef #endif ifdef 当且仅当变量已定义时为真，#ifndef 当且仅当变量未定义时为真，一旦检查结果为真，则执行后续操作直至遇到#endif为止。 命名空间的using声明 作用域操作符（::），编译器应从操作符左侧名字所示的作用域中寻找右侧那个名字 如：std::cin C++标准库中的函数或者对象都是在命名空间std中定义的 using namespace name; //可以直接访问命名空间中的名字 头文件不应该包含using声明 assert预处理宏 assert(expr) 如果expr表达式为假，assert输出信息并终止程序执行，如果为真，assert什么也不做。 explicit 用于修饰只有一个参数传递（除了第一个参数以外的其他参数都有默认值时, ）的构造函数，作用是表明该构造函数是显示的, 而非隐式的。相对应的，implicit,意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式). enum enum是一个派生数据类型，它可以声明、定义一个整型常数集合。所不同的是，集合里面的整型常数是用其他名字代替的，但只是代替，其本质还是一个整型常数。（让外界可以通过名字知道这些常数的含义） 常用于定义状态码 strcpy和memcpy strcpy 是字符串拷贝函数，返回dest的字符串起始地址。函数原型是： char *strcpy(char* dest, const char *src) 从src逐字节拷贝到dest，直到遇到\\0结束，因为没有指定长度，可能会导致拷贝越界，造成缓冲区溢出漏洞，安全的版本是strncpy函数 strncpy 是用来复制源字符串的前n个字符，返回dest的字符串起始地址。函数原型是： char *strncpy(char* dest, const char* src, const size_t n) src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置n个字符。如果src字符串长度小于n，则拷贝完字符串后，在dest后追加0，直到n个。如果src的长度大于等于n，就截取src的前n个字符，不会在dest后追加0。dest必须有足够的空间放置n个字符，否则可能会造成缓冲溢出的错误情况。 ​ memcpy()函数从源 src 所指的内存地址的起始位置，开始拷贝count个字节，到目标 dest 所指的内存地址的起始位置中。值得说明的是：src和dest所指内存区域不能重叠，函数返回指向dest的指针 extern void *memcpy(void *dest, void *src, unsigned int count); Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-05-09 18:37:52 "},"C++2.html":{"url":"C++2.html","title":"C++ (2)","keywords":"","body":" 编译 调试 gcc g++编译器 gdb调试器 ACM模式 cin cin.get(char &) cin.get(void) getline ( istream &is , string &str , char delim ) getchar() stringstream include STL String Lambda 左移 右移 编译 调试 gcc g++编译器 gcc是GNU编译器合集，能编译C, C++, Objective-C, Objective-C++, Fortran, Ada, D, Go, and BRIG (HSAIL)多种语言。 g++能编译 c & c++ 使用g++ test.cpp -o test或（g++ test.cpp ）会自动执行上述流程 g++ -std=c++11 a.cpp 支持c++11编译 （否则容易报错） g++ -g 添加gdb调试选项 option 功能 举例 输出格式 -E 预处理 宏替换、头文件展开、去掉注释g++ -E test.cpp -o test.i *.i -S 生成汇编文件 g++ -S test.i -o test.s *. s -c 生成二进制文件,可被直接执行 g++ -c test.s -o test.o *. o -o 生成最终可执行文件 g++ test.o -o test *.out(默认) -I参数是用来指定头文件所在目录 gdb调试器 g++ -g 添加gdb调试选项 linux系统支持gdb，mac支持lldb。https://lldb.llvm.org/use/map.html为gdb和lldb命令对照表。 先编译生成.out文件g++ -g -std=c++11 a.cpp，gdb a.out进入调试页面，最后r或run运行。 b打断点，info breeak查看断点信息，del 1删除断点。 n或next继续执行 p、print打印变量或变量地址 s、step进入函数调试 shell ls可以使用终端命令等，set logging on打开日志模式 watchpoint查看变量是否变化，info查看watchpoint信息。 ulimit -a 调试core文件 ACM模式 参考：https://www.nowcoder.com/exam/test/64565681/detail?pid=27976983 cin cin >> type 其中 type 可以是任何基本数据类型，对于一个变量，cin >>读取的是从非空白字符开始，到与目标类型不匹配的第一个字符之间的全部内容；不匹配的内容将被保存在输入缓冲流中，等待下一次输入。 cin >>会自动跳过空白（空格，换行符，制表符）直到遇到非空白字符。 cin.get(char &) 读取一个字符并存储到实参中。是一个非格式化函数，不会越过空格、换行符、制表符输入。 cin.get(void) 读取一个字符并返回。是一个非格式化函数，不会越过空格、换行符、制表符输入。 getline ( istream &is , string &str , char delim ) istream &is 表示一个输入流，例如cin； string &str 表示把从输入流读入的字符串存放在这个字符串中（可以自己随便命名，str什么的都可以） char delim 表示遇到这个字符停止读入，在不设置的情况下系统默认该字符为'\\n'，也就是回车换行符（遇到回车停止读入） getchar() 读取一个字符，回车结束。 stringstream include stringstream的作用就是从string对象读取字符或字符串。 结合getline分割字符串非常好用。 int main() { string line; //while (cin >> line) { //因为加了“，”所以可以看出一个字符串读取 while(getline(cin, line)){ vector strs; stringstream ss(line); string str; while (getline(ss, str, ',')) { strs.push_back(str); } // sort(strs.begin(), strs.end()); for (auto& str : strs) { cout '\\0' 字符串结束符，字符串的结尾标志，存储在字符串的结尾。 '\\n' 换行 ，将当前位置移到下一行开头。 EOF(End Of File) 表示文件结束符（end of file），在while循环中以EOF作为文件结束标志，这种以EOF作为文件结束标志的文件，必须是文本文件。 STL vector deque（双端数组） list（双向链表） queue stack set/unordered_set map/unordered_map 是否支持迭代器 × × 尾部添加 push_back push_back push_back push 尾部删除 pop_back pop_back pop_back 首部添加 push_front push_front push 首部删除 pop_front pop_front pop pop 插入（迭代器） insert insert insert insert insert 删除（迭代器） erase erase erase erase erase 改变大小 resize resize resize 交换内容 swap swap swap swap swap 清除 clear clear clear clear clear 是否为空 empty empty empty empty empty empty empty 大小 size size size size size size size 第一个元素 front front front front 最后一个元素 back back back back 访问元素 at() at() at() top（栈顶） 指定键的个数 count count 寻找指定键 存在返回迭代器，反之返回s.end() find find ps： vector> dp(n,vector(m,0)) n行m列二维数组 vector访问元素的速度要比deque快 set不允许出现重复 所有的元素都会被自动排序（默认从小到大） 不能直接修改它的元素值 multiset 允许出现键值重复，unordered_set unordered_multiset元素不会自动排序 map中是pair p(key,value) map.first是key 只出现一次 map.second是value map[key]=value map[x]++ 把key放在map中计数 迭代器是类模板不是指针（表现得像指针） container::iterator iter container::const_iterator citer *iter :返回迭代器iter所指元素引用 iter->mem :等价于(*iter).mem，解引用iter并获取该元素的名为mem的成员 ++iter :令iter指示容器中的下一个元素 --iter :令iter指示容器中的上一个元素 iter + n:迭代器加上一个整数仍得一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。 iter - n:迭代器减去一个整数仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。 reverse(begin(),end()); //翻转 swap(a,b); //互换 int max = *max_element(begin(),end()); // 返回最大值 int min = *min_element(begin(),end()); // 返回最小值 accumulate(begin(),end(),0); // 求和 sort(begin(),end()，cmp); //排序 bool cmp(const Type1 &a, const Type2 &b); //若第一参数小于第二参数则返回true //c++内置比较函数 less() // () // > less_equal() // () // >= sort函数根据cmp函数的返回值，对cmp函数的两个参数排序。如果cmp返回true，排序为“参数1” “参数2”，否则排序为“参数2” “参数1”。升序排列，则return ab。 for(auto a:b)中b为一个容器，效果是利用a遍历并获得b容器中的每一个值，但是a无法影响到b容器中的元素。 for(auto &a:b)中加了引用符号，可以对容器中的内容进行赋值，即可通过对a赋值来做到容器b的内容填充。 String str 转 int stoi(str) str 转 long stol(str) str 转 float stof(str) char -'0' 转 int int +'0' 转char to_string(type) (任意类型转换为字符串类型) str.substr(int pos = 0,int n = npos) str1.insert(int pos, char* s) str+='abc' (str拼接) .append() str1.find(string str2,int pos = 0) int main() { string s1 = \"aeiouAEIOU\"; string s2 = \"apple\"; int a = s1.find(s2[2]); //从s1字符串内查找s2字符，返回查到的位置索引，反之返回-1。 printf(\"a: %d\", a); return 0; } Lambda [ caputrue ] ( params ) opt -> ret { body; }; 1).capture是捕获列表； 2).params是参数表；(选填) 3).opt是函数选项；可以填mutable,exception,attribute（选填） mutable说明lambda表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获的对象的non-const方法。 exception说明lambda表达式是否抛出异常以及何种异常。 attribute用来声明属性。 4).ret是返回值类型。(选填) 5).body是函数体。 捕获列表：lambda表达式的捕获列表精细控制了lambda表达式能够访问的外部变量，以及如何访问这些变量。 1).[]不捕获任何变量。 2).[&]捕获外部作用域中所有变量，并作为引用在函数体中使用（按引用捕获）。 3).[=]捕获外部作用域中所有变量，并作为副本在函数体中使用(按值捕获)。 4).[=,&foo]按值捕获外部作用域中所有变量，并按引用捕获foo变量。 5).[bar]按值捕获bar变量，同时不捕获其他变量。 6).[this]捕获当前类中的this指针，让lambda表达式拥有和当前类成员函数同样的访问权限。如果已经使用了&或者=，就默认添加此选项。捕获this的目的是可以在lamda中使用当前类的成员函数和成员变量。 左移 右移 左移 右移 >> 左侧补0 >> 1 相当于除2 （有符号整数除外 负数） Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-05-15 21:29:19 "},"操作系统.html":{"url":"操作系统.html","title":"操作系统","keywords":"","body":" 内核态与用户态的区别 什么是系统调用 说说中断流程 什么是并发和并行 进程与线程的概念 进程与线程的区别 进程的状态转换 进程调度算法有哪些？ 进程间的通信方式有哪些？ 管道 系统IPC（Inter-Process Communication） 套接字 SOCKET 线程的通信方式有哪些？ 线程同步方式有哪些？ 守护进程、孤儿进程、僵尸进程 守护进程 孤儿进程 僵尸进程 如何解决僵尸进程？ 什么是死锁，产生的条件，如何解决、避免？ 置换算法有哪些？ LRU算法及其实现方式 物理地址、逻辑地址、虚拟内存、物理内存的概念？ 物理地址： 逻辑地址： 逻辑地址转物理地址 物理内存 虚拟内存： 虚拟内存的好处和坏处？ 虚拟内存的好处 虚拟内存的代价： wait()函数 fork()函数 五种IO模型 同步与异步的区别，阻塞与非阻塞的区别？ 多路IO复用技术有哪些，区别是什么？ epoll的原理 epoll和select的区别，epoll为什么高效？ epoll水平触发与边缘触发的区别？ 线程池的设计思路，线程池中线程的数量由什么确定？ 内核态与用户态的区别 内核态与用户态：内核态（系统态）与用户态是操作系统的两种运行级别。内核态拥有最高权限，可以访问所有系统指令；用户态则只能访问一部分指令。 什么时候进入内核态： 系统调用（Trap） ：用户态进程 主动 要求切换到内核态的一种方式，主要是为了使用内核态才能做的事情比如读取磁盘资源。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现。 中断（Interrupt） ：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 异常（Exception）：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 其中，系统调用是主动的，另外两种是被动的。 为什么区分内核态与用户态： 在CPU的所有指令中，有一些指令是非常危险的，如果错用，将导致整个系统崩溃。比如：清内存、设置时钟等。所以区分内核态与用户态主要是出于安全的考虑。 什么是系统调用 运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，系统调用和普通的函数调用非常相似。区别仅仅在于，系统调用由操作系统核心提供，运行于核心态；而普通的函数调用由函数库或用户自己提供，运行于用户态。 系统调用的过程可以简单分为以下几个步骤： 用户态的程序发起系统调用，因为系统调用中涉及一些特权指令（只能由操作系统内核态执行的指令），用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。 发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，也就是开始处理系统调用。 内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。 说说中断流程 中断是指当出现需要时，CPU暂时停止当前进程的执行，转而执行处理新情况的中断处理程序。当执行完该中断处理程序后，则重新从刚才停下的位置继续当前进程的运行。 为了区分不同的中断，每个设备有自己的中断号。系统有0-255一共256个中断。系统有一张中断向量表，用于存放256个中断的中断服务程序入口地址。每个入口地址对应一段代码，即中断服务程序。 什么是并发和并行 并发：对于单个CPU，在一个时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级，多个任务不停来回快速切换。 并行：对于多个CPU，多个进程同时运行。 区别。通俗来讲，它们虽然都说是\"多个进程同时运行\"，但是它们的\"同时\"不是一个概念。并行的\"同时\"是同一时刻可以多个任务在运行(处于running)，并发的\"同时\"是经过不同线程快速切换，使得看上去多个任务同时都在运行的现象。 进程与线程的概念 进程：是系统进行资源调度和分配的基本单位，且每个进程拥有独立的地址空间，进程实现了操作系统的并发，是系统中并发执行的单位。 线程：是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发； 进程与线程的区别 答案一： 单位：进程是资源分配的最小单位，线程是CPU调度的最小单位。两者均可并发执行。 从属：一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。 资源：进程之间的资源是独立的，进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。 资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。 系统开销：在创建或撤销进程时，系统都要为之分配或回收资源，系统开销显著大于创建或撤销线程的开销。 在进行进程切换时，设计到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。 而线程切换只需要保存和设置少量寄存器的内容，并不涉及存储管理方面的操作。 切换进程的开销也远大于切换线程的开销。 进程编程调试简单可靠性高，但是创建、销毁、切换开销大；线程正相反，但是编程调试相对复杂 进程之间不会相互影响，一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃会导致整个进程崩溃。所以多进程比多线程健壮。 答案二：根本区别就是多进程每个进程有自己的地址空间，线程则是共享地址空间。 速度：线程创建速度快，线程间通信快、切换快，因为它们在同一地址空间内 资源利用率：线程的资源利用率比较好也是因为它们在同一地址空间 同步问题：线程使用公共变量/内存时需要使用同步机制，也是因为它们在同一地址空间内。 进程的状态转换 进程包括三种状态：就绪、运行、阻塞 就绪 --> 运行：对就绪状态的进程，当进程调度程序按一种选定的策略从中选中一个就绪进程，为之分配处理机后，该进程便由就绪状态变为执行状态 运行 --> 阻塞：正在执行的进程因发生某等待事件而无法运行，则进程由执行状态变为阻塞状态，如进程提出输入/输出请求而变成带带外部设备传入信息的状态；进程申请资源（主存空间或外部设备）得不到满足时编程等待资源状态，进程运行中出现了故障（程序出错或主存储器读写错误等）编程等待干预状态等； 阻塞 --> 就绪：处于阻塞状态的进程，其等待的事件已经发生，如输入/输出完成；资源得到满足；或错误处理完毕时，处于等待状态的进程并不马上转入运行状态，而是先转入就绪状态，再由系统进程调度程序在适当的时候将改进成转为执行状态。 运行 --> 就绪 ：正在执行的进程，因时间片用完而被暂停运行；或在采用抢占式优先级调度算法的系统中，当有更高优先级的进程要运行而被迫让出处理机时，该进程便从运行状态转变为就绪状态 进程调度算法有哪些？ 先来先服务调度算法 时间片轮转调度算法 短作业优先调度算法 最短剩余时间优先调度算法： 是针对最短进程优先增加了抢占机制的版本 高响应比优先调度算法： 主要用于作业调度，该算法是对 先来先服务调度算法 和 短作业优先调度算法 的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间 优先级调度算法 进程间的通信方式有哪些？ 主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存）、套接字socket。 管道 管道主要包括普通管道和命名管道：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程的通信。 普通管道PIPE： 半双工（数据只能在一个方向上流动），具有固定的读端和写端 只能用于具有亲缘关系的进程间通信（也就是父子进程或兄弟进程之间） 它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，不属于其他任何文件系统，并且只存在于内存中。 int pipe(int fd[2]); 当一个管道建立时，会创建两个文件文件描述符，要关闭管道只需将这两个文件描述符关闭即可。 命名管道FIFO： 可以在无关的进程之间交换数据 有路径名与之相关联，以一种特殊设备文件形式存在于文件系统中 int mkfifo(const char* pathname,mode_t mode); 系统IPC（Inter-Process Communication） 消息队列： 消息队列是消息的链表，存放在内核中。一个消息队列由一个标识符来标识（即队列ID）。 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级； 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除； 消息队列可以实现消息的随机查询。 信号量 semaphore： 信号量是一个计数器，信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据； 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存； 信号量基于操作系统的PV操作，程序对信号量的操作都是原子操作； 每次对信号量的PV操作不仅限于对信号量值+1或-1而是可以加减任意正整数； 支持信号量组。 共享内存 Shared Memory： 共享内存指两个或多个进程共享一块指定的存储区，不同进程可以即时看到对方进程中对共享内存中数据的更新； 因为多个进程可以同时操作，所以需要进行同步； 信号量和共享内存通常结合在一起使用，信号量用来同步对共享内存的访问； 共享内存是最快的一种进程通信方式，因为进程是直接对内存进行存取。 套接字 SOCKET socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。 线程的通信方式有哪些？ 信号：类似进程间的信号处理 锁机制：互斥锁、读写锁、自旋锁 条件变量：使用通知的方式解锁，与互斥锁配合使用 信号量：包括无名线程信号量和命名线程信号量 线程同步方式有哪些？ （1）临界区： 通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问； （2）信号量： 信号量是一种特殊的变量，可用于线程同步。它只取自然数值，并且只支持两种操作： P(V)：如果信号量大于 0 ，执行 -1 操作；若S减1后仍大于或等于0，则进程继续执行；若S减1后小于0，则该进程被阻塞后放入等待该信号量的等待队列中，然后转进程调度。 V(V)：V+1；若结果大于0，则进程继续执行；若相加后结果仍小于或等于0，则从该信号的等待队列中释放一个等待进程，然后再返回原进程继续执行或转进程调度。 其系统调用为： sem_wait（sem_t *sem）：以原子操作的方式将信号量-1，如果信号量值小于0，则sem_wait将被阻塞，直到这个信号量具有非0 值。 sem_post（sem_t *sem)：以原子操作将信号量值+1。当信号量大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。 （3）互斥量： 互斥量又称互斥锁，主要用于线程互斥，不能保证按序访问，可以和条件锁一起实现同步。当进入临界区时，需要获得互斥锁并且加锁；当离开临界区时，需要对互斥锁解锁，以唤醒其他等待该互斥锁的线程。其主要的系统调用如下： pthread_mutex_init: 初始化互斥锁 pthread_mutex_destroy：销毁互斥锁 pthread_mutex_lock：以原子操作的方式给一个互斥锁加锁，如果目标互斥锁已经被上锁，pthread_mutex_lock 调用将阻塞，直到该互斥锁的占有者将其解锁。 pthread_mutex_unlock: 以一个原子操作的方式给一个互斥锁解锁。 （4）事件(信号)，Wait/Notify： 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作 （5）条件变量： 条件变量，又称条件锁，用于在线程之间同步共享数据的值。条件变量提供一种线程间通信机制：当某个共享数据达到某个值时，唤醒等待这个共享数据的一个/多个线程。即，当某个共享变量等于某个值时，调用signal/broadcast。此时操作共享变量时需要加锁。其主要的系统调用如下： pthread_cond_init: 初始化条件变量 pthread_cond_destroy：销毁条件变量 pthread_cond_signal：唤醒一个等待目标条件变量的线程。哪个线程被唤醒取决于调度策略和优先级。 pthread_cond_wait：等待目标条件变量。需要一个加锁的互斥锁确保操作的原子性。该函数中在进入wait状态前首先进行解锁，然后接收到信号后会再加锁，保证该线程对共享资源正确访问。 守护进程、孤儿进程、僵尸进程 守护进程 指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如Web服务器进程HTTP等。 孤儿进程 是指一个父进程退出后，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1 是内核启动的第一个用户级进程）所收养，并且由init进程对它们完成状态收集工作。 僵尸进程 是指一个进程使用fork函数创建子进程，如果子进程退出，而父进程并没有调用wait()或者waitpid()系统调用取得子进程的终止状态，那么子进程的进程描述符仍然保存在系统中，占用系统资源，这种进程称为僵尸进程。 两者的区别是：孤儿进程是父进程已退出，子进程未退出；而僵尸进程是父进程未退出，子进程已退出。 如何解决僵尸进程？ （1）一般为了防止产生僵尸进程，在fork子进程之后我们都要及时使用wait系统调用；同时，当子进程退出的时候，内核都会给父进程一个SIGCHLD信号，所以我们可以建立一个捕获SIGCHLD信号的信号处理函数，在函数体中调用wait（或waitpid），就可以清理退出的子进程以达到防止僵尸进程的目的。 （2）使用kill命令。 打开终端并输入下面命令: $ ps aux | grep Z 会列出进程表中所有僵尸进程的详细内容。 然后输入命令： $ kill -s SIGCHLD pid(父进程pid) 这样子进程退出后，父进程就会收到信号了。 或者可以强制杀死父进程： $ kill -9 pid(父进程pid) 这样父进程退出后，这些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并且由init进程对它们完成状态收集工作。 什么是死锁，产生的条件，如何解决、避免？ 由于系统中存在一些不可剥夺资源，当两个或两个以上进程在执行过程中，因争夺资源而造成的相互等待，使每个进程都无法向前推进的现象。 产生的条件：死锁发生有四个必要条件： 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源； 请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源； 不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放; 环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链。 如何解决： 破坏请求和保持条件： 一次性分配所有资源，这样就不会再有请求了 只要有一个资源得不到分配，就不给这个进程分配其他资源 破坏不可剥夺资源： 当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件 破坏环路等待条件： 资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件 置换算法有哪些？ 当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区，替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下： 最佳置换(OPT)算法：从主存中移出永远不再需要的页面；如无这样的页面存在，则选择最长时间不需要访问的页面。 先进先出(FIFO)算法：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。 最近最少使用（LRU）算法: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。 时钟（CLOCK）置换算法 当前最常采用的就是LRU 算法。 LRU算法及其实现方式 LRU算法：LRU算法用于缓存淘汰。思路是将缓存中最近最少使用的对象删除掉 实现方式：利用链表和hashmap。 当需要插入新的数据项的时候，如果新数据项在链表中存在（一般称为命中），则把该节点移到链表头部，如果不存在，则新建一个节点，放到链表头部，若缓存满了，则把链表最后一个节点删除即可。 在访问数据的时候，如果数据项在链表中存在，则把该节点移到链表头部，否则返回-1。这样一来在链表尾部的节点就是最近最久未访问的数据项。 代码实现 我们给出C++的具体实现，代码一看就懂了。 class LRUCache { list> cache;//创建双向链表 unordered_map>::iterator> map;//创建哈希表 int cap; public: LRUCache(int capacity) { cap = capacity; } int get(int key) { if (map.count(key) > 0){ auto temp = *map[key]; cache.erase(map[key]); map.erase(key); cache.push_front(temp);//把该节点移到链表头部 map[key] = cache.begin();//映射头部 return temp.second; } return -1; } void put(int key, int value) { if (map.count(key) > 0){ cache.erase(map[key]); map.erase(key); } else if (cap == cache.size()){//若缓存满了，则把链表最后一个节点删除 auto temp = cache.back(); map.erase(temp.first); cache.pop_back(); } cache.push_front(pair(key, value));//新建一个节点，放到链表头部 map[key] = cache.begin();//映射头部 } }; /** Your LRUCache object will be instantiated and called as such: LRUCache* obj = new LRUCache(capacity); int param_1 = obj->get(key); obj->put(key,value); */ 物理地址、逻辑地址、虚拟内存、物理内存的概念？ 物理地址： 它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取，是内存单元的真正地址 逻辑地址： 是指用户看到的地址。逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址（在内存条中的所处的位置）并非是连续的，只是通过操作系统通过地址映射，将逻辑地址映射成连续的，这样使用更符合人们的直观思维 逻辑地址转物理地址 一句话来说：逻辑地址左移四位加偏移地址就是物理地址 逻辑地址 = 段地址：偏移地址 具体运算：段地址×16（左移四位，也就是2的四次方，相当于乘16）+偏移地址=物理地址（可以理解为段地址末尾补一个零） 逻辑地址是 1000H：0001H 那么物理地址为1000H×16+0001H=10001H 因为地址本身一般都是十六进制数，所以只需要把段地址左移一位末尾补0再和偏移地址加起来就是物理地址 物理内存 寄存器：速度最快、量少、价格贵。 高速缓存：次之。 主存：再次之。 磁盘：速度最慢、量多、价格便宜。 虚拟内存： 虚拟内存是一种内存管理技术，它会使程序自己认为自己拥有一块很大且连续的内存，然而，这个程序在内存中不是连续的，并且有些还会在磁盘上，在需要时进行数据交换。虚拟内存与物理内存存在映射关系，通过页表寻址完成虚拟地址和物理地址的转换。 虚拟内存的好处和坏处？ 虚拟内存的好处 扩大地址空间； 内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。 公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。 当进程通信时，可采用虚存共享的方式实现。 当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内 虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU 交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高 在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片 虚拟内存的代价： 虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存 虚拟地址到物理地址的转换，增加了指令的执行时间。 页面的换入换出需要磁盘I/O，这是很耗时的 如果一页中只有一部分数据，会浪费内存。 wait()函数 wait函数是用来及时回收我们的进程资源的。 进程一旦调用了wait函数，就立即阻塞自己本身，然后由wait函数自动分析当前进程的某个子进程是否已经退出，当找到一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞，直到有一个出现为止。函数原型如下： #include #include pid_t wait(int* status); 子进程的结束状态值会由参数status返回，而子进程的进程识别码也会一起返回。如果不需要结束状态值，则参数status可以设成 NULL。 fork()函数 fork函数用来创建一个子进程。对于父进程，fork()函数返回新创建的子进程的PID。对于子进程，fork()函数调用成功会返回0。如果创建出错，fork()函数返回-1。 答案解析 fork()函数，其原型如下： #include pid_t fork(void); fork()函数不需要参数，返回值是一个进程标识符PID。返回值有以下三种情况： （1） 对于父进程，fork()函数返回新创建的子进程的PID。 （2） 对于子进程，fork()函数调用成功会返回0。 （3） 如果创建出错，fork()函数返回-1。 fork()函数创建一个新进程后，会为这个新进程分配进程空间，将父进程的进程空间中的内容复制到子进程的进程空间中，包括父进程的数据段和堆栈段，并且和父进程共享代码段。这时候，子进程和父进程一模一样，都接受系统的调度。因为两个进程都停留在fork()函数中，最后fork()函数会返回两次，一次在父进程中返回，一次在子进程中返回，两次返回的值不一样，如上面的三种情况。 五种IO模型 IO（Input/Output，输入/输出）即数据的读取（接收）或写入（发送）操作。 通常用户进程中的一个完整IO分为两阶段：用户进程空间与内核空间之间的相互切换、内核空间与设备空间的相互切换（磁盘、网络等）。我们通常说的IO是指网络IO和磁盘IO两种。 Linux中进程无法直接操作I/O设备，其必须通过系统调用请求内核来协助完成I/O动作；内核会为每个I/O设备维护一个缓冲区。 对于一个输入操作来说，进程IO系统调用后，内核会先看缓冲区中有没有相应的缓存数据，没有的话再到设备中读取，因为设备IO一般速度较慢，需要等待；内核缓冲区有数据则直接复制到进程空间。 所以，对于一个网络输入操作通常包括两个不同阶段： 等待网络数据到达网卡→读取到内核缓冲区，数据准备好； 从内核缓冲区复制数据到进程空间。 5种IO模型如下： 阻塞IO：进程发起IO系统调用后，进程被阻塞，转到内核空间处理，整个IO处理完毕后返回进程。操作成功则进程获取到数据。调用者将一直等待，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。 非阻塞IO：进程发起IO系统调用后，进程被阻塞，内核数据还没好，不想让进程等待，就返回一个错误，这样进程就不阻塞了。进程每隔一段时间就发起IO系统调用去检查IO事件是否就绪。这样就实现非阻塞了。每个进程都有一个时间片，轮询的时候读取IO，时间片到了就要换另一个进程做其他事情了，这样就做到了每隔一段时间发起IO系统调用。 IO多路复用：Linux用select/poll函数实现IO复用模型，这两个函数也会使进程阻塞，但是和阻塞IO所不同的是这两个函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检查。select/poll会监听所有的IO，直到有数据可读或可写时，才真正调用IO操作函数。 信号驱动IO：Linux用套接口进行信号驱动IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到SIGIO信号，然后处理IO事件。这个好理解，这个信号直接通知进程数据到了。 异步IO：进程发起IO系统调用后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序。用户可以直接去使用数据。具体操作是进程调用aio_read函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回。 前四种属于同步IO，原因就在于进程发起IO系统调用读取数据时，这个真正拿到数据的过程依然是阻塞的，直到完成数据读取还要把数据拷贝到用户空间中，进程才能继续做其他事。 而异步IO就不一样了，进程完全做自己的事情，数据都不需要它读取，而是由内核读取数据并将数据拷贝到缓冲区后，再通知应用程序。用户可以直接去使用数据。 同步与异步的区别，阻塞与非阻塞的区别？ 同步与异步的区别： 同步：所有的操作都做完，才返回给用户结果。即写完数据库之后，再响应用户，用户体验不好。双方的动作是经过双方协调的，步调一致的。 异步：不用等所有操作都做完，就响应用户请求。即先响应用户请求，然后慢慢去写数据库，用户体验较好。双方并不需要协调，都可以随意进行各自的操作。 阻塞与非阻塞的区别： 阻塞：调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的检查这个函数有没有返回，必须等这个函数返回后才能进行下一步动作。 非阻塞：非阻塞等待，每隔一段时间就去检查IO事件是否就绪。没有就绪就可以做其他事情。 多路IO复用技术有哪些，区别是什么？ select，poll，epoll都是IO多路复用的机制，I/O多路复用就是通过一种机制，可以监视多个文件描述符，一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作。 区别： （1）poll与select不同，通过一个pollfd数组向内核传递需要关注的事件，故没有描述符个数的限制，pollfd中的events字段和revents分别用于标示关注的事件和发生的事件，故pollfd数组只需要被初始化一次。 （2）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。 （3）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把当前进程往设备等待队列中挂一次，而epoll只要一次拷贝，而且把当前进程往等待队列上挂也只挂一次，这也能节省不少的开销。 epoll的原理 epoll提供了三个函数，epoll_create、epoll_ctl和epoll_wait。 首先创建一个epoll对象，然后使用epoll_ctl对这个对象进行操作（添加、删除、修改），把需要监控的描述符加进去，这些描述符将会以epoll_event结构体的形式组成一颗红黑树，接着阻塞在epoll_wait，进入大循环，当某个fd上有事件发生时，内核将会把其对应的结构体放入一个链表中，返回有事件发生的链表。 epoll和select的区别，epoll为什么高效？ 区别： （1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；而epoll保证了每个fd在整个过程中只会拷贝一次。 （2）每次调用select都需要在内核遍历传递进来的所有fd；而epoll只需要轮询一次fd集合，同时查看就绪链表中有没有就绪的fd就可以了。 （3）select支持的文件描述符数量太小了，默认是1024；而epoll没有这个限制，它所支持的fd上限是最大可以打开文件的数目，这个数字一般远大于2048。 epoll为什么高效： （1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。 （2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把当前进程往设备等待队列中挂一次，而epoll只要一次拷贝，而且把当前进程往等待队列上挂也只挂一次，这也能节省不少的开销。 epoll水平触发与边缘触发的区别？ LT模式（水平触发）下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作； 而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读。 线程池的设计思路，线程池中线程的数量由什么确定？ 设计思路： 实现线程池有以下几个步骤： （1）设置一个生产者消费者队列，作为临界资源。 （2）初始化n个线程，并让其运行起来，加锁去队列里取任务运行 （3）当任务队列为空时，所有线程阻塞。 （4）当生产者队列来了一个任务后，先对队列加锁，把任务挂到队列上，然后使用条件变量去通知阻塞中的一个线程来处理。 线程池中线程数量： 线程数量和哪些因素有关：CPU，IO、并行、并发 如果是CPU密集型应用，则线程池大小设置为：CPU数目+1 如果是IO密集型应用，则线程池大小设置为：2*CPU数目+1 最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目 所以线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。 为什么要创建线程池： 创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。同时线程池也是为了提升系统效率。 线程池的核心线程与普通线程： 任务队列可以存放100个任务，此时为空，线程池里有10个核心线程，若突然来了10个任务，那么刚好10个核心线程直接处理；若又来了90个任务，此时核心线程来不及处理，那么有80个任务先入队列，再创建核心线程处理任务；若又来了120个任务，此时任务队列已满，不得已，就得创建20个普通线程来处理多余的任务。 Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-05-04 22:13:34 "},"linux常用命令.html":{"url":"linux常用命令.html","title":"Linux命令","keywords":"","body":" 0 - 文件和目录常用命令 1 - chmod 权限 who(用户类型) operator(符号模式表) permission(权限) 常见的数字权限 2 - grep 搜索内容 3 - find 搜索文件 4 - cat、more、tail 显示文本文件内容 5 - 进程管理 6 - 网络 7 - 系统服务 8 - 其他 0 - 文件和目录常用命令 pwd查看当前所在目录 cd ~ # 进入当前用户主目录 cd .. # 进入上级目录 cd / # 进入系统根目录 ls -a # 列出目录下所有文件和目录 ls -l # 等同于ll 将文件的名字、权限、所有者、文件大小等信息详细列出来 touch 新建文件命令 mkdir 创建一个空目录 rm -f # 强制删除 rm -r # 删除目录和目录里所有文件 rm -rf /* # 删库跑路 mv a.txt b.txt # 修改文件名 mv b.txt ../ # 将文件移动到上级目录 cp 源文件 目标文件（夹） # 复制一个源文件到目标文件（夹） cp -r 源文件夹 目标文件夹 # 复制源文件夹到目标文件夹下 cp -u 源文件 目标文件 # 只有源文件较目标文件新时复制。 1 - chmod 权限 Linux系统中一切都是文件。Linux使用不同的字符来区分不同的文件： 普通文件 目录文件 链接文件 块设备文件 字符设备文件 管道文件 - d l b c p 每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。 文件权限的数字表示法基于字符（rwx）的权限计算而来，其目的是简化权限的表示方式。例如，若某个文件的权限为7，则代表可读、可写、可执行（4+2+1）；若权限为6，则代表可读、可写（4+2）。 chmod who operator permission file` 如`chmod u+x rumenz.txt who(用户类型) who 用户类型 说明 u user 文件所有者 g group 文件所有者所在组 o others 所有其他用户 a all 所用用户, 相当于 ugo operator(符号模式表) Operator 说明 + 为指定的用户类型增加权限 - 去除指定用户类型的权限 = 设置指定用户权限的设置，即将用户类型的所有权限重新设置 permission(权限) 模式 名字 说明 r 读 设置为可读权限 w 写 设置为可写权限 x 执行权限 设置为可执行权限 常见的数字权限 400 -r———— 拥有者能够读，其他任何人不能进行任何操作； 644 -rw-r—r— 拥有者都能够读，但只有拥有者可以编辑； 660 -rw-rw—— 拥有者和组用户都可读和写，其他人不能进行任何操作； 664 -rw-rw-r— 所有人都可读，但只有拥有者和组用户可编辑； 700 -rwx——— 拥有者能够读、写和执行，其他用户不能任何操作； 744 -rwxr—r— 所有人都能读，但只有拥有者才能编辑和执行； 755 -rwxr-xr-x 所有人都能读和执行，但只有拥有者才能编辑； 777 -rwxrwxrwx 所有人都能读、写和执行（该设置通常不是好想法）。 对文件test赋权chmod 777 test或对一个目录赋权要加 -R，递归执行，如对yzj目录执行赋权，chmod -R 777 yzj 2 - grep 搜索内容 grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 格式：grep [选项] ”模式“ [文件] 内容和文件名均可写作正则表达式 -i：在搜索的时候忽略大小写 -n：显示结果所在行号 -c：统计匹配到的行数，注意，是匹配到的总行数，不是匹配到的次数 -o：只显示符合条件的字符串，但是不整行显示，每个符合条件的字符串单独显示一行 -v：输出不带关键字的行（反向查询，反向匹配） -w：匹配整个单词，如果是字符串中包含这个单词，则不作匹配 -Ax：在输出的时候包含结果所在行之后的指定行数，这里指之后的x行，A：after -Bx：在输出的时候包含结果所在行之前的指定行数，这里指之前的x行，B：before -Cx：在输出的时候包含结果所在行之前和之后的指定行数，这里指之前和之后的x行，C：context -e：实现多个选项的匹配，逻辑or关系 -P：表示使用兼容perl的正则引擎。 -E：使用扩展正则表达式，而不是基本正则表达式，在使用\"-E\"选项时，相当于使用egrep。 3 - find 搜索文件 find 搜索路径 [选项] 搜索内容 -name 通过文件名字来查找 find . -name a.cpp # 从当前目录搜索 4 - cat、more、tail 显示文本文件内容 cat 文件名：cat命令一次显示整个文件的内容 more 文件名：more命令分页显示文件的内容，按空格键显示下一页，按b键显上一页，按q键退出。 tail -f 文件名：tail -f用于显示文本文件的最后几行，如果文件的内容有增加，就实时的刷新。对程序员来说，tail -f极其重要，可以动态显示后台服务程序的日志，用于调试和跟踪程序的运行。 5 - 进程管理 常用命令 作用 ps -ef 查看所有进程 ps -ef \\ grep expression 用正则表达式过滤出所需要的进程 kill -s name kill指定名称进程 kill -s pid kill指定pid的进程 top 实时显示进程状态 iostate 查看io读写/cpu使用情况 sar -u 1 10 查询cpu使用情况（1秒1次，共10次） sar -d 1 10 查询磁盘性能 6 - 网络 常用命令 作用 ifconfig 查看网络接口属性 ip addr 查看ip地址 ipconfig eh0 192.168.1.1 netmask 255.255.255.255 配置ip地址 netstat 查看各种网络相关信息 netstat -lntp 查看所有监听端口 netstat -antp 查看已经建立的TCP连接 netstat -lutp 查看TCP/UDP的状态信息 route -n 查看路由表 7 - 系统服务 常用命令 作用 systemctl status 查看某个服务 systemctl start 启动某个服务 systemctl stop 终止某个服务 systemctl restart 重启某个服务 systemctl enable 开启自启动 systemctl disable 关闭自启动 chkconfig --list 列出系统服务 使用systemctl命令 配置防火墙的过程如下 查看防火墙的命令： 1）查看防火墙的版本。firewall-cmd --version 2）查看firewall的状态。firewall-cmd --state 3）查看firewall服务状态（普通用户可执行）。systemctl status firewalld 4）查看防火墙全部的信息。firewall-cmd --list-all 5）查看防火墙已开通的端口。firewall-cmd --list-port 6）查看防火墙已开通的服务。firewall-cmd --list-service 7）查看全部的服务列表（普通用户可执行）。firewall-cmd --get-services 8）查看防火墙服务是否开机启动。 systemctl is-enabled firewalld 配置防火墙的命令： 1）启动、重启、关闭防火墙服务。 systemctl start firewalld # 启动 systemctl restart firewalld # 重启 systemctl stop firewalld # 关闭 2）开放、移去某个端口。 firewall-cmd --zone=public --add-port=80/tcp --permanent # 开放80端口 firewall-cmd --zone=public --remove-port=80/tcp --permanent # 移去80端口 3）开放、移去范围端口。 firewall-cmd --zone=public --add-port=5000-5500/tcp --permanent # 开放5000-5500之间的端口 firewall-cmd --zone=public --remove-port=5000-5500/tcp --permanent # 移去5000-5500之间的端口 4）开放、移去服务。 firewall-cmd --zone=public --add-service=ftp --permanent # 开放ftp服务 firewall-cmd --zone=public --remove-service=ftp --permanent # 移去http服务 5）重新加载防火墙配置（修改配置后要重新加载防火墙配置或重启防火墙服务）。 firewall-cmd --reload 6）设置开机时启用、禁用防火墙服务。 systemctl enable firewalld # 启用服务 systemctl disable firewalld # 禁用服务 8 - 其他 tar -xvf xxx.tar 解压tar包 (1) .tar 用 tar –xvf 解压 (2) .gz 用 gzip -d或者gunzip 解压 (3) .tar.gz和.tgz 用 tar –xzf 解压 (4) .bz2 用 bzip2 -d或者用bunzip2 解压 (5) .tar.bz2用tar –xjf 解压 (6) .Z 用 uncompress 解压 (7) .tar.Z 用tar –xZf 解压 (8) .rar 用 unrar e解压 (9) .zip 用 unzip 解压 (10) .xz 用 xz -d 解压 (11) .tar.xz 用 tar -zJf 解压 Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-05-03 13:21:27 "},"计算机网络.html":{"url":"计算机网络.html","title":"计算机网络","keywords":"","body":" 计算机网络有哪两种通信方式？ 什么是分组交换？优缺点 TCP/IP 体系结构 应用层 传输层 网络层 数据链路层 TCP UDP区别？ TCP头部结构 TCP建立（三次握手） TCP关闭（四次挥手） 两次握手不可以： 四次挥手的原因： TIME_WAIT的作用 TCP状态转移图 TCP的可靠机制 TCP超时重传 拥塞控制 Session和cookie的区别？ TCP 粘包 什么是Nagle算法 怎么解决拆包和粘包？ 为什么UDP不粘包 HTTP HTTP请求方法 get和post的区别是什么？ 概括： 区别： HTTP状态码 HTTP的无连接是什么意思？ HTTP的无状态是什么意思？ 说一说 HTTP1.0、HTTP1.1、HTTP2.0的区别？ HTTP1.0 HTTP1.1 HTTP2.0 HTTP 和 HTTPS 的区别？ HTTPS 优点： HTTPS 缺点： HTTPS的通信建立过程 在浏览器输入URL地址到显示主页的过程？ 什么是数字签名？ 什么是数字证书？ 什么是洪泛攻击？怎么避免？ 如何应对短连接、高并发的场景？ 计算机网络有哪两种通信方式？ 第一种方式：客户-服务器方式。这种传统的方式是互联网上最常见的方式。客户是服务请求方，服务器是服务提供方。 C/S模型有一个特例，那就是B/S（Browse/Server）模型，即浏览器／服务器模式，也叫B/S结构。它只安装维护一个服务器（Server），而客户端采用浏览器（Browse）运行软件。B/S结构是随着Internet技术的兴起，对C/S结构的变化和改进。它和C/S并没有本质区别。 第二种通信方式：对等连接（P2P）方式。是指两台主机在通信时并不区分哪一个是服务请求方哪一个是服务提供方。只要两台主机都运行了对等连接软件（P2P软件），他们就可以进行对等连接通信。 什么是分组交换？优缺点 分组交换采用存储转发技术，把一个报文划分为几个分组后再进行传送。分组的首部非常重要，包含了目的地址和源地址等重要控制信息，这样每一个分组才能在互联网中独立地选择传输路径，并被正确地交付到分组传输的终点。 优点： （1）高效，在分组传输时动态分配带宽，对通信链路逐段占用。 （2）灵活，为每一个分组独立地选择最合适的转发路由。 （3）迅速，以分组为单位，可以不先建立连接就能向主机发送数据。 （4）可靠，分布式多路由的分组交换网，使传输鲁棒性强。 缺点： （1）分组在路由器存储转发时需要排队，有时延。 （2）分组必须携带控制信息（头部）也造成了开销。 TCP/IP 体系结构 应用层 任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义了应用进程间通信和交互的规则。 HTTP：超文本传输协议，在浏览器与服务器间传送文档。 DNS（Domain Name Service，域名服务）协议提供机器域名到IP地址的转换。 DNS是一套分布式的域名服务系统。每个DNS服务器上都存放着大量的机器名和IP地址的映射，并且是动态更新的。众多网络客户端程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。 SMTP协议：简单邮件传送协议 FTP协议：文件传输协议 RIP 协议：距离矢量路由选择协议。 传输层 任务是为两台主机中进程之间的通信提供通用的数据传输服务。 TCP协议（Transmission Control Protocol，传输控制协议）为应用层提供可靠的、面向连接的和基于流（stream）的服务。 UDP协议（User Datagram Protocol，用户数据报协议）则与TCP协议完全相反，它为应用层提供不可靠、无连接和基于数据报的服务。 网络层 任务是负责为分组交换网上的不同主机提供通信服务。 IP协议：IP协议根据数据包的目的IP地址来决定如何投递它，使用逐跳（hop by hop）的方式确定通信路径。（1） 寻址。（2） 路由选择。（3） 分段与组装。 ICMP协议：是IP协议的重要补充，主要用于检测网络连接。 数据链路层 两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要专门的链路层协议。 ARP协议：ARP地址解析协议用于将计算机的网络地址（IP地址32位）转化为物理地址（MAC地址48位） 原理：主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。此网络上的其他机器都将收到这个请求，但只有被请求的目标机器会回应一个ARP应答，其中包含自己的物理地址。ARP维护一个高速缓存，其中包含经常访问（比如网关地址）或最近访问的机器的IP地址到物理地址的映射。这样就避免了重复的ARP请求，提高了发送数据包的速度。 RARP协议：RARP协议（Reverse ARP，反向ARP协议），其功能是将MAC地址解析为对应的IP地址。 TCP UDP区别？ （1）连接： TCP 是面向连接的传输层协议，即传输数据之前必须先建立好连接。 UDP是无连接的。 （2）服务对象： TCP 是点对点的两点间服务，即一条 TCP 连接只能有两个端点; UDP 支持一对一，一对多，多对一，多对多的交互通信。 （3）可靠性： TCP 是可靠交付:无差错，不丢失，不重复，按序到达。 UDP 是尽最大努力交付，不保证可靠交付。 （4）拥塞控制，流量控制： TCP 有拥塞控制和流量控制保证数据传输的安全性。 UDP 没有拥塞控制，网络拥塞不会影响源主机的发送效率。 （5) 报文长度： TCP 是动态报文长度，即 TCP 报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。 UDP 面向报文，不合并，不拆分，保留上面传下来报文的边界。 （6）首部开销： TCP 首部开销大，首部 20 个字节。 UDP 首部开销小，8 字节。(源端口，目的端口，数据长度，校验和) （7）TCP传输速度比UDP慢，TCP是重量级协议、UDP是轻量级协议 TCP头部结构 32位序号（sequence number）：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。序号值被系统初始化为某个随机值ISN（Initial Sequence Number，初始序号值）。 32位确认号（acknowledgement number）：用作对另一方发送来的TCP报文段的响应。其值是收到的TCP报文段的序号值加1。 4位头部长度（header length）：标识该TCP头部有多少个32bit字（4字节）。 标识位： URG标志，表示紧急指针（urgent pointer）是否有效。 ACK标志，表示确认号是否有效。称携带ACK标志的TCP报文段为确认报文段。 PSH标志，提示接收端应用程序应该立即从TCP接收缓冲区中读走数据，为接收后续数据腾出空间。 RST标志，表示要求对方重新建立连接。称携带RST标志的TCP报文段为复位报文段。 SYN标志，表示请求建立一个连接。称携带SYN标志的TCP报文段为同步报文段。 FIN标志，表示通知对方本端要关闭连接了。称携带FIN标志的TCP报文段为结束报文段。 16位窗口大小（window size）：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口（Receiver Window，RWND）。 16位校验和（TCP checksum）：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。 16位紧急指针（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。 RST 产生复位报文段的3种情况: 访问不存在的端口 异常终止连接 处理半打开连接 TCP建立（三次握手） Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，等待Server确认。此时客户端进入SYN-SENT（同步已发送） 状态。 SYN报文段（即SYN=1的报文段）不能携带数据，但要消耗一个序号 Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置1，ack=J+1，随机产生一个值seq=K，并将该数据包发给Client以确认连接请求。这时TCP服务器进行进入SYN-RCVD（同步收到）状态。 同理，此报文段也不能携带数据。 Client收到确认后，检测ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server。完成三次握手，客户端进入ESTABLISHED（已建立连接）状态。当服务器收到客户端的确认后，也进入ESTABLISHED（已建立连接）状态。 TCP标准规定，ACK报文段可以携带数据，但如果不携带数据则不消耗序号 TCP关闭（四次挥手） 客户端向服务器发送一个FIN报文，首部的FIN=1，同时报文给自己指定一个序号（m），此时客户端进入FIN_WAIT_1 （终止等待1）状态，但客户端依然可以接收服务器发送来的数据。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 服务端收到了客户端的FIN报文，会发送ACK报文进行确认，把收到报文的序列号的值+1（m+1）作为ACK报文的序列号的值，表明已经收到了客户端的报文，服务器进入CLOSE-WAIT（关闭等待）状态 TCP服务器进程这时应通知高层应用程序，客户端到服务端这个方向的连接就释放了，此时TCP连接处于半关闭（HALF-CLOSE）状态，即客户端已经没有数据要发送了，但服务器若发送数据，客户端仍要接收。客户端收到服务端的确认后，进入FIN-WAIT-2（终止等待2）状态。等待服务端发出的连接释放报文段。 当服务器没有数据要发送了，也想要断开连接，会给客户端发送FIN报文，且指定一个序列号（n），服务器进入了LAST-ACK（最后确认）状态。 客户端收到FIN之后，一样会发送一个ACK报文作为应答，且把服务端的序号+1（n+1）作为自己ACK报文的序号。然后进入TIME-WAIT（时间等待）状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。 两次握手不可以： TCP 是全双工通信，两次握手只能确定单向数据链路是可以通信的，并不能保证反向的通信正常 详细解释： 这个问题的本质是：在信道不可靠的情况下, 通信双发需要就某个问题达成一致. 需要几次通信？ 对于此问题，无论在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足\"在不可靠信道上可靠地传输信息\"这一需求所导致的 具体来说： TCP连接的双方要确保各自的收发消息的能力都是正常的。 客户端第一次发送握手消息到服务端，服务端接收到握手消息后把ack和自己的syn一同发送给客户端，这是第二次握手，当客户端接收到服务端发送来的第二次握手消息后，客户端可以确认“服务端的收发能力OK，客户端的收发能力OK”，但是服务端只能确认“客户端的发送OK，服务端的接收OK”， 所以还需要第三次握手，客户端收到服务端的第二次握手消息后，发起第三次握手消息，服务端收到客户端发送的第三次握手消息后，就能够确定“服务端的发送OK，客户端的接收OK”， 至此，客户端和服务端都能够确认自己和对方的收发能力OK，TCP连接建立完成。 四次挥手的原因： 因为当处于LISTEN状态的服务器端收到来自客户端的SYN报文(客户端希望新建一个TCP连接)时，它可以把ACK(确认应答)和SYN(同步序号)放在同一个报文里来发送给客户端。但在关闭TCP连接时，当收到对方的FIN报文时，对方仅仅表示对方已经没有数据发送给你了，但是自身可能还有数据需要发送给对方，则等你发送完剩余的数据给对方之后，再发送FIN报文给对方来表示你数据已经发送完毕，并请求关闭连接，所以通常情况下，这里的ACK报文和FIN报文都是分开发送的。 TIME_WAIT的作用 2MSL（MaximumSegment Life，报文段最大生存时间） 保证最后一次握手报文能到服务器，能进行超时重传。 2MSL 后，这次连接的所有报文都会消失，不会影响下一次连接。 缺点： 第一是内存资源占用，但不是很严重，基本可以忽略。 第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口。端口资源也是有限的，一般可以开启的端口为 32768～61000 ，也可以通过net.ipv4.ip_local_port_range指定，如果 TIME_WAIT 状态过多，会导致无法创建新连接。 TCP状态转移图 TCP的可靠机制 TCP超时重传 TCP可靠性中最重要的一个机制是处理数据超时和重传。TCP协议要求在发送端每发送一个报文段，就启动一个定时器并等待确认信息；接收端成功接收新数据后返回确认信息。若在定时器超时前数据未能被确认，TCP就认为报文段中的数据已丢失或损坏，需要对报文段中的数据重新组织和重传。 拥塞控制 包含四个部分慢启动（slow start）、拥塞避免（congestion avoidance）、快速重传（fast retransmit）和快速恢复（fast recovery）。 SWND（Send Window，发送窗口 ）、SMSS（Sender Maximum SegmentSize，发送者最大段大小）、接收通告窗口（RWND）、拥塞窗口（CongestionWindow，CWND） 慢启动：CWND将按照指数形式扩大。慢启动算法的理由是，TCP模块刚开始发送数据时并不知道网络的实际情况，需要用一种试探的方式平滑地增加CWND的大小。（cwnd *2） 拥塞避免：慢启动门限（slow start threshold size，ssthresh）。当CWND的大小超过该值时（一般设为65536），TCP拥塞控制将进入拥塞避免阶段，拥塞窗口的值不再指数上升，而是加法增加。（cwnd +1） 快速恢复：当发送方知道只是丢失了个别的报文段，不会启动慢开始算法，而是执行快恢复算法。将阈值设为当前窗口大小的一半，同时设置拥塞窗口为阈值的大小，然后执行拥塞避免算法。 快速重传：发送方只要一连收到3个重复确认，就知道接收方没有收到应当立即进行快重传，这样就不会出现超时。 如何判断拥塞？ 传输超时，或者说TCP重传定时器溢出。采用慢启动和拥塞避免 接收到重复的确认报文段。采用快速重传和快速恢复 Session和cookie的区别？ Cookie的工作原理 （1）浏览器端第一次发送请求到服务器端 （2）服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端 （3）浏览器端再次访问服务器端时会携带服务器端创建的Cookie （4）服务器端通过Cookie中携带的数据区分不同的用户 Session的工作原理 （1）浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个特殊的Cookie（name为JSESSIONID的固定值，value为session对象的ID），然后将该Cookie发送至浏览器端 （2）浏览器端发送第N（N>1）次请求到服务器端,浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象 （3）服务器端根据name为JSESSIONID的Cookie的value(sessionId),去查询Session对象，从而区分不同用户。 区别： 1、数据存放位置不同：cookie数据存放在客户的浏览器上，session数据放在服务器上。 2、安全程度不同：cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。 3、性能使用程度不同：session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。 4、数据存储大小不同：单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，而session则存储与服务端，浏览器对其没有限制。 5、会话机制不同 session会话机制：session会话机制是一种服务器端机制，它使用类似于哈希表（可能还有哈希表）的结构来保存信息。 cookies会话机制：cookie是服务器存储在本地计算机上的小块文本，并随每个请求发送到同一服务器。 Web服务器使用HTTP标头将cookie发送到客户端。在客户端终端，浏览器解析cookie并将其保存为本地文件，该文件自动将来自同一服务器的任何请求绑定到这些cookie。 TCP 粘包 如果客户端连续不断的向服务端发送数据包时，服务端接受的数据会出现两个数据报粘在一起的情况。 接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出一块，这种情况即发生了拆包和粘包 由Nagle算法造成的发送端粘包。Nagle算法是一种改善网络传输效率的算法，但也可能造成困扰。这就造成了粘包。 接收端接收不及时造成的接收端粘包。TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时取出TCP的数据，就会造成TCP缓冲区中存放多段数据。 什么是Nagle算法 Nagle算法简单的说，当提交一段数据给TCP时，TCP并不立刻发送此段数据，而是等待一段时间，看看在等待期间是否还有要发送的数据，若有则会一次把多段数据发送出去。 怎么解决拆包和粘包？ 分包机制一般有两个通用的解决方法： 特殊字符控制 在包头首部添加数据包的长度 如果使用netty框架的话，就有专门的编码器和解码器解决拆包和粘包的问题了 为什么UDP不粘包 对于UDP，不会使用块的合并优化算法，不存在封包，再加上UDP本身是一个“数据包“协议，也就是两段数据是有界限的。从TCP和UDP的头部结构体就可以很明显的看到，UDP头部是记录了数据的长度的，而TCP头部里面并没有记录数据长度的变量。 HTTP HTTP 协议是 Hyper Text Transfer Protocol(超文本传输协议)的缩写，是用于从万维网(WWW:World Wide Web)服务器传输超文本到本地浏览器的传送协议。 HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。 HTTP请求方法 get和post的区别是什么？ 概括： 对于GET 方式的请求，浏览器会把http header 和data 一并发送出去，服务器响应200（返回数据） 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据） 区别： （1）get 参数通过 url 传递，post 放在 request body 中。 （2）get 请求在 url 中传递的参数是有长度限制的，而 post 没有。 （3）get 比 post 更不安全，因为参数直接暴露在 url 中，所以不能用来传递敏感信息。 （4）get 请求只能进行 url 编码，而 post 支持多种编码方式。 （5）get 请求会浏览器主动 cache，而 post 支持多种编码方式。 （6）get 请求参数会被完整保留在浏览历史记录里，而post 中的参数不会被保留。 （7）GET 和POST 本质上就是TCP 连接，并无差别。但是由于HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 （8）GET 产生一个TCP 数据包；POST 产生两个TCP 数据包。 HTTP状态码 HTTP的无连接是什么意思？ 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 HTTP的无状态是什么意思？ 无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是，发送完，不会记录任何信息。 说一说 HTTP1.0、HTTP1.1、HTTP2.0的区别？ HTTP1.0 HTTP1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接。就像打电话一样，一次只能说一件事，说完就要挂断，又因为TCP连接建立一次需要三次握手，所以效率很低。 如果不想断开连接，需要在HTTP相应的Connection字段指定为keep-live connection:keep-alive; HTTP1.1 HTTP1.1引进了持久连接，TCP连接默认不关闭，可以被多个请求复用。客户端和服务端发现对方一段时间没有活动后，可以主动关闭连接；或者客户端在最后一个请求时，主动告诉服务端要关闭连接。 HTTP1.0就像打一次电话只能说一次事，HTTP1.1是打完电话先不直接挂断，而是持续一会，这期间如果有事情还可以再次沟通。 HTTP1.1还引入了管道机制，即在同一个TCP连接里，客户端可以同时发送多个请求，这样就进一步改进了HTTP协议的效率。 HTTP2.0 HTTP2.0采用了多路复用，即在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按顺序一一对应。能这样做有一个前提，就是HTTP2.0进行了二进制分帧，即会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码。 负责这个拆分、组装请求和二进制帧的一层就叫做二进制分帧层 也就是说，老板可以同时下达多个命令，员工也可以收到请求A和请求B，于是先回应A，结果发现处理A非常耗时，于是就发送A请求已经处理好的部分，接着回应B请求，完成后 ，再发送A请求剩下的部分。A请求的两部分响应再组合到一起发送给老板 除此之外还有一些其他的优化，比如Header压缩、服务端推送等 Header压缩就是压缩老板和员工之间的对话 服务端推送就是员工事先把一些老板可能询问的事情提前发送到老板的手机上（缓存）。这样老板想要知道的时候就可以直接读取短信（缓存）了。 HTTP 和 HTTPS 的区别？ HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer）：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下+SSL，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 开销：HTTPS协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。 端口不同：HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 安全性：HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。 资源消耗：HTTP是超文本传输协议，信息是明文传输；HTTPS则是具有安全性的SSL加密传输协议，需要消耗更多的CPU和内存资源 在OSI模型中，HTTP工作于应用层，而HTTPS工作于传输层； HTTPS 优点： HTTPS 传输数据过程中使用密钥进行加密，所以安全性更高 HTTPS 协议可以认证用户和服务器，确保数据发送到正确的用户和服务器 HTTPS 缺点： HTTPS 握手阶段延时较高：由于在进行HTTP 会话之前还需要进行SSL 握手，因此HTTPS 协议握手阶段延时增加 HTTPS 部署成本高：一方面HTTPS 协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS 协议需要进行加解密的计算，占用CPU 资源较多。 ps：对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥是真是假。为了保证发送方的公钥是真的，CA证书机构会负责颁发一个证书，里面的公钥确保是真的，用户请求服务器时，服务器将证书给用户，这个证书是经由系统内置证书的备案过的。 HTTPS的通信建立过程 在使用HTTPS是需要保证服务端配置正确了对应的安全证书 客户端发送请求到服务端 服务端返回公钥和数字证书到客户端 客户端接收后会验证证书的安全性，如果通过，则会随机生成一个随机数，用公钥对其加密，发送到服务端 服务端接受到这个加密后的随机数后，会用私钥对其解密得到真正的随机数，随后用这个随机数当做对称加密密钥对需要发送的数据进行对称加密 客户端在接收到加密后的数据对称加密密钥与服务器通信。 SSL加密建立 在浏览器输入URL地址到显示主页的过程？ 大概过程： （1）浏览器向DNS 服务器请求解析该URL 中的域名所对应的IP 地址； （2）解析出IP 地址后，根据该IP 地址和默认端口80，和服务器建立TCP 连接； （3）浏览器发出读取文件（URL 中域名后面部分对应的文件）的HTTP 请求，该请求报文作为TCP 三次握手的第三个报文的数据发送给服务器； （4）服务器对浏览器请求作出响应，并把对应的html 文本发送给浏览器； （5）释放TCP 连接； （6）浏览器将该html 文本解析后显示网页内容； 细致过程（笔试原题，排序）： 1、浏览器输入URL，先解析URL地址是否合法 2、浏览器检查是否有缓存（浏览器缓存 - 系统缓存 - 路由器缓存）。如果有，直接显示。没有，进行（3） 3、在发送HTTP请求前，需要域名解析（DNS解析），解析获取对应的IP地址 4、浏览器向服务器发起TCP连接，进行TCP连接的三次握手 5、握手成功后，浏览器向服务器发送HTTP请求，请求数据包 6、服务器收到请求，进行处理后将数据发送给浏览器（请求报文作为TCP 三次握手的第三个报文的数据发送给服务器） 7、浏览器收到HTTP响应 8、浏览器解析响应，如果响应可以缓存则存入缓存 9、浏览器发送请求获取嵌入在HTML的资源（HTML、CSS、JS等），对于未知类型，会弹出对话框 10、浏览器发送异步请求 11、页面全部渲染结束显示网页 什么是数字签名？ 为了避免数据在传输过程中被替换，比如黑客修改了报文内容，但是用户并不知道，所以需要让发送端做一个数字签名，把数据的摘要信息进行一个加密，比如MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行MD5加密，如果和签名一样，则说明数据是正确的 什么是数字证书？ 对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥是真是假。为了保证发送方的公钥是真的，CA证书机构会负责颁发一个证书，里面的公钥确保是真的，用户请求服务器时，服务器将证书给用户，这个证书是经由系统内置证书的备案过的。 什么是洪泛攻击？怎么避免？ A（攻击者）发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当这个服务器返回ACK以后，A不再进行确认，那这个连接就处在了一个挂起的状态，也就是半连接的意思，那么服务器收不到再确认的一个消息，还会重复发送ACK给A。 这样一来就会更加浪费服务器的资源。A就对服务器发送非法大量的这种TCP连接，由于每一个都没法完成握手的机制，所以它就会消耗服务器的内存最后可能导致服务器死机，就无法正常工作了。更进一步说，如果这些半连接的握手请求是恶意程序发出，并且持续不断，那么就会导致服务端较长时间内丧失服务功能——这样就形成了DoS攻击。这种攻击方式就称为SYN泛洪攻击。 避免方法： 最常用的一个手段就是优化主机系统设置。 （1）比如降低SYN timeout时间，使得主机尽快释放半连接的占用。 （2）或者采用SYN cookie设置，就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，以后从这个IP地址来的包会被丢弃。Cookie是当浏览某网站时，由Web服务器置于硬盘上一个非常小的文本文件，用来记录用户ID，密码，浏览过的网页，停留时间等信息。当我们认为受到了攻击，合理的采用*设置等外部网络进行拦截。 （3）使用长连接。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。 如何应对短连接、高并发的场景？ 针对于大量短连接同时高并发的情况： 最常用的一个手段就是优化主机系统设置。 （1）比如降低SYN timeout时间，使得主机尽快释放半连接的占用。 （2）或者采用SYN cookie设置，就是给每一个请求连接的IP地址分配一个Cookie，如果短时间内连续受到某个IP的重复SYN报文，就认定是受到了攻击，以后从这个IP地址来的包会被丢弃。Cookie是当浏览某网站时，由Web服务器置于硬盘上一个非常小的文本文件，用来记录用户ID，密码，浏览过的网页，停留时间等信息。当我们认为受到了攻击，合理的采用*设置等外部网络进行拦截。 （3）使用长连接。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。 而针对于服务器高并发的场景，有以下处理手段： （1）采用多IO复用模型，如select、epoll，甚至采用异步IO （2）采用队列进行削峰、缓存 （3）采用多服务器负载均衡手段 （4）数据库层面我们可以采用分库分表、读写分离等措施。 （5）还可以采用缓存的方式 Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-05-02 20:25:22 "},"剑指offer（第二版）.html":{"url":"剑指offer（第二版）.html","title":"剑指offer","keywords":"","body":" 链表 06. 从尾到头打印链表 18. 删除链表的节点 22. 链表中倒数第k个节点 24. 反转链表 25. 合并两个排序的链表 35. 复杂链表的复制 52. 两个链表的第一个公共节点 二叉树 二叉树的遍历 07. 重建二叉树 26. 树的子结构 27. 二叉树的镜像 28. 对称的二叉树 32 - I. 从上到下打印二叉树 32 - II. 从上到下打印二叉树 32 - III. 从上到下打印二叉树 33. 二叉搜索树的后序遍历序列 34. 二叉树中和为某一值的路径 36. 二叉搜索树与双向链表 37. 序列化二叉树 54. 二叉搜索树的第k大节点 55 - I. 二叉树的深度 55 - II. 平衡二叉树 68 - I. 二叉搜索树的最近公共祖先 68 - II. 二叉树的最近公共祖先 栈和队列 09. 用两个栈实现队列 30. 包含min函数的栈 31. 栈的压入、弹出序列 58 - I. 翻转单词顺序 59 - I. 滑动窗口的最大值 59 - II. 队列的最大值 堆 40. 最小的k个数 41. 数据流中的中位数 字符串 19. 正则表达式匹配 20. 表示数值的字符串 58 - II. 左旋转字符串 67. 把字符串转换成整数 哈希表 50. 第一个只出现一次的字符 56 - II. 数组中数字出现的次数II 57. 和为s的两个数字 位运算 15. 二进制中1的个数 56 - I. 数组中数字出现的次数I 64. 求1+2+…+n 65. 不用加减乘除做加法 图 12. 矩阵中的路径 13. 机器人的运动范围 动态规划 10- I. 斐波那契数列 10- II. 青蛙跳台阶问题 14- I. 剪绳子 14- II. 剪绳子 II 39. 数组中出现次数超过一半的数字 42. 连续子数组的最大和 46. 把数字翻译成字符串 47. 礼物的最大价值 60. n个骰子的点数 63. 股票的最大利润 贪心 45. 把数组排成最小的数 查找 04. 二维数组中的查找 53 - I. 在排序数组中查找数字I 53 - II. 0～n-1中缺失的数 排序 45. 把数组排成最小的数 双指针 21. 调整数组顺序使奇数位于偶数前面 48. 最长不含重复字符的子字符串 57 - II. 和为s的连续正数序列 回溯 38. 字符串的排列 数学 17. 打印从1到最大的n位数 43. 1～n 整数中 1 出现的次数 44. 数字序列中某一位的数字 49. 丑数 61. 扑克牌中的顺子 62. 圆圈中最后剩下的数字 其他 03. 数组中重复的数字 05. 替换空格 11. 旋转数组的最小数字 16. 数值的整数次方 29. 顺时针打印矩阵 51. 数组中的逆序对 66. 构建乘积数组 链表 //Definition for singly-linked list struct ListNode{ int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; 06. 从尾到头打印链表 法一：用栈解决 class Solution { public: vector reversePrint(ListNode* head){ ListNode *p=head; stack a; vector b; while(p!=nullptr){ a.push(p->val); p = p->next; } while(!a.empty()){ b.push_back(a.top()); a.pop(); } return b; } }; 法二：递归 class Solution { public: vector a; vector reversePrint(ListNode* head){ if (head!=nullptr){ if(head->next!=nullptr){ reversePrint(head->next); } a.push_back(head->val); } return a; } }; 18. 删除链表的节点 class Solution { public: ListNode* deleteNode(ListNode* head, int val) { ListNode *p = new ListNode; p->next=head; ListNode *cur = p; while(cur!=nullptr &&cur->next!=nullptr){ if(cur->next->val == val){ cur->next=cur->next->next; } cur=cur->next; } return p->next; } }; 22. 链表中倒数第k个节点 法一： class Solution { public: ListNode* getKthFromEnd(ListNode* head, int k) { int l = 0; ListNode *p=head; ListNode *q=head; while(p!=nullptr){ l++; p=p->next; } for(int i =0;inext; } return q; } }; 法二：快慢指针 p先走k步，然后p、q指针同时走，直到p走到尾后返回q。 class Solution { public: ListNode* getKthFromEnd(ListNode* head, int k) { ListNode *p = head; ListNode *q = head; for(int i=0;inext; } while(p!=nullptr){ p=p->next; q=q->next; } return q; } }; 24. 反转链表 法一：双指针 class Solution { public: ListNode* reverseList(ListNode* head) { ListNode *p=nullptr; ListNode *q=head; while(q!=nullptr){ ListNode *t = q->next; q->next=p; p=q; q=t; } return p; } }; 法二：递归 class Solution { public: ListNode* reverseList(ListNode* head) { return recur(head, nullptr); // 调用递归并返回 } private: ListNode* recur(ListNode* cur, ListNode* pre) { if (cur == nullptr) return pre; // 终止条件 ListNode* res = recur(cur->next, cur); // 递归后继节点 cur->next = pre; // 修改节点引用指向 return res; // 返回反转链表的头节点 } }; 25. 合并两个排序的链表 class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode *d=new ListNode(); ListNode *a=d; while(l1!=nullptr && l2!=nullptr){ if(l1->val>l2->val){ a->next=l2; l2=l2->next; } else{ a->next=l1; l1=l1->next; } a=a->next; } if(l1==nullptr){ a->next=l2; return d->next; } else{ a->next=l1; return d->next; } } }; 35. 复杂链表的复制 利用哈希表构建 class Solution { public: Node* copyRandomList(Node* head) { if(head==nullptr){ return head; } unordered_map ma; Node *p=head; while(p!=nullptr){ ma[p]=new Node(p->val); p=p->next; } p=head; while(p!=nullptr){ ma[p]->next=ma[p->next]; ma[p]->random=ma[p->random]; p=p->next; } return ma[head]; } }; 52. 两个链表的第一个公共节点 利用set集合查询是否为同一个节点，是则返回。 class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { unordered_set se; ListNode *p = headA; while(p!=nullptr){ se.insert(p); p=p->next; } ListNode *q = headB; while(q!=nullptr){ if(se.find(q)!=se.end()){ return q; } q=q->next; } return NULL; } }; 二叉树 //Definition for a binary tree node struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; 二叉树的遍历 题号：144、94、145 07. 重建二叉树 class Solution { public: unordered_map map; TreeNode* buildTree(vector& preorder, vector& inorder) { for(int i = 0;i & preorder, vector& inorder,int pre_root,int in_left,int in_right){ if(in_left > in_right) return NULL; TreeNode* root = new TreeNode(preorder[pre_root]); // 根节点在中序序列中的位置，用于划分左右子树的边界 int in_root = map[preorder[pre_root]]; // 左子树在前序中的根节点位于：pre_root+1,左子树在中序中的边界：[in_left,in_root-1] root->left = build(preorder,inorder,pre_root+1,in_left,in_root-1); // 右子树在前序中的根节点位于：根节点+左子树长度+1 = pre_root+in_root-in_left+1 // 右子树在中序中的边界：[in_root+1,in_right] root->right = build(preorder,inorder,pre_root+in_root-in_left+1,in_root+1,in_right); return root; } }; 26. 树的子结构 class Solution { public: bool isSubStructure(TreeNode* A, TreeNode* B) { return (A!=nullptr && B!=nullptr) && (digui(A,B) || isSubStructure(A->left,B) || isSubStructure(A->right,B)); } bool digui(TreeNode* A, TreeNode* B){ if(B==nullptr) return true; if(A==nullptr || A->val != B->val) return false; return digui(A->left,B->left) && digui(A->right,B->right); } }; 27. 二叉树的镜像 class Solution { public: TreeNode* mirrorTree(TreeNode* root) { digui(root); return root; } void digui(TreeNode *root){ if(root==nullptr){ return; } TreeNode *tmp=root->left; root->left=root->right; root->right=tmp; digui(root->left); digui(root->right); } }; 28. 对称的二叉树 class Solution { public: bool isSymmetric(TreeNode* root) { if(root == nullptr) return true; return digui(root->left,root->right); } bool digui(TreeNode *a,TreeNode *b){ if((a==nullptr && b==nullptr)) return true; if(a==nullptr || b==nullptr || a->val!=b->val) return false; return digui(a->left,b->right) && digui(b->left,a->right); } }; 32 - I. 从上到下打印二叉树 层序遍历 BFS（广度优先搜索），用队列（先入先出）解决。 class Solution { public: vector levelOrder(TreeNode* root) { vector res; if(root==nullptr) return res; queue q; q.push(root); while(q.size()){ TreeNode* node=q.front(); res.push_back(node->val); q.pop(); if(node->left!=nullptr) q.push(node->left); if(node->right!=nullptr) q.push(node->right); } return res; } }; 32 - II. 从上到下打印二叉树 class Solution { public: vector> levelOrder(TreeNode* root) { vector> a; queue q; if(root==nullptr) return a; q.push(root); while(q.size()){ int s=q.size(); vector b; for(int i=0;ival); q.pop(); if(t->left!=nullptr) q.push(t->left); if(t->right!=nullptr) q.push(t->right); } a.push_back(b); } return a; } }; 32 - III. 从上到下打印二叉树 class Solution { public: vector> levelOrder(TreeNode* root) { int cnt=1; vector> a; queue q; if(root==nullptr) return a; q.push(root); while(q.size()){ int s=q.size(); vector b; for(int i=0;ival); q.pop(); if(t->left!=nullptr) q.push(t->left); if(t->right!=nullptr) q.push(t->right); } if(cnt%2==0) reverse(b.begin(),b.end()); cnt++; a.push_back(b); } return a; } }; 33. 二叉搜索树的后序遍历序列 class Solution { public: bool verifyPostorder(vector& postorder) { return digui(postorder,0,postorder.size()-1); } bool digui(vector& postorder,int i,int j){ if(i>=j) return true; int p=i; while(postorder[p]postorder[j]) p++; return p==j && digui(postorder,i,m-1) &&digui(postorder,m,j-1); } }; 34. 二叉树中和为某一值的路径 回溯 class Solution { public: vector> pathSum(TreeNode* root, int target) { recur(root, target); return res; } private: vector> res; vector path; void recur(TreeNode *root, int tar) { if (root == nullptr) return; path.push_back(root->val); tar -= root->val; if (tar == 0 && root->left == nullptr && root->right == nullptr) { res.push_back(path); } recur(root->left, tar); recur(root->right, tar); path.pop_back(); } }; 36. 二叉搜索树与双向链表 二叉搜索树的中序遍历为 递增序列 class Solution { public: Node* treeToDoublyList(Node* root) { if(root == nullptr) return nullptr; dfs(root); head->left = pre; pre->right = head; return head; } private: Node *pre, *head; void dfs(Node* cur) { if(cur == nullptr) return; dfs(cur->left); if(pre != nullptr) pre->right = cur; //pre用于记录双向链表中位于cur左侧的节点，即上一次迭代中的cur,当pre==null时，cur左侧没有节点,即此时cur为双向链表中的头节点 ////反之，pre!=null时，cur左侧存在节点pre，需要进行pre.right=cur的操作。 else head = cur; cur->left = pre; pre = cur; dfs(cur->right); } }; 37. 序列化二叉树 层次遍历 54. 二叉搜索树的第k大节点 class Solution { public: vector a; int kthLargest(TreeNode* root, int k) { digui(root); return a[k-1]; } void digui(TreeNode* root){ if(root==nullptr) return; digui(root->right); a.push_back(root->val); digui(root->left); } }; 55 - I. 二叉树的深度 class Solution { public: int maxDepth(TreeNode* root) { if(root==nullptr) return 0; return max(maxDepth(root->left),maxDepth(root->right))+1; } }; 55 - II. 平衡二叉树 class Solution { public: bool isBalanced(TreeNode* root) { if(root==nullptr) return true; return abs(digui(root->left) - digui(root->right)) left) && isBalanced(root->right); } int digui(TreeNode *root){ if(root==nullptr) return 0; return max(digui(root->left),digui(root->right))+1; } }; 68 - I. 二叉搜索树的最近公共祖先 //分三种情况 1.都是左节点后代 2.都是右节点后代 3.分别是左右节点后代 class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(p->val > root->val &&q->val>root->val){ return lowestCommonAncestor(root->right,p,q); } if(p->val val &&q->valval){ return lowestCommonAncestor(root->left,p,q); } return root; } }; 68 - II. 二叉树的最近公共祖先 class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == nullptr || root==p || root==q) return root; // 如果树为空 或p和q中有等于 root的，那么它们的最近公共祖先即为root（一个节点也可以是它自己的祖先） TreeNode *left = lowestCommonAncestor(root->left,p,q); //递归遍历左子树 TreeNode *right = lowestCommonAncestor(root->right,p,q); //同理右子树 if(left==nullptr) return right; // 如果在左子树中 p和 q都找不到，则 p和 q一定都在右子树中，右子树中先遍历到的那个就是最近公共祖先（一个节点也可以是它自己的祖先） if(right==nullptr) return left; //同理 return root; //否则，当 left和 right均不为空时，说明 p、q节点分别在 root异侧, 最近公共祖先即为 root } }; 栈和队列 09. 用两个栈实现队列 30. 包含min函数的栈 class MinStack { public: /** initialize your data structure here. */ MinStack() { smin.push(INT_MAX); } void push(int x) { s.push(x); if(x s; stack smin; }; 31. 栈的压入、弹出序列 class Solution { public: bool validateStackSequences(vector& pushed, vector& popped) { stack s; int i =0; for(int a: pushed){ s.push(a); while(!s.empty() && s.top() == popped[i]){ s.pop(); i++; } } return s.empty(); } }; 58 - I. 翻转单词顺序 用栈麻烦，二次翻转或者getline class Solution { public: string reverseWords(string s) { stringstream iss(s); string ret=\"\"; string str; while(getline(iss,str,' ')) { if(str!=\"\") { if(ret==\"\") ret=str; else ret=str+\" \"+ret; } } return ret; } }; 59 - I. 滑动窗口的最大值 59 - II. 队列的最大值 堆 40. 最小的k个数 41. 数据流中的中位数 字符串 19. 正则表达式匹配 20. 表示数值的字符串 58 - II. 左旋转字符串 与189. 轮转数组相同 // nums = \"----->-->\"; k =3 // result = \"-->----->\"; // reverse \"----->-->\" we can get \"----->\" class Solution { public: string reverseLeftWords(string s, int n) { int k=s.size(); reverse(s.begin(),s.end()); reverse(s.begin(),s.begin()+k-n); reverse(s.begin()+k-n,s.end()); return s; } }; 67. 把字符串转换成整数 哈希表 50. 第一个只出现一次的字符 56 - II. 数组中数字出现的次数II 57. 和为s的两个数字 位运算 15. 二进制中1的个数 56 - I. 数组中数字出现的次数I 64. 求1+2+…+n 利用逻辑运算符的短路效应和递归。 if(A && B) // 若 A 为 false ，则 B 的判断不会执行（即短路），直接判定 A && B 为 false if(A || B) // 若 A 为 true ，则 B 的判断不会执行（即短路），直接判定 A || B 为 true class Solution { public: int res=0; int sumNums(int n) { bool x=n>1 && sumNums(n-1); res+=n; return res; } }; 65. 不用加减乘除做加法 图 12. 矩阵中的路径 13. 机器人的运动范围 动态规划 10- I. 斐波那契数列 class Solution { public: int fib(int n) { if(n == 0) return 0; vector dp(n+1); dp[0]=0; dp[1]=1; for(int i =2;i 10- II. 青蛙跳台阶问题 class Solution { public: int numWays(int n) { if(n==0) return 1; if(n==1) return 1; vector dp(n+1); dp[0]=1; dp[1]=1; for(int i=2;i 14- I. 剪绳子 14- II. 剪绳子 II 39. 数组中出现次数超过一半的数字 42. 连续子数组的最大和 46. 把数字翻译成字符串 47. 礼物的最大价值 60. n个骰子的点数 63. 股票的最大利润 贪心 45. 把数组排成最小的数 查找 04. 二维数组中的查找 法一：二分查找 class Solution { public: bool findNumberIn2DArray(vector>& matrix, int target) { for (int i = 0; i target) b = mid-1; else a = mid+1; } } return false; } }; 法二： class Solution { public: bool findNumberIn2DArray(vector>& matrix, int target) { int i = matrix.size() - 1, j = 0; while(i >= 0 && j target) i--; else if(matrix[i][j] 53 - I. 在排序数组中查找数字I 53 - II. 0～n-1中缺失的数 排序 45. 把数组排成最小的数 双指针 21. 调整数组顺序使奇数位于偶数前面 48. 最长不含重复字符的子字符串 57 - II. 和为s的连续正数序列 回溯 38. 字符串的排列 数学 17. 打印从1到最大的n位数 43. 1～n 整数中 1 出现的次数 44. 数字序列中某一位的数字 49. 丑数 61. 扑克牌中的顺子 62. 圆圈中最后剩下的数字 其他 03. 数组中重复的数字 class Solution { public: int findRepeatNumber(vector& nums) { unordered_map ma; for(auto x: nums){ if(ma[x]) return x; ma[x]=true; } return -1; } }; class Solution { public: int findRepeatNumber(vector& nums) { int i=0; while(i 05. 替换空格 11. 旋转数组的最小数字 16. 数值的整数次方 29. 顺时针打印矩阵 51. 数组中的逆序对 66. 构建乘积数组 Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-04-16 13:46:42 "},"数据库.html":{"url":"数据库.html","title":"数据库","keywords":"","body":" 说一说MySQL逻辑架构 连接层 服务层 SQL Interface: SQL接口 Parser: 解析器 Optimizer: 查询优化器 Caches & Buffers： 查询缓存组件 存储引擎层 InnoDB 和 MyISAM的区别 数据库三大范式是什么 第一范式 第二范式 第三范式 一条SQL语句在数据库框架中的执行流程 索引的优点和缺点 索引的分类 聚簇索引 辅助索引（非聚簇索引） 联合索引 索引的底层数据结构 b树（平衡多路查找树） b+树 适合建立索引的情况： 不适合建索引的情况： 如何判断数据库的索引有没有生效？ 什么时候索引失效？ 说一说事务的特性 事务的隔离级别 什么是脏读、不可重复读、幻读？ MVCC 锁 操作类型划分 粒度划分 意向锁（表级别） 行级锁的算法 态度划分 悲观锁 乐观锁 死锁 主从复制 内存、磁盘 局部性原理与磁盘预读 说一说MySQL逻辑架构 MySQL可以分为 服务层、存储引擎层、连接层。 连接层 系统（客户端）访问 MySQL 服务器前，需要建立 TCP 连接。经过三次握手建立连接成功后， MySQL 服务器对 TCP 传输过来的账号密码做身份认证、权限获取。 服务层 SQL Interface: SQL接口 接收用户的SQL命令，并且返回用户需要查询的结果。 Parser: 解析器 对 SQL 语句进行语法分析、语义分析。将SQL语句分解成数据结构。 Optimizer: 查询优化器 SQL语句在语法解析之后、查询之前会使用查询优化器确定 SQL 语句的执行路径，生成一个执行计划 Caches & Buffers： 查询缓存组件 因为查询缓存命中率不高，MySQL 8.0中删除。（相同的查询操作才会命中查询缓存） 存储引擎层 负责数据的存储和提取。MySQL>=5.5之后，默认采用InnoDB引擎（优先考虑InnoDB引擎）。 InnoDB 和 MyISAM的区别 InnoDB MyISAM 事务 支持 不支持 全文索引 不支持 支持 数据量过大时使用count() 瞬间返回，因为MyISAM会直接存储总行数 需要按行扫描再返回结果 外键 支持 不支持 锁 支持表锁、行锁，默认行锁 只支持表锁 数据库三大范式是什么 第一范式 无重复的列（原子性），数据表的每一列都是不可分割的原子数据项。 1NF的定义为：符合1NF的关系中的每个属性都不可再分 第二范式 要求实体的属性完全依赖于主关键字（唯一性），所谓完全依赖是指不能存在依赖主关键字一部分的属性。（员工id号） 满足1NF，非主属性完全函数依赖于候选码 第三范式 任何主属性不依赖于其他非主属性（每列都与主键有直接关系，不存在传递依赖）。 符合2NF，并且消除了非主属性对于候选码的传递函数依赖。 一条SQL语句在数据库框架中的执行流程 应用程序把查询SQL语句发送给服务器执行； 查询缓存，如果缓存是打开的，服务器在收到查询请求后，并不会直接去数据库查询，而是在数据库的查询缓存中找是否有相同的查询数据，如果存在，直接返回给客户端。只有缓存不存在时，才会进行下面的操作 查询优化处理，生成执行计划。包括解析SQL、预处理、优化SQL、执行计划 MySQL根据相应的执行计划完成整个查询 将查询结果返回给客户端 索引的优点和缺点 索引（Index）是帮助MySQL高效获取数据的数据结构。 优点：降低数据库的IO成本、加速表和表之间的连接、减少查询中分组和排序的时间 ，降低了CPU的消耗、通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。 缺点：创建索引和维护索引要耗费时间、索引需要占磁盘空间、降低更新表的速度 索引的分类 从功能逻辑上说，索引主要有 4 种，分别是普通索引（允许在定义索引的列中插入重复值和空值）、唯一索引（唯一，允许有空值）、主键索引（唯一，不允许有空值）、全文索引（支持值的全文查找）。 按照物理实现方式 ，索引可以分为 2 种：聚簇索引和非聚簇索引。 按照作用字段个数 进行划分，分成单列索引和联合索引。 聚簇索引 聚簇索引是对磁盘上实际数据重新组织，然后按指定的一个或多个列的值排序的算法。 聚簇索引的特点是存储数据的顺序和索引顺序一致。 一般情况下主键会默认创建聚簇索引，而且一张表只允许存在一个聚簇索引 辅助索引（非聚簇索引） 辅助索引是根据索引键创建的一棵B+树，与聚簇索引不同的是，其叶子节点仅存放索引键值，以及该索引键值指向的主键。也就是说，如果通过辅助索引来查找数据，那么当找到辅助索引的叶子节点后，还需要根据主键值查找聚簇索引来得到数据，这个过程称为回表。 联合索引 同时为多个列建立索引，比方说我们想让B+树按照 c2和c3列 的大小进行排序，这个包含两层含义：先把各个记录和页按照c2列进行排序，在记录的c2列相同的情况下，采用c3列进行排序。 索引的底层数据结构 b树（平衡多路查找树） B树中一个节点的子节点数目的最大值，称为阶 m 每个节点最多只有m个子节点。 除根节点外，每个非叶子节点具有至少有 m/2（向下取整）个子节点。 非叶子节点的根节点至少有两个子节点。 有k颗子树的非叶节点有k-1个键，键按照递增顺序排列。 叶节点都在同一层中。 b+树 每个节点最多只有m个子节点。 除根节点外，每个非叶子节点具有至少有 m/2（向下取整）个子节点。 非叶子节点的根节点至少有两个子节点。 有k颗子树的非叶节点有k个键，键按照递增顺序排列。 叶节点都在同一层中。 适合建立索引的情况： 在最频繁使用的、用以缩小查找返回的字段建立索引 在频繁使用的、需要排序的字段上建立索引 字段的数值有唯一性的限制 频繁作为 WHERE 查询条件的字段 经常 GROUP BY 和 ORDER BY 的列 DISTINCT 字段需要创建索引 不适合建索引的情况： 对于查询中很少涉及的列或重复值比较多的列，不适合建立索引 对于一些特殊的数据类型，不适合建立索引，比如文本字段 (text)等 在where中使用不到的字段，不要设置索引 数据量小的表最好不要使用索引 有大量重复数据的列上不要建立索引 避免对经常更新的表创建过多的索引 如何判断数据库的索引有没有生效？ 使用Explain命令查看语句的执行计划，MySQL在执行某个语句之前，会将该语句过一遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了很多信息。可以通过其中和索引有关的信息来分析是否命中了索引，例如：possible_key、key、key_len等字段，分别说明了此语句可能会使用的索引、实际使用的索引以及索引的长度 什么时候索引失效？ 1、索引列参与表达式计算 SELECT 'sname' FROM 'stu' WHERE 'age' + 10 = 30; 2、函数运算： SELECT 'sname' FROM 'stu' WHERE LEFT('date',4) 3、%语句% 模糊查询: SELECT * FROM 'manong' WHERE 'uname' LIKE '%码农%' -- 走索引 SELECT * FROM 'manong' WHERE 'uname' LIKE \"%码农%\" -- 不走索引 4、字符串与数字比较不走索引： CREATE TABLE 'a' ('a' char(10)); EXPLAIN SELECT * FROM 'a' WHERE 'a' = \"1\"; -- 走索引 EXPLAIN SELECT * FROM 'a' WHERE 'a' = 1; -- 不走索引，同样也是使用了函数运算 5、查询条件中有or，即时其中有条件带索引也不会使用（前后有非索引的列） SELECT * FROM dept WHERE dname='xxx' or loc='xx' or deptno=45; 6、正则表达式不使用索引 7、MySQL内部优化器会对SQL语句进行优化，如果优化器估算使用全表扫描比使用索引快，则不使用索引。使用不等于（!=或者<>） 说一说事务的特性 原子性（atomicity）A 是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。 一致性（consistency）C 一致性是指事务执行前后，数据从一个合法性状态 变换到另外一个合法性状态 。这种状态是语义上的而不是语法上的，跟具体的业务有关。 隔离型（isolation）I 事务的隔离性是指一个事务的执行 不能被其他事务干扰 ，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（durability）D 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的 ，接下来的其他操作和数据库故障不应该对其有任何影响。 事务的隔离级别 读未提交（READ UNCOMMITTED）最低的隔离级别，允许读取尚未提交的数据变更 读提交 （READ COMMITTED）允许读取并发事务已经提交的数据 可重复读 （REPEATABLE READ）对同一字段的多次读取结果都是一致的，除非数据是被本事务自己所修改 串行化 （SERIALIZABLE）最高隔离级别，完全服从ACID的隔离级别。所有的事务依次执行，这样事务之间就完全不可能产生干扰，严重影响程序的性能，通常情况都不会使用该级别。 隔离级别 脏读 不可重复读 幻读 READ UNCOMMITTED 可能 可能 可能 READ COMMITTED 不可能 可能 可能 REPEATABLE READ 不可能 不可能 可能 SERIALIZABLE 不可能 不可能 不可能 默认隔离级别： MySQL：REPEATABLE_READ （repeatable_read） ORACLE：READ_COMMITTED （read_committed） MySQL 在 REPEATABLE READ 隔离级别下是可以解决幻读问题的，解决方案有两种，可以使用 MVCC 方案解决，也可以采用 加锁 方案解决。（间隙锁） 什么是脏读、不可重复读、幻读？ 脏读：当前事务(A)中可以读到其他事务(B)未提交的数据（脏数据），这种现象是脏读。 不可重复读：在事务A中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。 幻读：在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。 MVCC （Multi-Version Concurrency Control, 多版本并发控制） 读——读：不存在任何问题，也不需要并发控制 读——写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读 写——写：有线程安全问题，可能会存在更新丢失的问题 MVCC 可以为数据库解决以下问题： 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发的读写性能 可以解决脏读、不可重复读、幻读等事务隔离问题，但不能解决更新丢失问题。 锁 操作类型划分 共享锁（S Lock），读锁，针对同一份数据，多个事务的读操作可以同时进行而不会互相影响。 排他锁（X Lock），写锁，当前写操作没有完成前，它会阻断其他写锁和读锁。 粒度划分 表级锁、页级锁、行锁 意向锁（表级别） 意向共享锁（IS Lock），事务有意向对表中的某些行加共享锁（S锁） 意向排他锁（IX Lock），事务有意向对表中的某些行加排他锁（X锁） 行级锁的算法 Record Lock：单个行记录上的锁。 Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。 Next-Key Lock∶Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。 态度划分 悲观锁 先获取锁，再进行业务操作，一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。 当数据库执行SELECT … FOR UPDATE时会获取被SELECT中的数据行的行锁，SELECT FOR UPDATE获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。 乐观锁 先进行业务操作，只在最后实际更新数据时检查数据是否被更新过 Java 并发包中的AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。 死锁 死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。若无外力作用，事务都将无法推进下去。 主从复制 内存、磁盘 索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。 内存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响。 机械硬盘结构（b站上有拆卸的视频），磁盘转动，磁头沿半径方向移动（实际是斜切向运动）。磁盘的每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。 当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。 局部性原理与磁盘预读 由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。 二叉排序/搜索/查找树 （1）若左子树不空，则左子树上所有结点的值均小于它的根节点的值； （2）若右子树不空，则右子树所有结点的值均大于或等于它的根结点的值； （3）左、右子树也分别为二叉排序树 平衡二叉树 它是一棵空树或它的左右两个子树的高度差（称为平衡因子）不大于1的二叉排序树，并且左右两个子树都是一棵平衡二叉树。 AVL 平衡二叉查找树 红黑树 Java 中的 TreeMap，JDK 1.8 中的 HashMap、C++ STL 中的 map 均是基于红黑树结构实现。 节点是红色或黑色 根是黑色 叶子节点（外部节点，空节点）都是黑色，这里的叶子节点指的是最底层的空节点（外部节点） 红色节点的子节点都是黑色 红色节点的父节点都是黑色 从根节点到叶子节点的所有路径上不能有 2 个连续的红色节点 从任一节点到叶子节点的所有路径都包含相同数目的黑色节点 Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-05-08 08:09:32 "},"SQL语法.html":{"url":"SQL语法.html","title":"SQL","keywords":"","body":" SELECT DISTINCT LIMIT 限定名 ORDER BY DESC WHERE AND OR IN NOT LIKE REGEXP Concat() AS 文本处理函数 日期和时间处理函数 数值处理函数 聚集函数 GROUP BY HAVING 子查询 连结表 UNION CREATE VIEW 存储过程 游标 触发器 事务 参考：MySQL必知必会 SQL语法顺序 SELECT 检索数据 SELECT 列 FROM 表名; # 单个列 SELECT 列1,列2,列3 FROM 表名; # 多个列 SELECT * FROM 表名; # 所有列 DISTINCT 去重，只返回选择列唯一的行。 SELECT DISTINCT 列 FROM 表名; LIMIT 限制结果，只显示前n行。 SELECT 列 FROM 表名 LIMIT 5,5; # 从行5开始的5行 限定名 SELECT 表名.列 FROM 表名 # 限制列名 SELECT 表名.列 FROM 数据库.表名 # 限制表名 ORDER BY 默认升序排列（从A到Z） SELECT 列 FROM 表名 ORDER BY 列; SELECT 列1,列2,列3 FROM 表名ORDER BY 列1,列2; # 先按列1排序，然后再按列2排序 DESC 降序排序，从Z到A排序 SELECT 列 FROM 表名 ORDER BY 列 DESC; WHERE 过滤数据 SELECT 列1,列2 FROM 表名 WHERE 列1 = 2.5 # 从表中检索两个列，只返回列1值等于2.5的行 WHERE子句操作符 操作符 说明 = 等于 <> 不等于 != 不等于 小于 小于等于 > 大于 >= 大于等于 BETWEEN 在指定的两个值之间 例：BETWEEN 5 AND 10 对字符串操作时需要加单引号 # 空值检查 SELECT 列1,列2 FROM 表名 WHERE 列1 IS NULL; # 返回列1为空（不是为0） AND 用在WHERE子句中的关键字，用来指示检索满足所有给定条件的行。 OR OR操作符与AND操作符不同，它指示MySQL检索匹配任一条件的行。 IN IN操作符用来指定条件范围，功能与OR相当。 SELECT 列1,列2 FROM 表名 WHERE 列1 IN (1002,1003); NOT NOT WHERE子句中用来否定后跟条件的关键字。 LIKE 通配符：%表示任何字符出现任意次数，_用途与%一样但下划线只匹配单个字符而不是多个字符。 SELECT 列1,列2 FROM 表名 WHERE 列1 LIKE 'jet%'; # 检索任意以jet起头的词 REGEXP REGEXP后所跟的东西作为正则表达式 Concat() 把两个列拼接起来 SELECT Concat(列1,'(',列2,')') FROM 表名; # 列1(列2) AS 起别名 文本处理函数 函数 说明 Left() 返回串左边的字符 Length() 返回串的长度 Locate() 找出串的一个子串 Lower() 将串转换为小写 LTrim() 去掉串左边的空格 Right() 返回串右边的字符 RTrim() 去掉串右边的空格 Soundex() 返回串的SOUNDEX值 SubString() 返回子串的字符 Upper() 将串转换为大写 日期和时间处理函数 略，太多了。。。 数值处理函数 函数 说明 Abs() 返回一个数的绝对值 Cos() 返回一个角度的余弦 Exp() 返回一个数的指数值 Mod() 返回除操作的余数 Pi() 返回圆周率 Rand() 返回一个随机数 Sin() 返回一个角度的正弦 Sqrt() 返回一个数的平方根 Tan() 返回一个角度的正切 聚集函数 运行在行组上，计算和返回单个值的函数 函数 说明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 GROUP BY 根据一个或多个列对结果集进行分组。在分组的列上我们通常配合 COUNT, SUM, AVG等函数一起使用。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 HAVING 过滤分组 HAVING和WHERE的差别：WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。这是一个重要的区别，WHERE排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组。WHERE过滤行，而HAVING过滤分组。 ORDER BY GROUP BY 排序产生的输出 分组行。但输出可能不是分组的顺序 任意列都可以使用（甚至非选择的列也可以使用） 只可能使用选择列或表达式列，而且必须使用每个选择列表达式 不一定需要 如果与聚集函数一起使用列（或表达式），则必须使用 子查询 在WHERE子句中使用子查询，应该保证SELECT语句具有与WHERE子句中相同数目的列。通常，子查询将返回单个列并且与单个列匹配，但如果需要也可以使用多个列。 连结表 联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。 SELECT 列1,列2,列3 FROM 表1,表2 WHERE 表1.列4 = 表2.列4; 没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。 可视化网站：https://joins.spathon.com/ UNION 组合查询 UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔。 UNION中的每个查询必须包含相同的列、表达式或聚集函数。 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型。 使用UNION ALL，MySQL不取消重复的行。 INSERT 插入数据、UPDATE 更新数据、DELETE 删除数据 CREATE TABLE 创建表 AUTO_INCREMENT，本列每当增加一行时自动增量 ALTER TABLE 更新表、DROP TABLE 删除表、RENAME TABLE 重命名表 CREATE VIEW 视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。 为什么使用视图？ 重用SQL语句。 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。 使用表的组成部分而不是整个表。 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 CREATE VIEW viewname AS SELECT 列1,列2 FROM 表名 WHERE 列1 = 2.2; # 创建视图 SHOW CREATE VIEW viewname; # 查看创建的视图 DROP VIEW viewname; # 删除视图 存储过程 为什么要使用存储过程？ 通过把处理封装在容易使用的单元中，简化复杂的操作。 简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，只需要更改存储过程的代码。 由于不要求反复建立一系列处理步骤，这保证了数据的完整性。 提高性能。因为使用存储过程比使用单独的SQL语句要快。 存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码。 CREATE PROCEDURE productpricing() # 创建存储过程 BEGIN SELECT 列1,列2 FROM 表名 WHERE 列1 = 2.2; END; # 此存储过程名为productpricing,BEGIN和END语句用来限定存储过程体,过程体本身是一个SELECT语句 CALL productpricing() # 使用存储过程 DROP PROCEDURE productpricing() # 删除存储过程 # 可以使用参数 暂时略 SHOW CREATE PROCEDURE productpricing() # 检查存储过程 游标 游标（cursor）是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。 CREATE PROCEDURE processorders() BEGIN DECLARE ordernumbers CURSOR # 游标用DECLARE语句创建 FOR SELECT order_num FROM orders; END; OPEN ordernumbers; # 打开游标 FETCH ordernumbers INTO o; # 检索当前行的order_num列（将自动从第一行开始）到一个名为o的局部声明的变量中。 CLOSE ordernumbers; # 关闭游标 触发器 触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）：DELETE、INSERT、UPDATE。只有表才支持触发器，视图不支持，每个表最多支持6个触发器。 CREATE TRIGGER newproduct AFTER INSERT ON products FOR EACH ROW SELECT 'Product added'; # CREATE TRIGGER 创建触发器 # AFTER INSERT 在INSERT语句成功执行后执行 BEFORE 在之前 # FOR EACH ROW 对每个插入行执行 DROP TRIGGER newproduct # 删除触发器 事务 事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。 START TRANSACTION; # 事务开始 ROLLBACK; # 回退 COMMIT; # 提交 SAVEPOINT delete1; # 使用保留点 ROLLBACK TO delete1; # 回退到保留点 事务处理用来管理INSERT、UPDATE和DELETE语句。不能回退SELECT语句或CREATE或DROP操作。 Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-02-18 22:36:28 "},"TinyWebServer.html":{"url":"TinyWebServer.html","title":"TinyWebserver","keywords":"","body":" 代码框架 代码架构 文件描述符 用户空间与内核空间 同步 异步 缓存 I/O I/O模式 阻塞 I/O（blocking IO） 非阻塞 I/O（nonblocking IO） 信号驱动 I/O（ signal driven IO） 异步 I/O（asynchronous IO） I/O 多路复用（ IO multiplexing） select poll epoll LT（电平触发） ET（边缘触发） Reactor Proactor socket 服务器的工作流程： 客户端工作流程： 线程池 为什么要使用线程池？ 线程池中的线程数量是依据什么确定的？ HTTP连接 HTTP报文 请求报文 GET POST GET和POST的区别？ 响应报文 HTTP状态码 日志 单例模式 定时器 MySQL连接 注册登录 压力测试 手写线程池 TinyWebServer 项目地址：https://github.com/qinguoyi/TinyWebServer/tree/raw_version 使用线程池 + epoll(ET和LT均实现) + 模拟Proactor模式的并发模型 使用状态机解析HTTP请求报文，支持解析GET和POST请求 通过访问服务器数据库实现web端用户注册、登录功能，可以请求服务器图片和视频文件 实现同步/异步日志系统，记录服务器运行状态 经Webbench压力测试可以实现上万的并发连接数据交换 添加注释版本： 参考资料： 1 2 3 4 代码框架 代码架构 ├─ CGImysql // CGI校验程序，负责用户数据与数据库数据对比 mysql连接 │ ├─ sql_connection_pool.cpp │ └─ sql_connection_pool.h ├─ http // 实现HTTP协议连接、销毁 │ ├─ http_conn.cpp │ └─ http_conn.h ├─ lock // 封装互斥锁、信号量等 │ └─ locker.h ├─ log // 日志 │ ├─ block_queue.h │ ├─ log.cpp │ └─ log.h ├─ main.cpp // 主函数 ├─ makefile ├─ root // 前端 网页 ├─ threadpool // 线程池 │ └─ threadpool.h └─ timer // 定时器 ├─ README.md └─ lst_timer.h 文件描述符 Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。在操作这些所谓的文件的时候，我们每操作一次就找一次名字，这会耗费大量的时间和效率。所以Linux中规定每一个文件对应一个索引，这样要操作文件的时候，直接找到索引就可以对其进行操作了。 文件描述符（file descriptor）就是内核为了高效管理这些已经被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符来实现。同时还规定系统刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。这意味着如果此时去打开一个新的文件，它的文件描述符会是3，再打开一个文件文件描述符就是4...... ls -l /proc/pid/fd // 查看文件描述符 pid是代表的进程号 用户空间与内核空间 内核态：也叫内核空间，是内核进程/线程所在的区域。主要负责运行系统、硬件交互。 用户态：也叫用户空间，是用户进程/线程所在的区域。主要用于执行用户程序。 同步 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去。 异步 异步是指进程不需要一直等下去， 而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 阻塞和非阻塞是线程的一种状态，同步和异步是指的是线程执行方法的一种方式，当然同步执行时，一般都伴随着线程的阻塞。 缓存 I/O I/O模式 IO (Input/Output，输入/输出)即数据的读取（接收）或写入（发送）操作。 对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段： 等待数据准备 (Waiting for the data to be ready) 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process) 正是因为这两个阶段，linux系统产生了下面五种网络模式的方案。 阻塞 I/O（blocking IO） 在内核将数据准备好之前，系统调用会一直等待所有的套接字。 指的是需要内核 IO 操作彻底完成后才返回到用户空间执行用户程序的操作指令。 非阻塞 I/O（nonblocking IO） 每次客户询问内核是否有数据准备好，即文件描述符缓冲区是否就绪。当有数据报准备好时，就进行拷贝数据报的操作。当没有数据报准备好时，也不阻塞程序，内核直接返回未准备就绪的信号，等待用户程序的下一个轮寻。 指的是用户进程不需要等待内核 IO 操作彻底完成，即可返回用户空间执行后续指令。与此同时，内核会立即返回给用户一个 IO 状态值。 信号驱动 I/O（ signal driven IO） 应用进程告诉内核：当数据报准备好的时候，给我发送一个信号，对SIGIO信号进行捕捉，并且调用我的信号处理函数来获取数据报。 异步 I/O（asynchronous IO） 当应用程序调用aio_read时，内核一方面去取数据报内容返回，另一方面将程序控制权还给应用进程，应用进程继续处理其他事情，是一种非阻塞的状态。 当内核中有数据报就绪时，由内核将数据报拷贝到应用程序中，返回aio_read中定义好的函数处理程序。 I/O 多路复用（ IO multiplexing） IO多路复用就是通过一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作的一种机制。 I/O多路复用的本质是使用select ，poll 或 epoll函数，挂起进程，当一个或多个IO事件发生之后，将控制返回给用户进程。 以服务器编程为例，传统的多进程（多线程）并发模型，在处理用户连接时都是开启一个新的线程或进程去处理一个新的连接，而IO多路复用则是可以在一个进程（线程）中同时监听多个网络IO事件，也就是多个文件描述符 I/O复用函数本身是阻塞的，能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力。 select int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 每次调用select，都需要把监听的文件描述符集合 fd_set从用户态拷贝多内核态，从算法角度来说就是$O(N)$的时间开销 每次调用select返回之后都需要遍历所有文件描述符，判断哪些文件描述符有读写事件发生，也是$O(N)$的时间开销 内核对被监控的文件描述符的集合大小做了限制，并且这个是通过宏控制的，大小不可改变，为1024。这一点和上一个缺点是矛盾的，文件描述符设大了，遍历时间就长，其效率也会下降 poll int poll (struct pollfd *fds, unsigned int nfds, int timeout); struct pollfd { int fd; /* file descriptor */ short events; /* requested events to watch */ short revents; /* returned events witnessed */ }; poll和select本质上没有差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。 select采用fdset（fdset采用了bitmap），poll采用了数组，所以表示的描述符比select大 poll和select同样存在一个缺点就是，文件描述符的数组被整体复制于用户态和内核态的地址空间之间，而不管这些文件描述符是否有事件，它们的开销随着文件描述符数量的增加而线性增大。 poll返回后，也需要遍历整个描述符的数组才能得到有事件的描述符 epoll int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)； int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); epoll解决了select和poll在文件描述符集合拷贝和遍历上的问题，能够在一个进程中监听多个文件描述符，并且十分高效 在内核当中epoll是以红黑树的方式组织监听事件的，所以查询开销是O(logn)。采用回调的方式检测就绪事件，时间复杂度是O(1) 在注册监听事件时从用户态将数据传入内核态；当返回时需要将就绪队列的内容拷贝到用户空间 对于select和poll来说，所有文件描述符都是在用户态被加入其文件描述符集合的，每次调用都需要将整个集合拷贝到内核态；epoll则将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都需要执行一个系统调用。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，epoll可能会慢于select和poll由于这些大量的系统调用开销。 select使用线性表描述文件描述符集合，文件描述符有上限；poll使用链表来描述；epoll底层通过红黑树来描述，并且维护一个ready list，将事件表中已经就绪的事件添加到这里，在使用epoll_wait调用时，仅观察这个list中有没有数据即可。 select和poll的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，它们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll则不需要去以这种方式检查，当有活动产生时，会自动触发epoll回调函数通知epoll文件描述符，然后内核将这些就绪的文件描述符放到之前提到的ready list中等待epoll_wait调用后被处理。 select和poll都只能工作在相对低效的LT模式下，而epoll同时支持LT和ET模式。 综上，当监测的fd数量较小，且各个fd都很活跃的情况下，建议使用select和poll；当监听的fd数量较多，且单位时间仅部分fd活跃的情况下，使用epoll会明显提升性能。 LT（电平触发） 假设委托内核检测读事件 -> 检测fd的读缓冲区 读缓冲区有数据 - > epoll检测到了会给用户通知 a.用户不读数据，数据一直在缓冲区，epoll 会一直通知 b.用户只读了一部分数据，epoll会通知 c.缓冲区的数据读完了，不通知 LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的。 效率会低于ET触发，尤其在高并发大流量的情况下。但是LT对代码编写要求比较低，不容易出现问题。LT模式服务编写上的表现是：只要有数据没有被获取，内核就不断通知你，因此不用担心时间丢失的情况。 ET（边缘触发） 假设委托内核检测读事件 -> 检测fd的读缓冲区 读缓冲区有数据 - > epoll检测到了会给用户通知 a.用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了 b.用户只读了一部分数据，epoll不通知 c.缓冲区的数据读完了，不通知 ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。 效率非常高，在高并发大流量的情况下，会比LT少很多epoll的系统调用，因此效率高。但是对编程要求高，需要细致的处理每个请求，否则容易发生丢失事件的情况 EPOLLIN ： 表示对应的文件描述符可以读（包括对端SOCKET正常关闭）； EPOLLOUT： 表示对应的文件描述符可以写； EPOLLPRI： 表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）； EPOLLERR： 表示对应的文件描述符发生错误； EPOLLHUP： 表示对应的文件描述符被挂断； EPOLLET： 将 EPOLL设为边缘触发(Edge Triggered)模式（默认为水平触发），这是相对于水平触发(Level Triggered)来说的。 EPOLLONESHOT： 只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里 Reactor Reactor要求主线程（I/O处理单元，下同）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元，下同）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。 Proactor Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。如主线程读完成后users[sockfd].read()，选择一个工作线程来处理客户请求pool->append(users + sockfd)。 同步I/O方式模拟出Proactor模式原理：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。 工作流程如下： 1）主线程往epoll内核事件表中注册socket上的读就绪事件。 2）主线程调用epoll_wait等待socket上有数据可读。 3）当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。 4）睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。 5）主线程调用epoll_wait等待socket可写。 6）当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。 socket Socket又称为套接字，它是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。通过调用接口中已经实现的方法建立两个进程之间的连接和通信。 服务器的工作流程： （1）创建 socket：创建服务端的socket。 （2）绑定 bind：把服务端用于通信的地址和端口绑定到socket上。 （3）监听 listen：把socket设置为监听模式。 （4）接受连接 accept：接受客户端的连接。 （5）通信 recv( ) / send( ) ：与客户端通信，接收客户端发过来的报文后，回复处理结果，重复此过程。 （6）关闭 close( )：关闭socket，释放资源。 客户端工作流程： （1）创建 socket：创建客户端的socket。 （2）发送连接 connect( )：向服务器发起连接请求 （3）通信 recv( ) / send( )：与服务端通信，发送一个报文后等待回复，然后再发下一个报文。重复此过程，直到全部的数据被发送完。 （4）关闭 close( )：关闭socket，释放资源。 线程池 threadpool(connection_pool *connPool, int thread_number = 8, int max_request = 10000); ~threadpool(); bool append(T *request); // 向请求队列中插入任务请求 static void *worker(void *arg); // 工作线程运行的函数，它不断从工作队列中取出任务并执行之 void run(); //调用void http_conn::process() 所谓线程池，就是一个pthread_t类型的普通数组，通过pthread_create()函数创建m_thread_number个线程，用来执行worker()函数以执行每个请求处理函数（HTTP请求的process函数），通过pthread_detach()将线程设置成脱离态（detached）后，当这一线程运行结束时，它的资源会被系统自动回收，而不再需要在其它线程中对其进行 pthread_join() 操作。 操作工作队列一定要加锁（locker），因为它被所有线程共享。 我们用信号量来标识请求队列中的请求数，通过m_queuestat.wait();来等待一个请求队列中待处理的HTTP请求，然后交给线程池中的空闲线程来处理。 为什么要使用线程池？ 当你需要限制你应用程序中同时运行的线程数时，线程池非常有用。因为启动一个新线程会带来性能开销，每个线程也会为其堆栈分配一些内存等。为了任务的并发执行，我们可以将这些任务任务传递到线程池，而不是为每个任务动态开启一个新的线程。（空间换时间） 线程池中的线程数量是依据什么确定的？ 回答 线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors/cores)的数量N：如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程阻塞）；对于IO密集型的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费，公式：最佳线程数 = CPU当前可使用的Cores数 * 当前CPU的利用率 * (1 + CPU等待时间 / CPU处理时间) HTTP连接 HTTP的报文处理流程分为以下三个步骤： 连接处理：浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理。 处理报文请求：工作线程取出任务后，调用process_read函数，通过主、从状态机对请求报文进行解析。 返回响应报文：解析完之后，跳转do_request函数生成响应报文，通过process_write写入buffer，返回给浏览器端。 void http_conn::init(int sockfd, const sockaddr_in &addr); // 外部调用初始化 bool http_conn::read_once(); // 读取数据存储到m_read_buf void http_conn::process(); // 调用process_read()和process_write(read_ret) HTTP_CODE process_read(); // 从m_read_buf读取，并处理请求报文 HTTP_CODE parse_request_line(char *text); // 主状态机解析报文中的请求行数据 获得请求方法，目标url及http版本号 HTTP_CODE parse_headers(char *text); // 主状态机解析报文中的请求头数据 HTTP_CODE parse_content(char *text); // 主状态机解析报文中的请求内容 char *get_line() { return m_read_buf + m_start_line; }; // get_line用于将指针向后偏移，指向未处理的字符 http_conn::LINE_STATUS http_conn::parse_line()// 返回值为行的读取状态，有LINE_OK,LINE_BAD,LINE_OPEN bool process_write(HTTP_CODE ret); // //向m_write_buf写入响应报文数据 通过while循环，对主从状态机进行封装，对报文的每一行进行循环处理。这里的主状态机，指的是process_read()函数，从状态机是指parse_line()函数。 从状态机负责读取报文的一行（并对其中的\\r\\n进行修改为\\0\\0），主状态机负责对该行数据进行解析，主状态机内部调用从状态机，从状态机驱动主状态机。它们之间的关系如下图所示： 主状态机初始状态是CHECK_STATE_REQUESTLINE，而后调用parse_request_line()解析请求行，获得HTTP的请求方法、目标URL以及HTTP版本号，状态变为CHECK_STATE_HEADER。 此时进入循环体之后，调用parse_headers()解析请求头部信息。先要判断是空行还是请求头，空行进一步区分POST还是GET。若是请求头，则更新长短连接状态、host等等。 注：GET和POST请求报文的区别之一是有无消息体部分。 当使用POST请求时，需要进行CHECK_STATE_CONTENT的解析，取出POST消息体中的信息（用户名、密码）。 HTTP报文 HTTP报文分为请求报文和响应报文两种，其中，浏览器端向服务器发送的为请求报文，服务器处理后返回给浏览器端的为响应报文。 HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。 GET和POST是最常见的HTTP请求方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。 请求报文 GET 请求指定的页面内容，并返回实体主体 GET /favicon.ico HTTP/1.1 Host: 49.232.165.212:9006 Connection: keep-alive User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36 Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8 Referer: http://49.232.165.212:9006/ Accept-Encoding: gzip, deflate Accept-Language: zh,en-US;q=0.9,en;q=0.8,zh-TW;q=0.7,zh-CN;q=0.6 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据包含在请求体中。POST请求可能会导致新的资源的建立或者已有资源的修改。 POST /2CGISQL.cgi HTTP/1.1 Host: 49.232.165.212:9006 Connection: keep-alive Content-Length: 17 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://49.232.165.212:9006 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Referer: http://49.232.165.212:9006/1 Accept-Encoding: gzip, deflate Accept-Language: zh,en-US;q=0.9,en;q=0.8,zh-TW;q=0.7,zh-CN;q=0.6 user=a&password=a 请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本。 请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。 HOST，给出请求资源所在服务器的域名。 User-Agent，HTTP客户端程序的信息，该信息由你发出请求使用的浏览器来定义,并且在每个请求中自动发送等。 Accept，说明用户代理可处理的媒体类型。 Accept-Encoding，说明用户代理支持的内容编码。 Accept-Language，说明用户代理能够处理的自然语言集。 Content-Type，说明实现主体的媒体类型。 Content-Length，说明实现主体的大小。 Connection，连接管理，可以是Keep-Alive或close。 空行，请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。 请求数据也叫主体，可以添加任意的其他数据。 GET和POST的区别？ 最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制。（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。 GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100（指示信息—表示请求已接收，继续处理）continue，浏览器再发送data，服务器响应200 ok（返回数据）。 响应报文 HTTP/1.1 200 OK Content-Length:360 Connection:keep-alive 状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为OK。 消息报头，用来说明客户端要使用的一些附加信息。 第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8。 空行，消息报头后面的空行是必须的。 响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。 HTTP状态码 状态码 意义 解释 301 Permanently Moved 被请求的资源已永久移动到新位置，新的URL在Location头中给出，浏览器应该自动地访问新的URL。301为永久重定向。 302 Found 请求的资源现在临时从不同的URL响应请求。302为临时重定向。 200 OK 表示从客户端发来的请求在服务器端被正确处理 304 Not Modified 告诉浏览器可以从缓存中获取所请求的资源。 400 bad request 请求报文存在语法错误 403 forbidden 表示对请求资源的访问被服务器拒绝 404 not found 表示在服务器上没有找到请求的资源 500 internal sever error 表示服务器端在执行请求时发生了错误 503 service unavailable 表明服务器暂时处于超负载或正在停机维护，无法处理请求 日志 单例模式 最常用的设计模式之一，保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。 实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。 懒汉模式 ：即非常懒，不用的时候不去初始化，所以在第一次被使用时才进行初始化（实例的初始化放在getinstance函数内部） 经典的线程安全懒汉模式，使用双检测锁模式（p == NULL检测了两次） 利用局部静态变量实现线程安全懒汉模式 饿汉模式：即迫不及待，在程序运行时立即初始化（实例的初始化放在getinstance函数外部，getinstance函数仅返回该唯一实例的指针）。 日志系统的运行机制 日志文件 局部变量的懒汉模式获取实例 生成日志文件，并判断同步和异步写入方式 同步 判断是否分文件 直接格式化输出内容，将信息写入日志文件 异步 判断是否分文件 格式化输出内容，将内容写入阻塞队列（循环数组、条件变量实现），创建一个写线程，从阻塞队列取出内容写入日志文件 定时器 服务器首先创建定时器容器链表，然后用统一事件源将（统一事件源，是指将信号事件与其他事件一样被处理。）异常事件，读写事件和信号事件统一处理，根据不同事件的对应逻辑使用定时器。 具体的，浏览器与服务器连接时，创建该连接对应的定时器，并将该定时器添加到定时器容器链表上； 处理异常事件时，执行定时事件，服务器关闭连接，从链表上移除对应定时器； 处理定时信号时，将定时标志设置为true，以便执行定时器处理函数； 处理读/写事件时，若某连接上发生读事件或某连接给浏览器发送数据，将对应定时器向后移动，否则，执行定时事件。 MySQL连接 每一个HTTP连接获取一个数据库连接，获取其中的用户账号密码进行对比（有点损耗资源，实际场景下肯定不是这么做的），而后再释放该数据库连接。 创建了数据库连接池、链表实现（跟线程池类似） 使用mysql_init()初始化连接 使用mysql_real_connect()建立一个到mysql数据库的连接 使用mysql_query()执行查询语句 使用result = mysql_store_result(mysql)获取结果集 使用mysql_num_fields(result)获取查询的列数，mysql_num_rows(result)获取结果集的行数 通过mysql_fetch_row(result)不断获取下一行，然后循环输出 使用mysql_free_result(result)释放结果集所占内存 使用mysql_close(conn)关闭连接 注册登录 压力测试 手写线程池 #include #include #include #include #include #include using namespace std; template class threadpool { public: threadpool(int thread_number = 8, int max_request = 10000); ~threadpool(); bool append(T request); private: static void *worker(void *arg); void run(); private: int m_thread_number; // 线程池中的线程数 int m_max_requests; // 请求队列中允许的最大请求数 pthread_t *m_threads; // 描述线程池的数组，其大小为m_thread_number list m_workqueue; // 请求队列 链表实现 pthread_mutex_t m_mutex; // 互斥锁 sem_t m_sem; // 信号量 int sval; // 信号量值 bool m_stop; //是否结束线程 }; template threadpool::threadpool(int thread_number, int max_requests) : m_thread_number(thread_number), m_max_requests(max_requests), m_stop(false), m_threads(NULL) { m_threads = new pthread_t[m_thread_number]; sem_init(&m_sem, 0, 0); pthread_mutex_init(&m_mutex, NULL); for (int i = 0; i threadpool::~threadpool() { delete[] m_threads; m_stop = true; } template bool threadpool::append(T request) { pthread_mutex_lock(&m_mutex); if (m_workqueue.size() > m_max_requests) { pthread_mutex_unlock(&m_mutex); return false; } m_workqueue.push_back(request); pthread_mutex_unlock(&m_mutex); sem_post(&m_sem); // 解锁 +1 sem_getvalue(&m_sem,&sval); cout void *threadpool::worker(void *arg) { threadpool *pool = (threadpool *)arg; pool->run(); } template void threadpool::run() { while (!m_stop) { sem_wait(&m_sem); // 加锁 -1 =0阻塞 pthread_mutex_lock(&m_mutex); if (m_workqueue.empty()) { pthread_mutex_unlock(&m_mutex); continue; } T request = m_workqueue.front(); m_workqueue.pop_front(); sem_getvalue(&m_sem,&sval); cout *pool = NULL; pool = new threadpool; for(int i =1;iappend(i); } sleep(5); //防止子线程没有抢占到CPU且此时主线程已经执行完并退出 } Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-04-10 16:06:52 "},"protobuf.html":{"url":"protobuf.html","title":"protobuf","keywords":"","body":"protobuf 官方文档 Protobuf即Protocol Buffers，是Google公司开发的一种跨语言和平台的序列化数据结构的方式，是一个灵活的、高效的用于序列化数据的协议。与XML和JSON格式相比，protobuf更小、更快、更便捷。protobuf是跨语言的，并且自带一个编译器(protoc)，只需要用protoc进行编译，就可以编译成Java、Python、C++、C#、Go等多种语言代码，然后可以直接使用，不需要再写其它代码，自带有解析的代码。只需要将要被序列化的结构化数据定义一次(在.proto文件定义)，便可以使用特别生成的源代码(使用protobuf提供的生成工具)轻松的使用不同的数据流完成对结构数据的读写操作。甚至可以更新.proto文件中对数据结构的定义而不会破坏依赖旧格式编译出来的程序。 Protobuf的优点如下： 性能好，效率高 序列化后字节占用空间比XML少3-10倍，序列化的时间效率比XML快20-100倍。 有代码生成机制 将对结构化数据的操作封装成一个类，便于使用。 支持向后和向前兼容 当客户端和服务器同时使用一块协议的时候， 当客户端在协议中增加一个字节，并不会影响客户端的使用 支持多种编程语言Protobuf目前已经支持Java，C++，Python、Go、Ruby等多种语言。 Protobuf的缺点如下： 二进制格式导致可读性差 缺乏自描述 1.创建.proto文件，定义数据结构，格式如下： message xxx { // 字段规则：required -> 字段只能也必须出现 1 次 // 字段规则：optional -> 字段可出现 0 次或1次 // 字段规则：repeated -> 字段可出现任意多次（包括 0） // 类型：int32、int64、sint32、sint64、string、32-bit .... // 字段编号：0 ~ 536870911（除去 19000 到 19999 之间的数字） 字段规则 类型 名称 = 字段编号; } 2.protoc编译.proto文件生成xxx.pb.h，xxx.pb.cpp // $SRC_DIR: .proto 所在的源目录 // --cpp_out: 生成 c++ 代码 // $DST_DIR: 生成代码的目标目录 // xxx.proto: 要针对哪个 proto 文件生成接口代码 protoc -I=$SRC_DIR --cpp_out=$DST_DIR $SRC_DIR/xxx.proto protoc ./xxx.proto --cpp_out=./ 3.调用接口 #include #include #include \"test.pb.h\" #include \"google/protobuf/io/zero_copy_stream_impl.h\" #include \"google/protobuf/text_format.h\" //g++ -g -o test test.cpp ./test.pb.cc -I. -lprotobuf -pthread -std=c++11 using namespace test; int main(){ User p; p.set_name(\"yangzejin\"); p.set_id(\"0507\"); //------------------将pb二进制信息保存到字符串 std::string str; p.SerializeToString(&str); std::cout Copyright © YZJ 2022 all right reserved，powered by Gitbook更新时间： 2023-05-14 19:26:59 "}}