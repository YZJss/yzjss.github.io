{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Copyright © YZJ 2023 all right reserved，powered by Gitbook更新时间： 2023-05-09 18:16:59 "},"test.html":{"url":"test.html","title":"test","keywords":"","body":"11111 22222 Copyright © YZJ 2023 all right reserved，powered by Gitbook更新时间： 2023-05-09 19:02:05 "},"TinyWebServer.html":{"url":"TinyWebServer.html","title":"TinyWebserver","keywords":"","body":"TinyWebServer 项目地址：https://github.com/qinguoyi/TinyWebServer/tree/raw_version 使用线程池 + epoll(ET和LT均实现) + 模拟Proactor模式的并发模型 使用状态机解析HTTP请求报文，支持解析GET和POST请求 通过访问服务器数据库实现web端用户注册、登录功能，可以请求服务器图片和视频文件 实现同步/异步日志系统，记录服务器运行状态 经Webbench压力测试可以实现上万的并发连接数据交换 添加注释版本： 参考资料： 1 2 3 4 代码框架 代码架构 ├─ CGImysql // CGI校验程序，负责用户数据与数据库数据对比 mysql连接 │ ├─ sql_connection_pool.cpp │ └─ sql_connection_pool.h ├─ http // 实现HTTP协议连接、销毁 │ ├─ http_conn.cpp │ └─ http_conn.h ├─ lock // 封装互斥锁、信号量等 │ └─ locker.h ├─ log // 日志 │ ├─ block_queue.h │ ├─ log.cpp │ └─ log.h ├─ main.cpp // 主函数 ├─ makefile ├─ root // 前端 网页 ├─ threadpool // 线程池 │ └─ threadpool.h └─ timer // 定时器 ├─ README.md └─ lst_timer.h 文件描述符 Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。在操作这些所谓的文件的时候，我们每操作一次就找一次名字，这会耗费大量的时间和效率。所以Linux中规定每一个文件对应一个索引，这样要操作文件的时候，直接找到索引就可以对其进行操作了。 文件描述符（file descriptor）就是内核为了高效管理这些已经被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符来实现。同时还规定系统刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。这意味着如果此时去打开一个新的文件，它的文件描述符会是3，再打开一个文件文件描述符就是4...... ls -l /proc/pid/fd // 查看文件描述符 pid是代表的进程号 用户空间与内核空间 内核态：也叫内核空间，是内核进程/线程所在的区域。主要负责运行系统、硬件交互。 用户态：也叫用户空间，是用户进程/线程所在的区域。主要用于执行用户程序。 同步 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去。 异步 异步是指进程不需要一直等下去， 而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 阻塞和非阻塞是线程的一种状态，同步和异步是指的是线程执行方法的一种方式，当然同步执行时，一般都伴随着线程的阻塞。 缓存 I/O I/O模式 IO (Input/Output，输入/输出)即数据的读取（接收）或写入（发送）操作。 对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段： 等待数据准备 (Waiting for the data to be ready) 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process) 正是因为这两个阶段，linux系统产生了下面五种网络模式的方案。 阻塞 I/O（blocking IO） 在内核将数据准备好之前，系统调用会一直等待所有的套接字。 指的是需要内核 IO 操作彻底完成后才返回到用户空间执行用户程序的操作指令。 非阻塞 I/O（nonblocking IO） 每次客户询问内核是否有数据准备好，即文件描述符缓冲区是否就绪。当有数据报准备好时，就进行拷贝数据报的操作。当没有数据报准备好时，也不阻塞程序，内核直接返回未准备就绪的信号，等待用户程序的下一个轮寻。 指的是用户进程不需要等待内核 IO 操作彻底完成，即可返回用户空间执行后续指令。与此同时，内核会立即返回给用户一个 IO 状态值。 信号驱动 I/O（ signal driven IO） 应用进程告诉内核：当数据报准备好的时候，给我发送一个信号，对SIGIO信号进行捕捉，并且调用我的信号处理函数来获取数据报。 异步 I/O（asynchronous IO） 当应用程序调用aio_read时，内核一方面去取数据报内容返回，另一方面将程序控制权还给应用进程，应用进程继续处理其他事情，是一种非阻塞的状态。 当内核中有数据报就绪时，由内核将数据报拷贝到应用程序中，返回aio_read中定义好的函数处理程序。 I/O 多路复用（ IO multiplexing） IO多路复用就是通过一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作的一种机制。 I/O多路复用的本质是使用select ，poll 或 epoll函数，挂起进程，当一个或多个IO事件发生之后，将控制返回给用户进程。 以服务器编程为例，传统的多进程（多线程）并发模型，在处理用户连接时都是开启一个新的线程或进程去处理一个新的连接，而IO多路复用则是可以在一个进程（线程）中同时监听多个网络IO事件，也就是多个文件描述符 I/O复用函数本身是阻塞的，能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力。 select int select (int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout); 每次调用select，都需要把监听的文件描述符集合 fd_set从用户态拷贝多内核态，从算法角度来说就是$O(N)$的时间开销 每次调用select返回之后都需要遍历所有文件描述符，判断哪些文件描述符有读写事件发生，也是$O(N)$的时间开销 内核对被监控的文件描述符的集合大小做了限制，并且这个是通过宏控制的，大小不可改变，为1024。这一点和上一个缺点是矛盾的，文件描述符设大了，遍历时间就长，其效率也会下降 poll int poll (struct pollfd *fds, unsigned int nfds, int timeout); struct pollfd { int fd; /* file descriptor */ short events; /* requested events to watch */ short revents; /* returned events witnessed */ }; poll和select本质上没有差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是poll没有最大文件描述符数量的限制。 select采用fdset（fdset采用了bitmap），poll采用了数组，所以表示的描述符比select大 poll和select同样存在一个缺点就是，文件描述符的数组被整体复制于用户态和内核态的地址空间之间，而不管这些文件描述符是否有事件，它们的开销随着文件描述符数量的增加而线性增大。 poll返回后，也需要遍历整个描述符的数组才能得到有事件的描述符 epoll int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)； int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); epoll解决了select和poll在文件描述符集合拷贝和遍历上的问题，能够在一个进程中监听多个文件描述符，并且十分高效 在内核当中epoll是以红黑树的方式组织监听事件的，所以查询开销是O(logn)。采用回调的方式检测就绪事件，时间复杂度是O(1) 在注册监听事件时从用户态将数据传入内核态；当返回时需要将就绪队列的内容拷贝到用户空间 对于select和poll来说，所有文件描述符都是在用户态被加入其文件描述符集合的，每次调用都需要将整个集合拷贝到内核态；epoll则将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都需要执行一个系统调用。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，epoll可能会慢于select和poll由于这些大量的系统调用开销。 select使用线性表描述文件描述符集合，文件描述符有上限；poll使用链表来描述；epoll底层通过红黑树来描述，并且维护一个ready list，将事件表中已经就绪的事件添加到这里，在使用epoll_wait调用时，仅观察这个list中有没有数据即可。 select和poll的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，它们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll则不需要去以这种方式检查，当有活动产生时，会自动触发epoll回调函数通知epoll文件描述符，然后内核将这些就绪的文件描述符放到之前提到的ready list中等待epoll_wait调用后被处理。 select和poll都只能工作在相对低效的LT模式下，而epoll同时支持LT和ET模式。 综上，当监测的fd数量较小，且各个fd都很活跃的情况下，建议使用select和poll；当监听的fd数量较多，且单位时间仅部分fd活跃的情况下，使用epoll会明显提升性能。 LT（电平触发） 假设委托内核检测读事件 -> 检测fd的读缓冲区 读缓冲区有数据 - > epoll检测到了会给用户通知 a.用户不读数据，数据一直在缓冲区，epoll 会一直通知 b.用户只读了一部分数据，epoll会通知 c.缓冲区的数据读完了，不通知 LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的。 效率会低于ET触发，尤其在高并发大流量的情况下。但是LT对代码编写要求比较低，不容易出现问题。LT模式服务编写上的表现是：只要有数据没有被获取，内核就不断通知你，因此不用担心时间丢失的情况。 ET（边缘触发） 假设委托内核检测读事件 -> 检测fd的读缓冲区 读缓冲区有数据 - > epoll检测到了会给用户通知 a.用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了 b.用户只读了一部分数据，epoll不通知 c.缓冲区的数据读完了，不通知 ET（edge - triggered）是高速工作方式，只支持 no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。 效率非常高，在高并发大流量的情况下，会比LT少很多epoll的系统调用，因此效率高。但是对编程要求高，需要细致的处理每个请求，否则容易发生丢失事件的情况 EPOLLIN ： 表示对应的文件描述符可以读（包括对端SOCKET正常关闭）； EPOLLOUT： 表示对应的文件描述符可以写； EPOLLPRI： 表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）； EPOLLERR： 表示对应的文件描述符发生错误； EPOLLHUP： 表示对应的文件描述符被挂断； EPOLLET： 将 EPOLL设为边缘触发(Edge Triggered)模式（默认为水平触发），这是相对于水平触发(Level Triggered)来说的。 EPOLLONESHOT： 只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里 Reactor Reactor要求主线程（I/O处理单元，下同）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元，下同）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。 Proactor Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。如主线程读完成后users[sockfd].read()，选择一个工作线程来处理客户请求pool->append(users + sockfd)。 同步I/O方式模拟出Proactor模式原理：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。 工作流程如下： 1）主线程往epoll内核事件表中注册socket上的读就绪事件。 2）主线程调用epoll_wait等待socket上有数据可读。 3）当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。 4）睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。 5）主线程调用epoll_wait等待socket可写。 6）当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。 socket Socket又称为套接字，它是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。通过调用接口中已经实现的方法建立两个进程之间的连接和通信。 服务器的工作流程： （1）创建 socket：创建服务端的socket。 （2）绑定 bind：把服务端用于通信的地址和端口绑定到socket上。 （3）监听 listen：把socket设置为监听模式。 （4）接受连接 accept：接受客户端的连接。 （5）通信 recv( ) / send( ) ：与客户端通信，接收客户端发过来的报文后，回复处理结果，重复此过程。 （6）关闭 close( )：关闭socket，释放资源。 客户端工作流程： （1）创建 socket：创建客户端的socket。 （2）发送连接 connect( )：向服务器发起连接请求 （3）通信 recv( ) / send( )：与服务端通信，发送一个报文后等待回复，然后再发下一个报文。重复此过程，直到全部的数据被发送完。 （4）关闭 close( )：关闭socket，释放资源。 线程池 threadpool(connection_pool *connPool, int thread_number = 8, int max_request = 10000); ~threadpool(); bool append(T *request); // 向请求队列中插入任务请求 static void *worker(void *arg); // 工作线程运行的函数，它不断从工作队列中取出任务并执行之 void run(); //调用void http_conn::process() 所谓线程池，就是一个pthread_t类型的普通数组，通过pthread_create()函数创建m_thread_number个线程，用来执行worker()函数以执行每个请求处理函数（HTTP请求的process函数），通过pthread_detach()将线程设置成脱离态（detached）后，当这一线程运行结束时，它的资源会被系统自动回收，而不再需要在其它线程中对其进行 pthread_join() 操作。 操作工作队列一定要加锁（locker），因为它被所有线程共享。 我们用信号量来标识请求队列中的请求数，通过m_queuestat.wait();来等待一个请求队列中待处理的HTTP请求，然后交给线程池中的空闲线程来处理。 为什么要使用线程池？ 当你需要限制你应用程序中同时运行的线程数时，线程池非常有用。因为启动一个新线程会带来性能开销，每个线程也会为其堆栈分配一些内存等。为了任务的并发执行，我们可以将这些任务任务传递到线程池，而不是为每个任务动态开启一个新的线程。（空间换时间） 线程池中的线程数量是依据什么确定的？ 回答 线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors/cores)的数量N：如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程阻塞）；对于IO密集型的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导致资源浪费，公式：最佳线程数 = CPU当前可使用的Cores数 * 当前CPU的利用率 * (1 + CPU等待时间 / CPU处理时间) HTTP连接 HTTP的报文处理流程分为以下三个步骤： 连接处理：浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，工作线程从任务队列中取出一个任务进行处理。 处理报文请求：工作线程取出任务后，调用process_read函数，通过主、从状态机对请求报文进行解析。 返回响应报文：解析完之后，跳转do_request函数生成响应报文，通过process_write写入buffer，返回给浏览器端。 void http_conn::init(int sockfd, const sockaddr_in &addr); // 外部调用初始化 bool http_conn::read_once(); // 读取数据存储到m_read_buf void http_conn::process(); // 调用process_read()和process_write(read_ret) HTTP_CODE process_read(); // 从m_read_buf读取，并处理请求报文 HTTP_CODE parse_request_line(char *text); // 主状态机解析报文中的请求行数据 获得请求方法，目标url及http版本号 HTTP_CODE parse_headers(char *text); // 主状态机解析报文中的请求头数据 HTTP_CODE parse_content(char *text); // 主状态机解析报文中的请求内容 char *get_line() { return m_read_buf + m_start_line; }; // get_line用于将指针向后偏移，指向未处理的字符 http_conn::LINE_STATUS http_conn::parse_line()// 返回值为行的读取状态，有LINE_OK,LINE_BAD,LINE_OPEN bool process_write(HTTP_CODE ret); // //向m_write_buf写入响应报文数据 通过while循环，对主从状态机进行封装，对报文的每一行进行循环处理。这里的主状态机，指的是process_read()函数，从状态机是指parse_line()函数。 从状态机负责读取报文的一行（并对其中的\\r\\n进行修改为\\0\\0），主状态机负责对该行数据进行解析，主状态机内部调用从状态机，从状态机驱动主状态机。它们之间的关系如下图所示： 主状态机初始状态是CHECK_STATE_REQUESTLINE，而后调用parse_request_line()解析请求行，获得HTTP的请求方法、目标URL以及HTTP版本号，状态变为CHECK_STATE_HEADER。 此时进入循环体之后，调用parse_headers()解析请求头部信息。先要判断是空行还是请求头，空行进一步区分POST还是GET。若是请求头，则更新长短连接状态、host等等。 注：GET和POST请求报文的区别之一是有无消息体部分。 当使用POST请求时，需要进行CHECK_STATE_CONTENT的解析，取出POST消息体中的信息（用户名、密码）。 HTTP报文 HTTP报文分为请求报文和响应报文两种，其中，浏览器端向服务器发送的为请求报文，服务器处理后返回给浏览器端的为响应报文。 HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。 GET和POST是最常见的HTTP请求方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。 请求报文 GET 请求指定的页面内容，并返回实体主体 GET /favicon.ico HTTP/1.1 Host: 49.232.165.212:9006 Connection: keep-alive User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36 Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8 Referer: http://49.232.165.212:9006/ Accept-Encoding: gzip, deflate Accept-Language: zh,en-US;q=0.9,en;q=0.8,zh-TW;q=0.7,zh-CN;q=0.6 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据包含在请求体中。POST请求可能会导致新的资源的建立或者已有资源的修改。 POST /2CGISQL.cgi HTTP/1.1 Host: 49.232.165.212:9006 Connection: keep-alive Content-Length: 17 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://49.232.165.212:9006 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/111.0.0.0 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Referer: http://49.232.165.212:9006/1 Accept-Encoding: gzip, deflate Accept-Language: zh,en-US;q=0.9,en;q=0.8,zh-TW;q=0.7,zh-CN;q=0.6 user=a&password=a 请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本。 请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。 HOST，给出请求资源所在服务器的域名。 User-Agent，HTTP客户端程序的信息，该信息由你发出请求使用的浏览器来定义,并且在每个请求中自动发送等。 Accept，说明用户代理可处理的媒体类型。 Accept-Encoding，说明用户代理支持的内容编码。 Accept-Language，说明用户代理能够处理的自然语言集。 Content-Type，说明实现主体的媒体类型。 Content-Length，说明实现主体的大小。 Connection，连接管理，可以是Keep-Alive或close。 空行，请求头部后面的空行是必须的即使第四部分的请求数据为空，也必须有空行。 请求数据也叫主体，可以添加任意的其他数据。 GET和POST的区别？ 最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制。（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。 GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100（指示信息—表示请求已接收，继续处理）continue，浏览器再发送data，服务器响应200 ok（返回数据）。 响应报文 HTTP/1.1 200 OK Content-Length:360 Connection:keep-alive 状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为OK。 消息报头，用来说明客户端要使用的一些附加信息。 第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8。 空行，消息报头后面的空行是必须的。 响应正文，服务器返回给客户端的文本信息。空行后面的html部分为响应正文。 HTTP状态码 状态码 意义 解释 301 Permanently Moved 被请求的资源已永久移动到新位置，新的URL在Location头中给出，浏览器应该自动地访问新的URL。301为永久重定向。 302 Found 请求的资源现在临时从不同的URL响应请求。302为临时重定向。 200 OK 表示从客户端发来的请求在服务器端被正确处理 304 Not Modified 告诉浏览器可以从缓存中获取所请求的资源。 400 bad request 请求报文存在语法错误 403 forbidden 表示对请求资源的访问被服务器拒绝 404 not found 表示在服务器上没有找到请求的资源 500 internal sever error 表示服务器端在执行请求时发生了错误 503 service unavailable 表明服务器暂时处于超负载或正在停机维护，无法处理请求 日志 单例模式 最常用的设计模式之一，保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。 实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例。 懒汉模式 ：即非常懒，不用的时候不去初始化，所以在第一次被使用时才进行初始化（实例的初始化放在getinstance函数内部） 经典的线程安全懒汉模式，使用双检测锁模式（p == NULL检测了两次） 利用局部静态变量实现线程安全懒汉模式 饿汉模式：即迫不及待，在程序运行时立即初始化（实例的初始化放在getinstance函数外部，getinstance函数仅返回该唯一实例的指针）。 日志系统的运行机制 日志文件 局部变量的懒汉模式获取实例 生成日志文件，并判断同步和异步写入方式 同步 判断是否分文件 直接格式化输出内容，将信息写入日志文件 异步 判断是否分文件 格式化输出内容，将内容写入阻塞队列（循环数组、条件变量实现），创建一个写线程，从阻塞队列取出内容写入日志文件 定时器 服务器首先创建定时器容器链表，然后用统一事件源将（统一事件源，是指将信号事件与其他事件一样被处理。）异常事件，读写事件和信号事件统一处理，根据不同事件的对应逻辑使用定时器。 具体的，浏览器与服务器连接时，创建该连接对应的定时器，并将该定时器添加到定时器容器链表上； 处理异常事件时，执行定时事件，服务器关闭连接，从链表上移除对应定时器； 处理定时信号时，将定时标志设置为true，以便执行定时器处理函数； 处理读/写事件时，若某连接上发生读事件或某连接给浏览器发送数据，将对应定时器向后移动，否则，执行定时事件。 MySQL连接 每一个HTTP连接获取一个数据库连接，获取其中的用户账号密码进行对比（有点损耗资源，实际场景下肯定不是这么做的），而后再释放该数据库连接。 创建了数据库连接池、链表实现（跟线程池类似） 使用mysql_init()初始化连接 使用mysql_real_connect()建立一个到mysql数据库的连接 使用mysql_query()执行查询语句 使用result = mysql_store_result(mysql)获取结果集 使用mysql_num_fields(result)获取查询的列数，mysql_num_rows(result)获取结果集的行数 通过mysql_fetch_row(result)不断获取下一行，然后循环输出 使用mysql_free_result(result)释放结果集所占内存 使用mysql_close(conn)关闭连接 注册登录 压力测试 手写线程池 #include #include #include #include #include #include using namespace std; template class threadpool { public: threadpool(int thread_number = 8, int max_request = 10000); ~threadpool(); bool append(T request); private: static void *worker(void *arg); void run(); private: int m_thread_number; // 线程池中的线程数 int m_max_requests; // 请求队列中允许的最大请求数 pthread_t *m_threads; // 描述线程池的数组，其大小为m_thread_number list m_workqueue; // 请求队列 链表实现 pthread_mutex_t m_mutex; // 互斥锁 sem_t m_sem; // 信号量 int sval; // 信号量值 bool m_stop; //是否结束线程 }; template threadpool::threadpool(int thread_number, int max_requests) : m_thread_number(thread_number), m_max_requests(max_requests), m_stop(false), m_threads(NULL) { m_threads = new pthread_t[m_thread_number]; sem_init(&m_sem, 0, 0); pthread_mutex_init(&m_mutex, NULL); for (int i = 0; i threadpool::~threadpool() { delete[] m_threads; m_stop = true; } template bool threadpool::append(T request) { pthread_mutex_lock(&m_mutex); if (m_workqueue.size() > m_max_requests) { pthread_mutex_unlock(&m_mutex); return false; } m_workqueue.push_back(request); pthread_mutex_unlock(&m_mutex); sem_post(&m_sem); // 解锁 +1 sem_getvalue(&m_sem,&sval); cout void *threadpool::worker(void *arg) { threadpool *pool = (threadpool *)arg; pool->run(); } template void threadpool::run() { while (!m_stop) { sem_wait(&m_sem); // 加锁 -1 =0阻塞 pthread_mutex_lock(&m_mutex); if (m_workqueue.empty()) { pthread_mutex_unlock(&m_mutex); continue; } T request = m_workqueue.front(); m_workqueue.pop_front(); sem_getvalue(&m_sem,&sval); cout *pool = NULL; pool = new threadpool; for(int i =1;iappend(i); } sleep(5); //防止子线程没有抢占到CPU且此时主线程已经执行完并退出 } Copyright © YZJ 2023 all right reserved，powered by Gitbook更新时间： 2023-04-10 16:06:52 "}}